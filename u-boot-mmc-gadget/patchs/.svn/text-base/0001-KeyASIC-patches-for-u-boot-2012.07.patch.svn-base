From 6fce994e6c1273824f093582b362e77cdbd9b358 Mon Sep 17 00:00:00 2001
From: Sam Ho <samho@keyasic.com>
Date: Fri, 10 Aug 2012 16:41:19 +0800
Subject: [PATCH] KeyASIC patches for u-boot-2012.07.

---
 Makefile                                       |   66 +-
 arch/arm/cpu/arm926ejs/cpu.c                   |   21 +
 arch/arm/cpu/arm926ejs/keyasic/Makefile        |   59 +
 arch/arm/cpu/arm926ejs/keyasic/config.mk       |   32 +
 arch/arm/cpu/arm926ejs/keyasic/cpu.c           |  518 ++++++++
 arch/arm/cpu/arm926ejs/keyasic/cpu_clk.c       |  501 ++++++++
 arch/arm/cpu/arm926ejs/keyasic/ka2000.c        |   31 +
 arch/arm/cpu/arm926ejs/keyasic/ka2000_define.h |  244 ++++
 arch/arm/cpu/arm926ejs/keyasic/ka2000_mmc.c    |  541 ++++++++
 arch/arm/cpu/arm926ejs/keyasic/ka2000_spi.c    |  660 ++++++++++
 arch/arm/cpu/arm926ejs/keyasic/lowlevel_init.S |   58 +
 arch/arm/cpu/arm926ejs/keyasic/misc_init.S     |   53 +
 arch/arm/cpu/arm926ejs/keyasic/reset.S         |   31 +
 arch/arm/cpu/arm926ejs/keyasic/rw_support.S    |  105 ++
 arch/arm/cpu/arm926ejs/keyasic/sdctrl.c        | 1568 ++++++++++++++++++++++++
 arch/arm/cpu/arm926ejs/keyasic/sdctrl.h        |   30 +
 arch/arm/cpu/arm926ejs/keyasic/sdswitch.c      |  919 ++++++++++++++
 arch/arm/cpu/arm926ejs/keyasic/sdswitch.h      |   69 ++
 arch/arm/cpu/arm926ejs/keyasic/timer.c         |  115 ++
 arch/arm/include/asm/arch-keyasic/emac_defs.h  |  393 ++++++
 arch/arm/include/asm/arch-keyasic/emif_defs.h  |   87 ++
 arch/arm/include/asm/arch-keyasic/gpio_defs.h  |   66 +
 arch/arm/include/asm/arch-keyasic/hardware.h   |   94 ++
 arch/arm/include/asm/arch-keyasic/i2c_defs.h   |   99 ++
 arch/arm/include/asm/arch-keyasic/nand_defs.h  |   45 +
 arch/arm/include/asm/arch-keyasic/reg_defs.h   |  252 ++++
 arch/arm/include/asm/mach-types.h              |    1 +
 arch/arm/lib/board.c                           |    9 +-
 board/keyasic/common/Makefile                  |   52 +
 board/keyasic/common/misc.c                    |   28 +
 board/keyasic/ka2000/Makefile                  |   49 +
 board/keyasic/ka2000/board_init.S              |   29 +
 board/keyasic/ka2000/config.mk                 |   43 +
 board/keyasic/ka2000/ka2000.c                  |  168 +++
 board/keyasic/ka2000/led.c                     |   31 +
 boards.cfg                                     |    1 +
 common/Makefile                                |    3 +-
 common/cmd_boot.c                              |    4 +-
 common/cmd_bootm.c                             |    4 +-
 common/cmd_clk.c                               |   91 ++
 common/cmd_mem.c                               |   58 +-
 common/cmd_mmc.c                               |   99 +-
 common/cmd_sf.c                                |    5 +
 common/env_common.c                            |    2 +
 common/image.c                                 |   19 +-
 common/main.c                                  |   39 +-
 config.mk                                      |    2 +-
 drivers/mtd/spi/spi_flash.c                    |   30 +-
 drivers/serial/ns16550.c                       |   24 +-
 drivers/serial/serial.c                        |    2 +-
 drivers/spi/ka2000_spi.c                       |   85 ++
 include/clk.h                                  |   46 +
 include/common.h                               |    1 +
 include/configs/ka2000.h                       |  313 +++++
 include/configs/ka2000_0929.h                  |  186 +++
 include/configs/ka2000_1108.h                  |  187 +++
 include/configs/ka2000_1118.h                  |  231 ++++
 include/configs/ka2000_boot1.h                 |  236 ++++
 include/part.h                                 |    6 +
 include/part_cmd.h                             |  152 +++
 keyasic_config.sh                              |    2 +
 keyasic_make.sh                                |    1 +
 62 files changed, 8829 insertions(+), 67 deletions(-)
 create mode 100644 arch/arm/cpu/arm926ejs/keyasic/Makefile
 create mode 100644 arch/arm/cpu/arm926ejs/keyasic/config.mk
 create mode 100644 arch/arm/cpu/arm926ejs/keyasic/cpu.c
 create mode 100644 arch/arm/cpu/arm926ejs/keyasic/cpu_clk.c
 create mode 100644 arch/arm/cpu/arm926ejs/keyasic/ka2000.c
 create mode 100644 arch/arm/cpu/arm926ejs/keyasic/ka2000_define.h
 create mode 100644 arch/arm/cpu/arm926ejs/keyasic/ka2000_mmc.c
 create mode 100644 arch/arm/cpu/arm926ejs/keyasic/ka2000_spi.c
 create mode 100644 arch/arm/cpu/arm926ejs/keyasic/lowlevel_init.S
 create mode 100644 arch/arm/cpu/arm926ejs/keyasic/misc_init.S
 create mode 100644 arch/arm/cpu/arm926ejs/keyasic/reset.S
 create mode 100644 arch/arm/cpu/arm926ejs/keyasic/rw_support.S
 create mode 100644 arch/arm/cpu/arm926ejs/keyasic/sdctrl.c
 create mode 100644 arch/arm/cpu/arm926ejs/keyasic/sdctrl.h
 create mode 100644 arch/arm/cpu/arm926ejs/keyasic/sdswitch.c
 create mode 100644 arch/arm/cpu/arm926ejs/keyasic/sdswitch.h
 create mode 100644 arch/arm/cpu/arm926ejs/keyasic/timer.c
 create mode 100644 arch/arm/include/asm/arch-keyasic/emac_defs.h
 create mode 100644 arch/arm/include/asm/arch-keyasic/emif_defs.h
 create mode 100644 arch/arm/include/asm/arch-keyasic/gpio_defs.h
 create mode 100644 arch/arm/include/asm/arch-keyasic/hardware.h
 create mode 100644 arch/arm/include/asm/arch-keyasic/i2c_defs.h
 create mode 100644 arch/arm/include/asm/arch-keyasic/nand_defs.h
 create mode 100644 arch/arm/include/asm/arch-keyasic/reg_defs.h
 create mode 100644 board/keyasic/common/Makefile
 create mode 100644 board/keyasic/common/misc.c
 create mode 100644 board/keyasic/ka2000/Makefile
 create mode 100644 board/keyasic/ka2000/board_init.S
 create mode 100644 board/keyasic/ka2000/config.mk
 create mode 100644 board/keyasic/ka2000/ka2000.c
 create mode 100644 board/keyasic/ka2000/led.c
 create mode 100644 common/cmd_clk.c
 create mode 100644 drivers/spi/ka2000_spi.c
 create mode 100644 include/clk.h
 create mode 100644 include/configs/ka2000.h
 create mode 100644 include/configs/ka2000_0929.h
 create mode 100644 include/configs/ka2000_1108.h
 create mode 100644 include/configs/ka2000_1118.h
 create mode 100644 include/configs/ka2000_boot1.h
 create mode 100644 include/part_cmd.h
 create mode 100644 keyasic_config.sh
 create mode 100644 keyasic_make.sh

diff --git a/Makefile b/Makefile
index eb37ea1..3ca9465 100644
--- a/Makefile
+++ b/Makefile
@@ -226,8 +226,8 @@ endif
 OBJS := $(addprefix $(obj),$(OBJS))
 
 LIBS  = lib/libgeneric.o
-LIBS += lib/lzma/liblzma.o
-LIBS += lib/lzo/liblzo.o
+#LIBS += lib/lzma/liblzma.o
+#LIBS += lib/lzo/liblzo.o
 LIBS += lib/zlib/libz.o
 ifeq ($(CONFIG_TIZEN),y)
 LIBS += lib/tizen/libtizen.o
@@ -245,31 +245,33 @@ ifeq ($(CONFIG_OF_EMBED),y)
 LIBS += dts/libdts.o
 endif
 LIBS += arch/$(ARCH)/lib/lib$(ARCH).o
-LIBS += fs/cramfs/libcramfs.o fs/fat/libfat.o fs/fdos/libfdos.o fs/jffs2/libjffs2.o \
-	fs/reiserfs/libreiserfs.o fs/ext2/libext2fs.o fs/yaffs2/libyaffs2.o \
-	fs/ubifs/libubifs.o
-LIBS += net/libnet.o
+#LIBS += fs/cramfs/libcramfs.o fs/fat/libfat.o fs/fdos/libfdos.o fs/jffs2/libjffs2.o \
+#	fs/reiserfs/libreiserfs.o fs/ext2/libext2fs.o fs/yaffs2/libyaffs2.o \
+#	fs/ubifs/libubifs.o
+LIBS += fs/fat/libfat.o fs/fdos/libfdos.o
+
+#LIBS += net/libnet.o
 LIBS += disk/libdisk.o
-LIBS += drivers/bios_emulator/libatibiosemu.o
+#LIBS += drivers/bios_emulator/libatibiosemu.o
 LIBS += drivers/block/libblock.o
-LIBS += drivers/dma/libdma.o
-LIBS += drivers/fpga/libfpga.o
-LIBS += drivers/gpio/libgpio.o
-LIBS += drivers/hwmon/libhwmon.o
-LIBS += drivers/i2c/libi2c.o
+#LIBS += drivers/dma/libdma.o
+#LIBS += drivers/fpga/libfpga.o
+#LIBS += drivers/gpio/libgpio.o
+#LIBS += drivers/hwmon/libhwmon.o
+#LIBS += drivers/i2c/libi2c.o
 LIBS += drivers/input/libinput.o
 LIBS += drivers/misc/libmisc.o
 LIBS += drivers/mmc/libmmc.o
-LIBS += drivers/mtd/libmtd.o
-LIBS += drivers/mtd/nand/libnand.o
-LIBS += drivers/mtd/onenand/libonenand.o
-LIBS += drivers/mtd/ubi/libubi.o
+#LIBS += drivers/mtd/libmtd.o
+#LIBS += drivers/mtd/nand/libnand.o
+#LIBS += drivers/mtd/onenand/libonenand.o
+#LIBS += drivers/mtd/ubi/libubi.o
 LIBS += drivers/mtd/spi/libspi_flash.o
-LIBS += drivers/net/libnet.o
-LIBS += drivers/net/phy/libphy.o
-LIBS += drivers/pci/libpci.o
-LIBS += drivers/pcmcia/libpcmcia.o
-LIBS += drivers/power/libpower.o
+#LIBS += drivers/net/libnet.o
+#LIBS += drivers/net/phy/libphy.o
+#LIBS += drivers/pci/libpci.o
+#LIBS += drivers/pcmcia/libpcmcia.o
+#LIBS += drivers/power/libpower.o
 LIBS += drivers/spi/libspi.o
 ifeq ($(CPU),mpc83xx)
 LIBS += drivers/qe/libqe.o
@@ -286,22 +288,22 @@ ifeq ($(CPU),mpc86xx)
 LIBS += arch/powerpc/cpu/mpc8xxx/ddr/libddr.o
 LIBS += arch/powerpc/cpu/mpc8xxx/lib8xxx.o
 endif
-LIBS += drivers/rtc/librtc.o
+#LIBS += drivers/rtc/librtc.o
 LIBS += drivers/serial/libserial.o
 ifeq ($(CONFIG_GENERIC_LPC_TPM),y)
 LIBS += drivers/tpm/libtpm.o
 endif
-LIBS += drivers/twserial/libtws.o
-LIBS += drivers/usb/eth/libusb_eth.o
-LIBS += drivers/usb/gadget/libusb_gadget.o
-LIBS += drivers/usb/host/libusb_host.o
-LIBS += drivers/usb/musb/libusb_musb.o
-LIBS += drivers/usb/phy/libusb_phy.o
-LIBS += drivers/usb/ulpi/libusb_ulpi.o
-LIBS += drivers/video/libvideo.o
-LIBS += drivers/watchdog/libwatchdog.o
+#LIBS += drivers/twserial/libtws.o
+#LIBS += drivers/usb/eth/libusb_eth.o
+#LIBS += drivers/usb/gadget/libusb_gadget.o
+#LIBS += drivers/usb/host/libusb_host.o
+#LIBS += drivers/usb/musb/libusb_musb.o
+#LIBS += drivers/usb/phy/libusb_phy.o
+#LIBS += drivers/usb/ulpi/libusb_ulpi.o
+#LIBS += drivers/video/libvideo.o
+#LIBS += drivers/watchdog/libwatchdog.o
 LIBS += common/libcommon.o
-LIBS += lib/libfdt/libfdt.o
+#LIBS += lib/libfdt/libfdt.o
 LIBS += api/libapi.o
 LIBS += post/libpost.o
 
diff --git a/arch/arm/cpu/arm926ejs/cpu.c b/arch/arm/cpu/arm926ejs/cpu.c
index 626384c..597f727 100644
--- a/arch/arm/cpu/arm926ejs/cpu.c
+++ b/arch/arm/cpu/arm926ejs/cpu.c
@@ -37,16 +37,36 @@ static void cache_flush(void);
 
 int cleanup_before_linux (void)
 {
+#define KA_PATCH 0
 	/*
 	 * this function is called just before we call linux
 	 * it prepares the processor for linux
 	 *
 	 * we turn off caches etc ...
 	 */
+#if KA_PATCH
+	uint32_t reg, val=0;
+#endif // KA_PATCH
 
 	disable_interrupts ();
 
 
+#if KA_PATCH
+	/* turn off I/D-cache */
+	icache_disable();
+//	dcache_disable();
+	l2_cache_disable();
+
+	/* disable mmu */
+	reg = get_cr();
+	val = (CR_M | CR_C);
+	set_cr(reg & !val);
+//	asm ("mrc p15, 0, %0, c7, c10, 3": :"r" (15));	/* test and clean dcache */
+
+	/* flush I/D-cache */
+	cache_flush();
+	printf("Cleanup - disable icache, dcache, mmu.\n");
+#else
 	/* turn off I/D-cache */
 	icache_disable();
 	dcache_disable();
@@ -54,6 +74,7 @@ int cleanup_before_linux (void)
 
 	/* flush I/D-cache */
 	cache_flush();
+#endif // KA patch
 
 	return 0;
 }
diff --git a/arch/arm/cpu/arm926ejs/keyasic/Makefile b/arch/arm/cpu/arm926ejs/keyasic/Makefile
new file mode 100644
index 0000000..8a798ca
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/keyasic/Makefile
@@ -0,0 +1,59 @@
+#
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# Copyright (C) 2007 Sergey Kubushyn <ksi@koi8.net>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(SOC).o
+
+COBJS-y				+= cpu.o timer.o
+COBJS-$(CONFIG_SOC_KA2000)	+= ka2000.o  ka2000_spi.o
+COBJS-$(CONFIG_KA2000_MMC)	+= sdctrl.o  ka2000_mmc.o sdswitch.o
+#sdio_test.o
+
+
+
+SOBJS	= reset.o rw_support.o misc_init.o
+
+ifndef CONFIG_SKIP_LOWLEVEL_INIT
+SOBJS	+= lowlevel_init.o
+endif
+
+SRCS	:= $(START:.o=.S) $(SOBJS:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y) $(SOBJS))
+START	:= $(addprefix $(obj),$(START))
+
+all:	$(obj).depend $(LIB)
+
+$(LIB):	$(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/arch/arm/cpu/arm926ejs/keyasic/config.mk b/arch/arm/cpu/arm926ejs/keyasic/config.mk
new file mode 100644
index 0000000..565adda
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/keyasic/config.mk
@@ -0,0 +1,32 @@
+#
+# (C) Copyright 2002
+# Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+PLATFORM_RELFLAGS += -fno-common -ffixed-r8 -msoft-float
+
+PLATFORM_CPPFLAGS += -march=armv5te
+# =========================================================================
+#
+# Supply options according to compiler version
+#
+# =========================================================================
+PLATFORM_RELFLAGS +=$(call cc-option,-mshort-load-bytes,$(call cc-option,-malignment-traps,))
diff --git a/arch/arm/cpu/arm926ejs/keyasic/cpu.c b/arch/arm/cpu/arm926ejs/keyasic/cpu.c
new file mode 100644
index 0000000..30a57cc
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/keyasic/cpu.c
@@ -0,0 +1,518 @@
+/*
+ * Copyright (C) 2010
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <common.h>
+#include <clk.h>
+#include <asm/arch/hardware.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/arch/reg_defs.h>
+#define PLL_INIT_FINISH (1 << 28)
+
+//#if 0
+#if OSC == 24
+#define OSC_MHZ   24
+#define HCLK_RATE  CONFIG_HCLK_RATIO
+#else
+#define OSC_MHZ   12
+#define HCLK_RATE  CONFIG_HCLK_RATIO
+#endif
+
+void buzzer_off(void)
+{
+	word_write (TCON0, word_read(TCON0) & ~1);
+}
+
+void buzzer_on(int tone)
+{
+	word_write(TCFG0, (word_read(TCFG0) & 0xffffff00) | 0x80);	//set Timer0 prescaler=128
+	word_write(TCFG1, (word_read(TCFG1) & 0xffeffffc));		//set Timer0 clk input=1/2, interrupt mode
+
+	//set Timer0 duty cycle and count
+	if(tone==0) { //low frequency for Fail indication
+		word_write(TCMPB0, 0x800);
+		word_write(TCNTB0, 0x1000);
+	} else {	//high frequency for Pass indication
+		word_write(TCMPB0, 0x100);
+		word_write(TCNTB0, 0x200);
+	}
+
+	word_write(TCON0, (word_read(TCON0) | 0x09));		//set Timer0 auto-reload and start it
+}
+
+//------------------------------------------------------------------------------
+static int null_delay(int t)
+{
+	volatile int i = 0;
+	int j = 0;
+	for (i = 0; i < t; i++) {
+		j++;
+	}
+	return j;
+}
+//------------------------------------------------------------------------------
+
+static void ka2000_set_gpio0(u32 val)
+{
+	u32 reg_val;
+
+	reg_val = word_read(0xa0005008);
+	if (val)
+		reg_val |= 1;
+	else
+		reg_val &= ~1;
+
+	word_write(0xa0005008, reg_val);
+	word_write(0xa0005000, 1);   /* set gpio output */
+}
+
+void set_clock(int mhz)
+{
+	volatile ulong val;
+	volatile int t = 1000000;
+	int div;
+	int div_n;
+	int div_k;
+	int div_m;
+#if 0
+	printf("\n0xa0000000 %08x\n", word_read(0xa0000000));
+	printf("0xa0000004 %08x\n", word_read(0xa0000004));
+	printf("0xa0000008 %08x\n", word_read(0xa0000008));
+	printf("0xa000000c %08x\n", word_read(0xa000000c));
+#endif
+
+	if (mhz == OSC) {
+		//word_write(0xa0000000, 0x10c26600);
+		printf("clk: OSC %dMHz\n", OSC_MHZ);
+		goto end_setclk; //return;
+	}
+
+// Normal mode (1)
+//     PLL        200MHz
+//     ARM        200Mhz
+//     HCLK        50MHz
+//     PCLK        50MHz
+//     SD Card     50MHz
+//     SDRAM      100MHz
+
+// mw a000000c 00006003 ; mw a000000c 00006001 ; mw a000000c 00006000 ; mw a0000004 00000100 ; mw a0000008 00040404 ; mw a000400c 83; mw a0004004 00; mw a0004000 a1; mw a000400c 3; mw a0000000 01c33717;
+
+	/*
+	mw a000000c 00006707 ; mw a000000c 00006705 ; mw a000000c 00006704 ;
+	mw a0000004 00000100 ; mw a0000008 00080808 ;
+
+	mw a000400c 83; mw a0004004 00; mw a0004000 61; mw a000400c 3;
+	mw a0000000 01c33715;
+	*/
+	/* CLK_OUT = FIN * (PLLDIVN [5:0] +1)/ ((PLLDIVM+1) * PLLDIVK [1:0]). */
+	div_m = 0;
+	div_k = 2;
+	div_n = ((mhz / OSC_MHZ) * (1 << div_k)) - 1;
+	div = (div_k << 14)  | (div_n << 8) | (div_m << 2);
+	if (word_read(0xa000000c) == div) {
+		printf("clk: PLL (div=%x)\n", div);
+		goto end_setclk; //return;
+	}
+
+	val = word_read(0xa0000000);
+	printf("div=%x\n", div);
+
+	//printf("Change to %dMHz, div m %d, n %d, k %d\n", mhz, div_m, div_n, div_k);
+
+	word_write(0xa0000000, val & ~(0xff));      //use OSC clk temporarily
+	//printf("Changing OSC... \n");
+	null_delay(10);
+
+#define PLL_RESET      2
+#define PLL_POWER_DOWN 1
+#define DIV_N(v) (v << 8)
+#define DIV_K(v) (v << 14)
+
+	/* Setup PLL freq change */
+
+	word_write(0xa000000c, 3 | div);
+	word_write(0xa000000c, 1 | div);
+	//word_write(0xa000000c, (div_k << 14) | (div_n << 8) | PLL_RESET | PLL_POWER_DOWN);  //0x4303
+	//word_write(0xa000000c, (div_k << 14) | (div_n << 8) | PLL_POWER_DOWN);                   //0x4301
+
+	null_delay(100);
+	/* doing PLL change */
+	word_write(0xa000000c, div);
+	//word_write(0xa000000c, (div_k << 14) | (div_n << 8));                               //0x4300
+
+	/* wait PLL init finish */
+	while((word_read(0xa0000000) & PLL_INIT_FINISH) != PLL_INIT_FINISH) {
+		null_delay(1);
+		if (t-- <= 0)
+			break;
+	};
+
+#define SPI_PLL(v) ((v) << 16)
+#define SDRAM_PLL(v) ((v) << 8)
+#define ARM_PLL(v) ((v) << 0)
+	/* PLL Frequency Select Register 1 - 0xa0000004 */
+	//word_write(0xa0000004, 0x00100000);
+	//word_write(0xa0000004, 0x000000100);
+	//word_write(0xa0000004, SPI_PLL(0x10) | SDRAM_PLL(0x1));
+
+	//word_write(0xa0000008, 0x06040004);
+	//word_write(0xa0000008, 0x00080808);     //0x00040404
+
+	word_write(0xa000400c, 0x83);
+	word_write(0xa0004004, 0x00);
+	word_write(0xa0004000, 0xa1);
+	word_write(0xa000400c, 0x03);
+	//mw a000400c 83; mw a0004004 00; mw a0004000 a1; mw a000400c 3
+
+#define SDHOST_SEL_PLL    (1 << 12)
+#define SDRAM_SEL_PLL     (1 << 4)
+#define ARM_CLK_RATIO(v)  ((v - 1) << 1)
+#define ARM_PLL_SRC       1
+	/* setting the new ratio */
+	//word_write(0xa0000000, val | 0x11 | ARM_CLK_RATIO(1) | 0x6600);
+	val &= ~SDHOST_SEL_PLL;
+	val |= 0x11  | 0x600 | ARM_CLK_RATIO(HCLK_RATE);
+
+end_setclk:
+	word_write(0xa0000008, 0x00040404);     //0x00040404 //0x00080808 //0x04040404
+	word_write(0xa0000004, 0x00000000);
+	word_write(0xa0000014, 0x00000001);
+	if (mhz == OSC)  //12
+		word_write(0xa0000000, 0x10c26600);     //0x10c26600
+	else {          //PLL
+		word_write(0xa0000000, 0x01c33313);    //0625=0x01c33717, 0x01c33317, 0x01c37317, 0x01c37313, 0x01c33313, 0x01c33311
+		//word_write(0xa0000000, 0x01c33317);
+	}
+	// word_write(0xa0000000, val );
+	//word_write(0xa0000000, val | SDRAM_SEL_PLL | ARM_PLL_SRC | ARM_CLK_RATIO(1));
+	printf("scu: %08x,%08x,%08x,%08x,%x\n", word_read(0xa0000000), word_read(0xa0000004), word_read(0xa0000008), word_read(0xa000000c), word_read(0xa0000014));
+
+}
+
+#ifdef CONFIG_SOC_KA2000
+//ref in include/configs/ka2000.h
+int clk_get(enum ka_clk_ids id)
+{
+	return CONFIG_SYS_HZ_CLOCK;
+}
+#endif /* CONFIG_SOC_KA2000 */
+
+#ifdef CONFIG_DISPLAY_CPUINFO
+static unsigned pll_clk_mhz()
+{
+	//TODO: placeholder
+
+	return (CONFIG_SYS_CLK_FREQ / 1000);
+}
+
+int print_cpuinfo(void)
+{
+	// printf("Cores: ARM %d MHz\n", 192); 	//pll_clk_mhz());
+	// printf("SDRAM: %d MHz\n", 96);	//pll_clk_mhz());
+
+	return 0;
+}
+#endif /* CONFIG_DISPLAY_CPUINFO */
+
+#ifdef CONFIG_ARCH_CPU_INIT
+int arch_cpu_init(void)
+{
+	/* disable wifi module power by disable gpio 0 */
+	ka2000_set_gpio0(0);
+
+	//TODO: placeholder
+	if (CONFIG_SET_CLOCK)
+		set_clock(CONFIG_SYS_CLK_FREQ / 1000000);
+
+	/*	//change to normal mode
+		word_write(0xa0000000,0x00000000);
+		word_write(0xa0000004,0x00000100);
+		word_write(0xa0000008,0x00101010);
+		word_write(0xa000000c,0x00006003);
+		word_write(0xa000000c,0x00006001);
+		word_write(0xa000000c,0x00006000);
+		while((word_read(0xa0000000) & 0x10000000) != 0x10000000) {};
+		word_write(0xa0000000,0x00037713);
+	*/
+	return 0;
+}
+#endif /* CONFIG_ARCH_CPU_INIT */
+
+#if defined(CONFIG_ARCH_MISC_INIT)
+void pagetbl_setup(unsigned int phy_addr, unsigned int cache_enable, unsigned int write_buf)
+{
+	unsigned int base_addr = phy_addr >> 20;
+	word_write(0x01f04000 + (base_addr * 4), 0);
+	word_write(0x01f04000 + (base_addr * 4), (base_addr<<20) | (0x03<<10) | (0x00<<5) | (1<<4) | (cache_enable<<3) | (write_buf<<2) | 0x02);
+}
+void pagetbl_init(void)
+{
+	pagetbl_setup(0x01f00000, 0x00, 0x00);	//setup page table addr, non-cacheable, non-buffered, size 1MB
+	//pagetbl_setup(0x00000000, 0x00, 0x00);	//setup page table addr, non-cacheable, non-buffered, size 1MB
+	pagetbl_setup(0xa0000000, 0x00, 0x00);	//setup peripheral addr, non-cacheable, non-buffered, size 1MB
+}
+
+int arch_misc_init(void)
+{
+extern void cpu_setup(void);
+
+//	int result = 1;
+	int i;
+//	uint32_t reg;
+
+	cpu_setup();
+
+	buzzer_on(1);
+
+	pagetbl_init();
+	for(i = 0; i < 31; i++) //setup a special mem location, cacheable, buffered, write-back mode, size 1MB
+		pagetbl_setup((i<<20), 0x01, 0x01);
+	//printf("Page Table setup completed.\n");
+
+#if 1//def CONFIG_SKIP_LOWLEVEL_INIT
+	//printf("ICACHE disabled.\n");
+#else
+	icache_enable();
+	//printf("ICACHE enabled.\n");
+#endif /* CONFIG_SKIP_LOWLEVEL_INIT */
+
+#ifdef CONFIG_SYS_DISABLE_DCACHE
+	//printf("DCACHE & MMU disabled.\n");
+#else
+	//enable MMU & dcache
+	//dcache_enable();
+	reg = get_cr();
+	set_cr(reg | CR_M | CR_S | CR_R | CR_C);	//set MMU, system MMU protect, ROM MMU protect, dcache
+	nop();
+	nop();
+	//printf("DCACHE & MMU enabled. CR=0x%x\n", reg);
+#ifdef CONFIG_SYS_CACHE_TEST
+	for(i=0; i<0x100; i++)
+		word_write(0x00200180 + (i*4),i);
+
+	for(i=0; i<0x100; i++) {
+		if(word_read(0x00200180 + (i*4)) != i)
+			printf("Cache test Failed. Exp: 0x%x, Act: 0x%x\n", i, word_read(0x00200180 + (i*4)));
+	}
+	word_write(0xc1800000, 0x01);
+	printf("Cache test completed.\n");
+#endif /* CONFIG_SYS_CACHE_TEST */
+
+#endif /* CONFIG_SYS_DISABLE_DCACHE */
+
+	return 0;
+}
+
+int program_mode(void)
+{
+	//TODO: placeholder
+	//Assume: SSI & SD Host clk are enabled, SD card initialized
+	//Init SD Controller
+	//Init SSI Controller
+	//Allocate buffer for write data
+
+	//Read data from SD Card into buffer (block-512B)
+	//Switch SSI control to NOR Flash (def was Autoload)
+	//Erase NOR Flash sector (sector-4kB)
+	//Write data to NOR Flash (page-256B)
+	//Read & Compare NOR Flash data	(page-256B)
+
+	//Free buffer
+
+	return 0;
+}
+
+#endif /* CONFIG_ARCH_MISC_INIT */
+
+#ifdef CONFIG_CMD_CLK
+#define ARM_RATIO(v,s)  ((v - 1) << s)
+#define PLL_RATIO(v,s)  ((v == 2) ? (1 << s) : (1 << (int)(v / 2)) << s)
+static clk_speed_t clk_dev;
+
+int pll_ratio(int input, int type)
+{
+	//type: 1=div to reg (set), 0=reg to div (check)
+	int result = 0;
+	switch(input) {
+	case 0:
+		result = type ? 0  : 1;
+		break;
+	case 1:
+		result = type ? 0  : 2;
+		break;
+	case 2:
+		result = type ? 1  : 3;
+		break;
+	case 3:
+		result = type ? 2  : 1;
+		break;
+	case 4:
+		result = 4;
+		break;
+	case 6:
+		result = type ? 8  : 1;
+		break;
+	case 8:
+		result = type ? 16 : 6;
+		break;
+	case 16:
+		result = type ? 0  : 8;
+		break;
+	default:
+		result = type ? 0  : 1;
+		break;
+	}
+	return result;
+}
+
+unsigned long set_clock_f(int pllclk, int armclk, int hclk, int sdclk)
+{
+	volatile ulong val;
+	volatile int t = 1000000;
+	int div;
+	int div_n;
+	int div_k = 2;
+	int div_m = 0;
+	unsigned int uartval;
+	int sdratio = 0;
+	int hclkratio = 0;
+	int armratio = 0;
+
+	printf("\npre: %08x,%08x,%08x,%08x,%x", word_read(0xa0000000), word_read(0xa0000004), word_read(0xa0000008), word_read(0xa000000c), word_read(0xa0000014));
+	//set pll clock
+	if (armclk == clk_dev.osc_clk) {
+		pllclk = clk_dev.osc_clk;
+		printf("OSC %dMHz\n", OSC_MHZ);
+		goto set_ratio;
+	}
+
+	div_n = ((pllclk / clk_dev.osc_clk) * (1 << div_k)) - 1;
+	div = (div_k << 14)  | (div_n << 8) | (div_m << 2);
+	printf(" (PLL %dMHz, div=%x)", pllclk, div);
+
+	if (word_read(0xa000000c) == div)
+		goto set_ratio;
+
+	val = word_read(0xa0000000);
+	word_write(0xa0000000, val & ~(0xff));      //use OSC clk temporarily
+	null_delay(10);
+
+	word_write(0xa000000c, 3 | div);
+	word_write(0xa000000c, 1 | div);
+	null_delay(100);
+	word_write(0xa000000c, div);
+	/* wait PLL init finish */
+	while((word_read(0xa0000000) & PLL_INIT_FINISH) != PLL_INIT_FINISH) {
+		null_delay(1);
+		if (t-- <= 0) {
+			armclk = hclk = pllclk = sdclk = clk_dev.osc_clk;
+			printf("\nFailed to change PLL, use OSC.");
+			break;
+		}
+	};
+
+set_ratio:
+	//set uart
+	uartval = (unsigned int)((hclk * 1000000 / 16 / clk_dev.baudrate) - 1);
+	word_write(0xa000400c, 0x83);
+	word_write(0xa0004004, 0x00);
+	word_write(0xa0004000, uartval/*0xa1*/);
+	word_write(0xa000400c, 0x03);
+	null_delay(10);
+
+	if (armclk == clk_dev.osc_clk) {
+		word_write(0xa0000000, 0x10c26600);     //0x10c26600
+		word_write(0xa000000c, 0x3);
+		goto done;
+	}
+
+	/* setting the new ratio */
+	sdratio = (int)(pllclk / sdclk);
+	hclkratio = (int)(armclk / hclk);
+	armratio = (int)(pllclk / armclk);
+
+	/*if(sdratio == 1)
+	    word_write(0xa0000008, 0x00000000);
+	else
+	    word_write(0xa0000008, PLL_RATIO(sdratio,16) | PLL_RATIO(sdratio,8) | PLL_RATIO(sdratio,0)); */
+	word_write(0xa0000008, (pll_ratio(sdratio,1) << 16) | (pll_ratio(sdratio,1) << 8) | pll_ratio(sdratio,1));
+
+	/*if(armratio == 1)
+	    word_write(0xa0000004, 0x00000000);
+	else
+	    word_write(0xa0000004, 0x00000000 | PLL_RATIO(armratio,0));*/
+	word_write(0xa0000004, 0x00000000 | pll_ratio(armratio,1));
+
+	word_write(0xa0000000, 0x01c33301 | ARM_RATIO(hclkratio,1));    //0x01c33313, 0x01c37313
+
+done:
+	printf("\npost:%08x,%08x,%08x,%08x,%x", word_read(0xa0000000), word_read(0xa0000004), word_read(0xa0000008), word_read(0xa000000c), word_read(0xa0000014));
+	clk_dev.pllclk = pllclk;
+	clk_dev.armclk = armclk;
+	clk_dev.hclk = hclk;
+	clk_dev.sdclk = clk_dev.sdioclk = sdclk;
+	return 0;
+}
+
+unsigned long get_clock_f(void)
+{
+	unsigned int val = 0;
+	unsigned int sdfreq = 0;
+	int div_n = 0;
+	int div_k = 2;
+	int div_m = 0;
+	int armratio = 0;
+
+	printf("\nscu: %08x,%08x,%08x,%08x,%x", word_read(0xa0000000), word_read(0xa0000004), word_read(0xa0000008), word_read(0xa000000c), word_read(0xa0000014));
+	val = word_read(0xa0000000);
+	if((val & 0x1) == 0) {
+		clk_dev.pllclk = clk_dev.armclk = clk_dev.hclk = clk_dev.sdclk = clk_dev.sdioclk = clk_dev.osc_clk;
+		return 0;
+	}
+
+	//PLL clock
+	div_n = (word_read(0xa000000c) >> 8) & 0x3f;
+	clk_dev.pllclk = (int)(clk_dev.osc_clk * (div_n + 1) / (1 << div_k) / (div_m + 1));
+
+	//ARM clock
+	armratio = word_read(0xa0000004) & 0x1f;
+	clk_dev.armclk = clk_dev.pllclk / pll_ratio(armratio,0);
+
+	//HCLK
+	clk_dev.hclk = clk_dev.armclk / (((val & 0xe) >> 1) + 1);
+
+	//SD, SDIO clock
+	sdfreq = word_read(0xa0000008);
+	clk_dev.sdclk = clk_dev.pllclk / pll_ratio((sdfreq & 0x1f),0);
+	clk_dev.sdioclk = clk_dev.pllclk / pll_ratio(((sdfreq >> 8) & 0x1f),0);
+
+	return 0;
+}
+
+clk_speed_t *clk_get_dev(void)
+{
+	clk_dev.set_clock_speed = set_clock_f;
+	clk_dev.get_clock_speed = get_clock_f;
+	return (clk_speed_t *) &clk_dev;
+}
+
+
+#endif
diff --git a/arch/arm/cpu/arm926ejs/keyasic/cpu_clk.c b/arch/arm/cpu/arm926ejs/keyasic/cpu_clk.c
new file mode 100644
index 0000000..584b3d7
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/keyasic/cpu_clk.c
@@ -0,0 +1,501 @@
+/*
+ * Copyright (C) 2010
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <common.h>
+#include <clk.h>
+#include <asm/arch/hardware.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/arch/reg_defs.h>
+#define PLL_INIT_FINISH (1 << 28)
+
+//#if 0
+#if OSC == 24
+#define OSC_MHZ   24
+#define HCLK_RATE  CONFIG_HCLK_RATIO
+#else
+#define OSC_MHZ   12
+#define HCLK_RATE  CONFIG_HCLK_RATIO
+#endif
+
+void buzzer_off()
+{
+	word_write (TCON0, word_read(TCON0) & ~1);
+}
+
+void buzzer_on(int tone)
+{
+	word_write(TCFG0, (word_read(TCFG0) & 0xffffff00) | 0x80);	//set Timer0 prescaler=128
+	word_write(TCFG1, (word_read(TCFG1) & 0xffeffffc));		//set Timer0 clk input=1/2, interrupt mode
+
+	//set Timer0 duty cycle and count
+	if(tone==0) { //low frequency for Fail indication
+		word_write(TCMPB0, 0x800);
+		word_write(TCNTB0, 0x1000);
+	} else {	//high frequency for Pass indication
+		word_write(TCMPB0, 0x100);
+		word_write(TCNTB0, 0x200);
+	}
+
+	word_write(TCON0, (word_read(TCON0) | 0x09));		//set Timer0 auto-reload and start it
+}
+
+//------------------------------------------------------------------------------
+static void ka2000_set_gpio0(u32 val)
+{
+	u32 reg_val;
+
+	reg_val = word_read(0xa0005008);
+	if (val)
+		reg_val |= 1;
+	else
+		reg_val &= ~1;
+
+	word_write(0xa0005008, reg_val);
+	word_write(0xa0005000, 1);   /* set gpio output */
+}
+
+void set_clock(int mhz)
+{
+	volatile ulong val;
+	volatile int t = 1000000;
+	int div;
+	int div_n;
+	int div_k;
+	int div_m;
+#if 0
+	printf("\n0xa0000000 %08x\n", word_read(0xa0000000));
+	printf("0xa0000004 %08x\n", word_read(0xa0000004));
+	printf("0xa0000008 %08x\n", word_read(0xa0000008));
+	printf("0xa000000c %08x\n", word_read(0xa000000c));
+#endif
+
+	if (mhz == OSC) {
+		//word_write(0xa0000000, 0x10c26600);
+		printf("clk: OSC %dMHz\n", OSC_MHZ);
+		goto end_setclk; //return;
+	}
+
+// Normal mode (1)
+//     PLL        200MHz
+//     ARM        200Mhz
+//     HCLK        50MHz
+//     PCLK        50MHz
+//     SD Card     50MHz
+//     SDRAM      100MHz
+
+// mw a000000c 00006003 ; mw a000000c 00006001 ; mw a000000c 00006000 ; mw a0000004 00000100 ; mw a0000008 00040404 ; mw a000400c 83; mw a0004004 00; mw a0004000 a1; mw a000400c 3; mw a0000000 01c33717;
+
+	/*
+	mw a000000c 00006707 ; mw a000000c 00006705 ; mw a000000c 00006704 ;
+	mw a0000004 00000100 ; mw a0000008 00080808 ;
+
+	mw a000400c 83; mw a0004004 00; mw a0004000 61; mw a000400c 3;
+	mw a0000000 01c33715;
+	*/
+	/* CLK_OUT = FIN * (PLLDIVN [5:0] +1)/ ((PLLDIVM+1) * PLLDIVK [1:0]). */
+	div_m = 0;
+	div_k = 2;
+	div_n = ((mhz / OSC_MHZ) * (1 << div_k)) - 1;
+	div = (div_k << 14)  | (div_n << 8) | (div_m << 2);
+	if (word_read(0xa000000c) == div) {
+		printf("clk: PLL (div=%x)\n", div);
+		goto end_setclk; //return;
+	}
+
+	val = word_read(0xa0000000);
+	printf("div=%x\n", div);
+
+	//printf("Change to %dMHz, div m %d, n %d, k %d\n", mhz, div_m, div_n, div_k);
+
+	word_write(0xa0000000, val & ~(0xff));      //use OSC clk temporarily
+	//printf("Changing OSC... \n");
+	null_delay(10);
+
+#define PLL_RESET      2
+#define PLL_POWER_DOWN 1
+#define DIV_N(v) (v << 8)
+#define DIV_K(v) (v << 14)
+
+	/* Setup PLL freq change */
+
+	word_write(0xa000000c, 3 | div);
+	word_write(0xa000000c, 1 | div);
+	//word_write(0xa000000c, (div_k << 14) | (div_n << 8) | PLL_RESET | PLL_POWER_DOWN);  //0x4303
+	//word_write(0xa000000c, (div_k << 14) | (div_n << 8) | PLL_POWER_DOWN);                   //0x4301
+
+	null_delay(100);
+	/* doing PLL change */
+	word_write(0xa000000c, div);
+	//word_write(0xa000000c, (div_k << 14) | (div_n << 8));                               //0x4300
+
+	/* wait PLL init finish */
+	while((word_read(0xa0000000) & PLL_INIT_FINISH) != PLL_INIT_FINISH) {
+		null_delay(1);
+		if (t-- <= 0)
+			break;
+	};
+
+#define SPI_PLL(v) ((v) << 16)
+#define SDRAM_PLL(v) ((v) << 8)
+#define ARM_PLL(v) ((v) << 0)
+	/* PLL Frequency Select Register 1 - 0xa0000004 */
+	//word_write(0xa0000004, 0x00100000);
+	//word_write(0xa0000004, 0x000000100);
+	//word_write(0xa0000004, SPI_PLL(0x10) | SDRAM_PLL(0x1));
+
+	//word_write(0xa0000008, 0x06040004);
+	//word_write(0xa0000008, 0x00080808);     //0x00040404
+
+	word_write(0xa000400c, 0x83);
+	word_write(0xa0004004, 0x00);
+	word_write(0xa0004000, 0xa1);
+	word_write(0xa000400c, 0x03);
+	//mw a000400c 83; mw a0004004 00; mw a0004000 a1; mw a000400c 3
+
+#define SDHOST_SEL_PLL    (1 << 12)
+#define SDRAM_SEL_PLL     (1 << 4)
+#define ARM_CLK_RATIO(v)  ((v - 1) << 1)
+#define ARM_PLL_SRC       1
+	/* setting the new ratio */
+	//word_write(0xa0000000, val | 0x11 | ARM_CLK_RATIO(1) | 0x6600);
+	val &= ~SDHOST_SEL_PLL;
+	val |= 0x11  | 0x600 | ARM_CLK_RATIO(HCLK_RATE);
+
+end_setclk:
+	word_write(0xa0000008, 0x00040404);     //0x00040404 //0x00080808
+	word_write(0xa0000004, 0x00000000);
+	if (mhz == OSC)  //12
+		word_write(0xa0000000, 0x10c26600);     //0x10c26600
+	else {          //PLL
+		word_write(0xa0000000, 0x01c33313);    //0625=0x01c33717, 0x01c33317, 0x01c37317, 0x01c37313, 0x01c33313, 0x01c33311
+		//word_write(0xa0000000, 0x01c33317);
+	}
+	// word_write(0xa0000000, val );
+	//word_write(0xa0000000, val | SDRAM_SEL_PLL | ARM_PLL_SRC | ARM_CLK_RATIO(1));
+	printf("scu: %08x,%08x,%08x,%08x,%x\n", word_read(0xa0000000), word_read(0xa0000004), word_read(0xa0000008), word_read(0xa000000c), word_read(0xa0000014));
+
+}
+
+#ifdef CONFIG_SOC_KA2000
+//ref in include/configs/ka2000.h
+int clk_get(enum ka_clk_ids id)
+{
+	return CONFIG_SYS_HZ_CLOCK;
+}
+#endif /* CONFIG_SOC_KA2000 */
+
+#ifdef CONFIG_DISPLAY_CPUINFO
+static unsigned pll_clk_mhz()
+{
+	//TODO: placeholder
+
+	return (CONFIG_SYS_CLK_FREQ / 1000);
+}
+
+int print_cpuinfo(void)
+{
+	// printf("Cores: ARM %d MHz\n", 192); 	//pll_clk_mhz());
+	// printf("SDRAM: %d MHz\n", 96);	//pll_clk_mhz());
+
+	return 0;
+}
+#endif /* CONFIG_DISPLAY_CPUINFO */
+
+#ifdef CONFIG_ARCH_CPU_INIT
+int arch_cpu_init(void)
+{
+	/* disable wifi module power by disable gpio 0 */
+	ka2000_set_gpio0(0);
+
+	//TODO: placeholder
+	if (CONFIG_SET_CLOCK)
+		set_clock(CONFIG_SYS_CLK_FREQ / 1000000);
+
+	/*	//change to normal mode
+		word_write(0xa0000000,0x00000000);
+		word_write(0xa0000004,0x00000100);
+		word_write(0xa0000008,0x00101010);
+		word_write(0xa000000c,0x00006003);
+		word_write(0xa000000c,0x00006001);
+		word_write(0xa000000c,0x00006000);
+		while((word_read(0xa0000000) & 0x10000000) != 0x10000000) {};
+		word_write(0xa0000000,0x00037713);
+	*/
+	return 0;
+}
+#endif /* CONFIG_ARCH_CPU_INIT */
+
+#if defined(CONFIG_ARCH_MISC_INIT)
+void pagetbl_setup(unsigned int phy_addr, unsigned int cache_enable, unsigned int write_buf)
+{
+	unsigned int base_addr = phy_addr >> 20;
+	word_write(0x01f04000 + (base_addr * 4), 0);
+	word_write(0x01f04000 + (base_addr * 4), (base_addr<<20) | (0x03<<10) | (0x00<<5) | (1<<4) | (cache_enable<<3) | (write_buf<<2) | 0x02);
+}
+void pagetbl_init()
+{
+	pagetbl_setup(0x01f00000, 0x00, 0x00);	//setup page table addr, non-cacheable, non-buffered, size 1MB
+	//pagetbl_setup(0x00000000, 0x00, 0x00);	//setup page table addr, non-cacheable, non-buffered, size 1MB
+	pagetbl_setup(0xa0000000, 0x00, 0x00);	//setup peripheral addr, non-cacheable, non-buffered, size 1MB
+}
+
+int arch_misc_init(void)
+{
+	int result = 1, i;
+	uint32_t reg;
+
+	cpu_setup();
+
+	buzzer_on(1);
+
+	pagetbl_init();
+	for(i = 0; i < 31; i++) //setup a special mem location, cacheable, buffered, write-back mode, size 1MB
+		pagetbl_setup((i<<20), 0x01, 0x01);
+	//printf("Page Table setup completed.\n");
+
+#if 1//def CONFIG_SKIP_LOWLEVEL_INIT
+	//printf("ICACHE disabled.\n");
+#else
+	icache_enable();
+	//printf("ICACHE enabled.\n");
+#endif /* CONFIG_SKIP_LOWLEVEL_INIT */
+
+#ifdef CONFIG_SYS_DISABLE_DCACHE
+	//printf("DCACHE & MMU disabled.\n");
+#else
+	//enable MMU & dcache
+	//dcache_enable();
+	reg = get_cr();
+	set_cr(reg | CR_M | CR_S | CR_R | CR_C);	//set MMU, system MMU protect, ROM MMU protect, dcache
+	nop();
+	nop();
+	//printf("DCACHE & MMU enabled. CR=0x%x\n", reg);
+#ifdef CONFIG_SYS_CACHE_TEST
+	for(i=0; i<0x100; i++)
+		word_write(0x00200180 + (i*4),i);
+
+	for(i=0; i<0x100; i++) {
+		if(word_read(0x00200180 + (i*4)) != i)
+			printf("Cache test Failed. Exp: 0x%x, Act: 0x%x\n", i, word_read(0x00200180 + (i*4)));
+	}
+	word_write(0xc1800000, 0x01);
+	printf("Cache test completed.\n");
+#endif /* CONFIG_SYS_CACHE_TEST */
+
+#endif /* CONFIG_SYS_DISABLE_DCACHE */
+
+	return 0;
+}
+
+int program_mode()
+{
+	//TODO: placeholder
+	//Assume: SSI & SD Host clk are enabled, SD card initialized
+	//Init SD Controller
+	//Init SSI Controller
+	//Allocate buffer for write data
+
+	//Read data from SD Card into buffer (block-512B)
+	//Switch SSI control to NOR Flash (def was Autoload)
+	//Erase NOR Flash sector (sector-4kB)
+	//Write data to NOR Flash (page-256B)
+	//Read & Compare NOR Flash data	(page-256B)
+
+	//Free buffer
+
+	return 0;
+}
+
+#endif /* CONFIG_ARCH_MISC_INIT */
+
+#ifdef CONFIG_CMD_CLK
+#define ARM_RATIO(v,s)  ((v - 1) << s)
+#define PLL_RATIO(v,s)  ((v == 2) ? (1 << s) : (1 << (int)(v / 2)) << s)
+static clk_speed_t clk_dev;
+
+int pll_ratio(int input, int type)
+{
+	//type: 1=div to reg (set), 0=reg to div (check)
+	int result = 0;
+	switch(input) {
+	case 0:
+		result = type ? 0 : 1;
+		break;
+	case 1:
+		result = type ? 0 : 2;
+		break;
+	case 2:
+		result = type ? 1 : 3;
+		break;
+	case 3:
+		result = type ? 2 : 1;
+		break;
+	case 4:
+		result = 4;
+		break;
+	case 6:
+		result = type ? 8 : 1;
+		break;
+	case 8:
+		result = type ? 8 : 6;
+		break;
+	case 10:
+		result = type ? 0 : 8;
+		break;
+	default:
+		result = type ? 0 : 1;
+		break;
+	}
+	return result;
+}
+
+uint32_t set_clock_f(int pllclk, int armclk, int hclk, int sdclk)
+{
+	volatile ulong val;
+	volatile int t = 1000000;
+	int div;
+	int div_n;
+	int div_k = 2;
+	int div_m = 0;
+	unsigned int uartval;
+	int sdratio = 0;
+	int hclkratio = 0;
+	int armratio = 0;
+
+	printf("\npre: %08x,%08x,%08x,%08x,%x", word_read(0xa0000000), word_read(0xa0000004), word_read(0xa0000008), word_read(0xa000000c), word_read(0xa0000014));
+	//set pll clock
+	if (armclk == clk_dev.osc_clk) {
+		pllclk = clk_dev.osc_clk;
+		printf("OSC %dMHz\n", OSC_MHZ);
+		goto set_ratio;
+	}
+
+	div_n = ((pllclk / clk_dev.osc_clk) * (1 << div_k)) - 1;
+	div = (div_k << 14)  | (div_n << 8) | (div_m << 2);
+	printf(" (PLL %dMHz, div=%x)", pllclk, div);
+
+	if (word_read(0xa000000c) == div)
+		goto set_ratio;
+
+	val = word_read(0xa0000000);
+	word_write(0xa0000000, val & ~(0xff));      //use OSC clk temporarily
+	null_delay(10);
+
+	word_write(0xa000000c, 3 | div);
+	word_write(0xa000000c, 1 | div);
+	null_delay(100);
+	word_write(0xa000000c, div);
+	/* wait PLL init finish */
+	while((word_read(0xa0000000) & PLL_INIT_FINISH) != PLL_INIT_FINISH) {
+		null_delay(1);
+		if (t-- <= 0) {
+			armclk = hclk = pllclk = sdclk = clk_dev.osc_clk;
+			printf("\nFailed to change PLL, use OSC.");
+			break;
+		}
+	};
+
+set_ratio:
+	//set uart
+	uartval = (unsigned int)((hclk * 1000000 / 16 / clk_dev.baudrate) - 1);
+	word_write(0xa000400c, 0x83);
+	word_write(0xa0004004, 0x00);
+	word_write(0xa0004000, uartval/*0xa1*/);
+	word_write(0xa000400c, 0x03);
+	null_delay(10);
+
+	if (armclk == clk_dev.osc_clk) {
+		word_write(0xa0000000, 0x10c26600);     //0x10c26600
+		word_write(0xa000000c, 0x3);
+		goto done;
+	}
+
+	/* setting the new ratio */
+	sdratio = (int)(pllclk / sdclk);
+	hclkratio = (int)(armclk / hclk);
+	armratio = (int)(pllclk / armclk);
+
+	if(sdratio == 1)
+		word_write(0xa0000008, 0x00000000);
+	else
+		word_write(0xa0000008, PLL_RATIO(sdratio,16) | PLL_RATIO(sdratio,8) | PLL_RATIO(sdratio,0));
+
+	if(armratio == 1)
+		word_write(0xa0000004, 0x00000000);
+	else
+		word_write(0xa0000004, 0x00000000 | PLL_RATIO(armratio,0));
+
+	word_write(0xa0000000, 0x01c33301 | ARM_RATIO(hclkratio,1));    //0x01c33313, 0x01c37313
+
+done:
+	printf("\npost:%08x,%08x,%08x,%08x,%x", word_read(0xa0000000), word_read(0xa0000004), word_read(0xa0000008), word_read(0xa000000c), word_read(0xa0000014));
+	clk_dev.pllclk = pllclk;
+	clk_dev.armclk = armclk;
+	clk_dev.hclk = hclk;
+	clk_dev.sdclk = clk_dev.sdioclk = sdclk;
+	return 0;
+}
+
+uint32_t get_clock_f(void)
+{
+	unsigned int val = 0;
+	unsigned int sdfreq = 0;
+	int div_n = 0;
+	int div_k = 2;
+	int div_m = 0;
+	int armratio = 0;
+
+	printf("\nscu: %08x,%08x,%08x,%08x,%x", word_read(0xa0000000), word_read(0xa0000004), word_read(0xa0000008), word_read(0xa000000c), word_read(0xa0000014));
+	val = word_read(0xa0000000);
+	if((val & 0x1) == 0) {
+		clk_dev.pllclk = clk_dev.armclk = clk_dev.hclk = clk_dev.sdclk = clk_dev.sdioclk = clk_dev.osc_clk;
+		return 0;
+	}
+
+	//PLL clock
+	div_n = (word_read(0xa000000c) >> 8) & 0x3f;
+	clk_dev.pllclk = (int)(clk_dev.osc_clk * (div_n + 1) / (1 << div_k) / (div_m + 1));
+
+	//ARM clock
+	armratio = word_read(0xa0000004) & 0x1f;
+	clk_dev.armclk = clk_dev.pllclk / pll_ratio(armratio,0);
+
+	//HCLK
+	clk_dev.hclk = clk_dev.armclk / (((val & 0xe) >> 1) + 1);
+
+	//SD, SDIO clock
+	sdfreq = word_read(0xa0000008);
+	clk_dev.sdclk = clk_dev.pllclk / pll_ratio((sdfreq & 0x1f),0);
+	clk_dev.sdioclk = clk_dev.pllclk / pll_ratio(((sdfreq >> 8) & 0x1f),0);
+
+	return 0;
+}
+
+clk_speed_t *clk_get_dev(void)
+{
+	clk_dev.set_clock_speed = set_clock_f;
+	clk_dev.get_clock_speed = get_clock_f;
+	return (clk_speed_t *) &clk_dev;
+}
+
+
+#endif
diff --git a/arch/arm/cpu/arm926ejs/keyasic/ka2000.c b/arch/arm/cpu/arm926ejs/keyasic/ka2000.c
new file mode 100644
index 0000000..567e2bf
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/keyasic/ka2000.c
@@ -0,0 +1,31 @@
+/*
+ * SoC-specific code for KeyAsic KA2000 and similar chips
+ *
+ * Copyright (C) 2010
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <common.h>
+#include <asm/arch/hardware.h>
+
+
+//Placeholder
+void ka_errata_workarounds(void)
+{
+}
diff --git a/arch/arm/cpu/arm926ejs/keyasic/ka2000_define.h b/arch/arm/cpu/arm926ejs/keyasic/ka2000_define.h
new file mode 100644
index 0000000..923125c
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/keyasic/ka2000_define.h
@@ -0,0 +1,244 @@
+
+#define KA_REGIF_BASE            0xA0000000			//old:REGIF_BASE
+
+#define SYSTEM_BASE              KA_REGIF_BASE
+#define SYSTEM_CTRL_REG          SYSTEM_BASE
+#define CLK_DIV_REG              SYSTEM_BASE + 0x04
+
+#define SDRAM_BASE               0x00000000 + 0x00000000
+
+#define KA_SCU_BASE              KA_REGIF_BASE                   /* System Control Unit */
+#define KA_SSI_BASE              KA_REGIF_BASE + 0x1000
+#define KA_PWM_BASE              KA_REGIF_BASE + 0x2000
+#define KA_WDT_BASE              KA_REGIF_BASE + 0x3000
+#define KA_UART_BASE             KA_REGIF_BASE + 0x4000
+#define KA_GPIO0_BASE            KA_REGIF_BASE + 0x5000
+#define KA_INTC_BASE             KA_REGIF_BASE + 0x6000
+#define KA_DMA_BASE              KA_REGIF_BASE + 0x7000
+#define KA_SDRAM_CTRL_BASE       KA_REGIF_BASE + 0x8000
+#define KA_SDIO_BASE             KA_REGIF_BASE + 0x9000
+#define KA_SD_SWITCH_BASE        KA_REGIF_BASE + 0xa000
+#define KA_SD_CTRL_BASE          KA_REGIF_BASE + 0xb000
+#define KA_GPIO1_BASE            KA_REGIF_BASE + 0xc000
+
+/* scu */
+#define SCU_CLK_SRC_CTL		 KA_SCU_BASE + 0x00
+#define SCU_PLL_FREQ_SEL1	 KA_SCU_BASE + 0x04
+#define SCU_PLL_FREQ_SEL2	 KA_SCU_BASE + 0x08
+#define SCU_SYSTEM_CTL1		 KA_SCU_BASE + 0x0c
+#define SCU_SYSTEM_CTL2		 KA_SCU_BASE + 0x10
+#define SCU_SYSTEM_CTL3		 KA_SCU_BASE + 0x14
+#define SCU_CHIP_ID_HI	     KA_SCU_BASE + 0x30
+#define SCU_CHIP_ID_LO	     KA_SCU_BASE + 0x34
+
+/* ssi */
+#define SSI_BASE                 KA_SSI_BASE
+#define SSI_PRE                  SSI_BASE + 0x00
+#define SSI_CON                  SSI_BASE + 0x04
+#define SSI_STA                  SSI_BASE + 0x08
+#define SSI_TDAT                 SSI_BASE + 0x0c
+#define SSI_RDAT                 SSI_BASE + 0x10
+
+/* sdio */
+#define SDIO_BASE                KA_SDIO_BASE
+#define SDIO_CARD_BLOCK_SET_REG  SDIO_BASE  + 0x00
+#define SDIO_CTRL_REG            SDIO_BASE  + 0x04
+#define SDIO_CMD_ARGUMENT_REG    SDIO_BASE  + 0x08
+#define SDIO_SPECIAL_COMMAND_REG SDIO_BASE  + 0x0c
+#define SDIO_STATUS_REG          SDIO_BASE  + 0x10
+#define SDIO_ERROR_ENABLE_REG    SDIO_BASE  + 0x14
+#define SDIO_RESPONSE1_REG       SDIO_BASE  + 0x18
+#define SDIO_RESPONSE2_REG       SDIO_BASE  + 0x1c
+#define SDIO_RESPONSE3_REG       SDIO_BASE  + 0x20
+#define SDIO_RESPONSE4_REG       SDIO_BASE  + 0x24
+#define SDIO_BUF_TRAN_RESP_REG   SDIO_BASE  + 0x28
+#define SDIO_BUF_TRAN_CTRL_REG   SDIO_BASE  + 0x2c
+#define SDIO_DMA_SACH0_REG       SDIO_BASE  + 0x30
+#define SDIO_DMA_TCCH0_REG       SDIO_BASE  + 0x34
+#define SDIO_DMA_CTRCH0_REG      SDIO_BASE  + 0x38
+#define SDIO_reserved            SDIO_BASE  + 0x3c
+#define SDIO_DMA_DACH1_REG       SDIO_BASE  + 0x40
+#define SDIO_DMA_TCCH1_REG       SDIO_BASE  + 0x44
+#define SDIO_DMA_CTRCH1_REG      SDIO_BASE  + 0x48
+#define SDIO_DMA_INTS_REG        SDIO_BASE  + 0x4c
+#define SDIO_DMA_FIFO_STATUS_REG SDIO_BASE  + 0x50
+
+/* pwm */
+#define PWM_BASE                 KA_PWM_BASE
+#define TCFG0                    PWM_BASE + 0x00
+#define TCFG1                    PWM_BASE + 0x04
+#define TCON0                    PWM_BASE + 0x08
+#define TCON1                    PWM_BASE + 0x0c
+#define TCNTB0                   PWM_BASE + 0x10
+#define TCMPB0                   PWM_BASE + 0x14
+#define TCNTO0                   PWM_BASE + 0x18
+#define TCNTB1                   PWM_BASE + 0x40
+#define TCNTO1                   PWM_BASE + 0x44
+#define TCNTB2                   PWM_BASE + 0x48
+#define TCNTO2                   PWM_BASE + 0x4c
+
+/* sd switch */
+#define SDSW_BASE           	 KA_SD_SWITCH_BASE
+#define SDSW_M1_CTRL0	 	 SDSW_BASE + 0x00
+#define SDSW_M2_CTRL0	 	 SDSW_BASE + 0x04
+#define SDSW_M1_STATUS	 	 SDSW_BASE + 0x08
+#define SDSW_M2_STATUS		 SDSW_BASE + 0x0c
+#define SDSW_READ_SWDAT	 	 SDSW_BASE + 0x18
+#define SDSW_SW_CTRL0	 	 SDSW_BASE + 0x1c
+#define SDSW_TEST_REG	 	 SDSW_BASE + 0x20
+#define SDSW_M1_PREV_CMD_REG0	 SDSW_BASE + 0x30
+#define SDSW_M1_PREV_CMD_REG1	 SDSW_BASE + 0x34
+#define SDSW_M1_PREV_RSP_REG0	 SDSW_BASE + 0x38
+#define SDSW_M1_PREV_RSP_REG1	 SDSW_BASE + 0x3c
+#define SDSW_M1_CURR_CMD_REG0	 SDSW_BASE + 0x40
+#define SDSW_M1_CURR_CMD_REG1	 SDSW_BASE + 0x44
+#define SDSW_M1_CURR_RSP_REG0	 SDSW_BASE + 0x48
+#define SDSW_M1_CURR_RSP_REG1	 SDSW_BASE + 0x4c
+#define SDSW_M1_CURR_RSP_REG2	 SDSW_BASE + 0x50
+#define SDSW_M1_CURR_RSP_REG3	 SDSW_BASE + 0x54
+#define SDSW_M1_CURR_RSP_REG4	 SDSW_BASE + 0x58
+#define SDSW_M1_CMD_FLG_REG0	 SDSW_BASE + 0x5c
+#define SDSW_M1_CMD_CRC_FLG_REG0 SDSW_BASE + 0x60
+#define SDSW_M1_CMD_FLG_REG1     SDSW_BASE + 0x64
+#define SDSW_M1_CMD_CRC_FLG_REG1 SDSW_BASE + 0x68
+#define SDSW_M1_CMD_FLG_REG2     SDSW_BASE + 0x6c
+#define SDSW_M1_CMD_CRC_FLG_REG2 SDSW_BASE + 0x70
+#define SDSW_M1_CMD_FLG_REG3     SDSW_BASE + 0x74
+#define SDSW_M1_CMD_CRC_FLG_REG3 SDSW_BASE + 0x78
+#define SDSW_BOMB_START_ADDR_REG SDSW_BASE + 0x80
+#define SDSW_BOMB_END_ADDR_REG   SDSW_BASE + 0x84
+#define SDSW_BOMB_Flag_ADDR_REG  SDSW_BASE + 0x88
+#define SDSW_M1_CID_REG0         SDSW_BASE + 0x8c
+#define SDSW_M1_CID_REG1         SDSW_BASE + 0x90
+#define SDSW_M1_CID_REG2         SDSW_BASE + 0x94
+#define SDSW_M1_CID_REG3         SDSW_BASE + 0x98
+#define SDSW_M1_RCA_REG          SDSW_BASE + 0x9c
+#define SDSW_M1_DSR_REG          SDSW_BASE + 0xa0
+#define SDSW_M1_CIC_REG          SDSW_BASE + 0xa4
+#define SDSW_M1_CSD_REG0         SDSW_BASE + 0xa8
+#define SDSW_M1_CSD_REG1         SDSW_BASE + 0xac
+#define SDSW_M1_CSD_REG2         SDSW_BASE + 0xb0
+#define SDSW_M1_CSD_REG3         SDSW_BASE + 0xb4
+#define SDSW_M1_CSR_REG          SDSW_BASE + 0xb8
+#define SDSW_M1_BLR_REG          SDSW_BASE + 0xbc
+#define SDSW_M1_EWBS_REG         SDSW_BASE + 0xc0
+#define SDSW_M1_EWBE_REG         SDSW_BASE + 0xc4
+#define SDSW_M1_SBW_REG          SDSW_BASE + 0xc8
+#define SDSW_M1_SWBEC_REG        SDSW_BASE + 0xcc
+#define SDSW_M1_OCR_REG          SDSW_BASE + 0xd0
+#define SDSW_M1_SCCD_REG         SDSW_BASE + 0xd4
+#define SDSW_M1_SSR_REG0         SDSW_BASE + 0xd8
+#define SDSW_M1_SSR_REG1         SDSW_BASE + 0xdc
+#define SDSW_M1_SSR_REG2         SDSW_BASE + 0xe0
+#define SDSW_M1_SSR_REG3         SDSW_BASE + 0xe4
+#define SDSW_M1_SCR_REG0         SDSW_BASE + 0xe8
+#define SDSW_M1_SCR_REG1         SDSW_BASE + 0xec
+#define SDSW_M1_SNWB_REG         SDSW_BASE + 0xf0
+#define SDSW_M1_BLOCK_LEN_REG    SDSW_BASE + 0xf4
+#define SDSW_M1_WDATA_TOUT_REG   SDSW_BASE + 0xf8
+#define SDSW_M1_RDATA_TOUT_REG   SDSW_BASE + 0xfc
+#define SDSW_DIRECT_START_TRANS_REG     SDSW_BASE + 0x100
+#define SDSW_DIRECT_CMD_INDEX_REG       SDSW_BASE + 0x104
+#define SDSW_DIRECT_CMD_ARGU_REG        SDSW_BASE + 0x108
+#define SDSW_DIRECT_CTRL_REG            SDSW_BASE + 0x10c
+#define SDSW_DIRECT_BLOCK_LENGTH_REG    SDSW_BASE + 0x110
+#define SDSW_DIRECT_WRITE_SW_CYCLE_REG  SDSW_BASE + 0x114
+#define SDSW_M1_CMD_FLAG_INTEN_REG0     SDSW_BASE + 0x120
+#define SDSW_M1_CMD_FLAG_INTEN_REG1     SDSW_BASE + 0x124
+#define SDSW_M1_CMD_FLAG_INTEN_REG2     SDSW_BASE + 0x128
+#define SDSW_M1_CMD_FLAG_INTEN_REG3     SDSW_BASE + 0x12c
+
+/* wdt */
+#define WDT_BASE                 KA_WDT_BASE
+#define WDT_CON                  WDT_BASE + 0x00
+#define WDT_DAT                  WDT_BASE + 0x04
+#define WDT_CNT                  WDT_BASE + 0x08
+#define WDT_CON_CONTER_EN        0x20
+
+/* gpio0 */
+#define GPIO0_BASE               KA_GPIO0_BASE		//old:GPIO_BASE
+#define GPIO_OEN                 GPIO0_BASE + 0x00
+#define GPIO_INPUT               GPIO0_BASE + 0x04
+#define GPIO_OUTPUT              GPIO0_BASE + 0x08
+#define GPIO_INT                 GPIO0_BASE + 0x0c
+#define GPIO_INT_CLR0            GPIO0_BASE + 0x10
+#define GPIO_INT_CLR1            GPIO0_BASE + 0x14
+#define GPIO_INT_CLR2            GPIO0_BASE + 0x18
+#define GPIO_INT_CLR3            GPIO0_BASE + 0x1c
+#define GPIO_INT_CLR4            GPIO0_BASE + 0x20
+#define GPIO_INT_CLR5            GPIO0_BASE + 0x24
+#define GPIO_INT_CLR6            GPIO0_BASE + 0x28
+#define GPIO_INT_CLR7            GPIO0_BASE + 0x2c
+
+/* gpio1 */
+#define GPIO1_BASE               KA_GPIO1_BASE
+#define GPO_OEN                  GPIO1_BASE + 0x00
+#define GPI_INPUT                GPIO1_BASE + 0x04
+#define GPO_OUTPUT               GPIO1_BASE + 0x08
+#define GPI_INT                  GPIO1_BASE + 0x0c
+#define GPI_INT_CLR0             GPIO1_BASE + 0x10
+#define GPI_INT_CLR1             GPIO1_BASE + 0x14
+#define GPI_INT_CLR2             GPIO1_BASE + 0x18
+#define GPI_INT_CLR3             GPIO1_BASE + 0x1c
+#define GPI_INT_CLR4             GPIO1_BASE + 0x20
+#define GPI_INT_CLR5             GPIO1_BASE + 0x24
+#define GPI_INT_CLR6             GPIO1_BASE + 0x28
+#define GPI_INT_CLR7             GPIO1_BASE + 0x2c
+
+// sdram base
+#define SDRAM_CTRL_BASE          KA_SDRAM_CTRL_BASE
+
+/* uart */
+#define UART_BASE                KA_UART_BASE
+#define UART_RECV                UART_BASE + 0x00
+#define UART_THR                 UART_BASE + 0x00
+#define UART_INTR                UART_BASE + 0x04
+#define UART_FCR                 UART_BASE + 0x08
+#define UART_IIR                 UART_BASE + 0x08
+#define UART_LCR                 UART_BASE + 0x0c
+#define UART_MCR                 UART_BASE + 0x10
+#define UART_LINE                UART_BASE + 0x14
+#define UART_MSR                 UART_BASE + 0x18
+#define UART_RFST                UART_BASE + 0x1c
+
+/*sd card */
+#define SDR_BASE                  KA_SD_CTRL_BASE
+#define SDR_Card_BLOCK_SET_REG    SDR_BASE + 0x00
+#define SDR_CTRL_REG              SDR_BASE + 0x04
+#define SDR_CMD_ARGUMENT_REG      SDR_BASE + 0x08
+#define SDR_SPECIAL_CTRL_REG      SDR_BASE + 0x0C	//old:SDR_ADDRESS_REG
+#define SDR_STATUS_REG            SDR_BASE + 0x10
+#define SDR_Error_Enable_REG      SDR_BASE + 0x14
+#define SDR_RESPONSE1_REG         SDR_BASE + 0x18
+#define SDR_RESPONSE2_REG         SDR_BASE + 0x1C
+#define SDR_RESPONSE3_REG         SDR_BASE + 0x20
+#define SDR_RESPONSE4_REG         SDR_BASE + 0x24
+#define SDR_DMA_TRAN_RESP_REG     SDR_BASE + 0x28
+#define SDR_BUF_TRAN_CTRL_REG     SDR_BASE + 0x2C
+
+#define SDR_DMA_SACH0_REG         SDR_BASE + 0x30
+#define SDR_DMA_TCCH0_REG         SDR_BASE + 0x34
+#define SDR_DMA_CTRCH0_REG        SDR_BASE + 0x38
+#define SDR_DMA_DACH1_REG         SDR_BASE + 0x40
+#define SDR_DMA_TCCH1_REG         SDR_BASE + 0x44
+#define SDR_DMA_CTRCH1_REG        SDR_BASE + 0x48
+#define SDR_DMA_INTS_REG          SDR_BASE + 0x4C
+#define SDR_DMA_FIFO_STATUS_REG   SDR_BASE + 0x50
+
+/* interrupt controller */
+#define INTC_BASE                 KA_INTC_BASE
+#define INTC_INTSRC1_ADDR         INTC_BASE + 0x00
+#define INTC_INTSRC2_ADDR         INTC_BASE + 0x04
+#define INTC_INTMOD1_ADDR         INTC_BASE + 0x08
+#define INTC_INTMOD2_ADDR         INTC_BASE + 0x0c
+#define INTC_INTMSK1_ADDR         INTC_BASE + 0x10
+#define INTC_INTMSK2_ADDR         INTC_BASE + 0x14
+#define INTC_INTPND1_ADDR         INTC_BASE + 0x18
+#define INTC_INTPND2_ADDR         INTC_BASE + 0x1c
+#define INTC_INTPRT1_ADDR         INTC_BASE + 0x20
+#define INTC_INTPRT2_ADDR         INTC_BASE + 0x24
+#define INTC_INTPRO1_ADDR         INTC_BASE + 0x28
+#define INTC_INTPRO2_ADDR         INTC_BASE + 0x2c
+#define INTC_INTCLR_ADDR          INTC_BASE + 0x30
+#define INTC_INTOFS_ADDR          INTC_BASE + 0x34
+
diff --git a/arch/arm/cpu/arm926ejs/keyasic/ka2000_mmc.c b/arch/arm/cpu/arm926ejs/keyasic/ka2000_mmc.c
new file mode 100644
index 0000000..6876db1
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/keyasic/ka2000_mmc.c
@@ -0,0 +1,541 @@
+
+#include <config.h>
+#include <common.h>
+#include <command.h>
+#include <mmc.h>
+#include <part.h>
+#include <malloc.h>
+#include <mmc.h>
+#include <spi_flash.h>
+#include <fat.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+
+#include <asm/arch/reg_defs.h>
+//#include "ka2000-define.h"
+#include "sdctrl.h"
+
+
+#define DRIVER_NAME "ka2000-mmc"
+
+
+static block_dev_desc_t mmc_blk_dev;
+
+extern int m1_busy(void);
+
+void test_switch_register(void)
+{
+	u32 v0[64];
+	u32 v1[64];
+	u32 r;
+//	u32 val;
+	int i;
+//	int n = 24;
+	r = SDSW_BASE;
+
+	while (1) {
+		for (i = 0; i < 64; i++) {
+			v0[i]=v1[i];
+			v1[i] = word_read(r+i*4);
+		}
+
+		for (i = 0; i < 64; i++) {
+			if (v1[i] != v0[i])
+				printf("i %d v0 %08x, v1 %08x", i, v0[i], v1[i]);
+		}
+	}
+
+}
+
+block_dev_desc_t *mmc_get_dev(int dev)
+{
+	return (block_dev_desc_t *) &mmc_blk_dev;
+}
+
+static __inline__ int null_delay(int t)
+{
+	volatile int i = 0;
+	volatile int j = 0;
+	for (i = 0; i < t; i++) {
+		for (j = 0; j < 5; j++);
+	}
+	return j;
+}
+
+#if 0
+extern int m2_err;
+uint32_t mmc_bread(int dev_num, uint32_t blknr, lbaint_t blkcnt, void *dst)
+{
+	int i = 0;
+	int n = blkcnt;
+	int m = 4;   //64
+	int ret = 1;
+
+	if (m2_err > 1)
+		return 0;
+	//switch_to_m2();
+	for (i = 0; i + m < blkcnt; i += m) {
+		ret = CardRead_single_pin((unsigned int)dst, blknr, m);
+		if (m2_err > 2)
+			return 0;
+
+		null_delay(10);
+		dst += m * 512;
+		blknr += m;
+		n -= m;
+	}
+
+	if (n > 0)
+		ret = CardRead_single_pin((unsigned int)dst, blknr, n);
+	switch_to_m1();
+	ret = (ret==0) ? blkcnt : 0;
+	return ret; //1;
+}
+#else
+uint32_t mmc_bread(int dev_num, uint32_t blknr, lbaint_t blkcnt, void *dst)
+{
+	int ret = 1;
+	int n = (int)blkcnt;
+	int m = 8; //64
+	int r = 50;
+
+	//switch_to_m2();
+	if(blkcnt <= 1)
+		ret = SDCardRead((unsigned int)dst, blknr, (int)blkcnt, 1);
+	else {
+		for (n = blkcnt; n > 0; n -= m, r = 50) {
+			if(n < m) m = n;
+			while(r--) {
+				if((ret = SDCardRead((unsigned int)dst, blknr, m, 0)) == 0)
+					break;
+				null_delay(10);
+				printf("<%d.rf %d>" , r, blknr);
+			}
+			/*if((ret = SDCardRead((unsigned int)dst, blknr, m, 0)) != 0) {
+			         printf("<r %d fail>" , blknr);
+			        break;
+			}*/
+			null_delay(5); //10
+			dst += m * 512;
+			blknr += m;
+		}
+		//ret = SDCardRead((unsigned int)dst, blknr, (int)blkcnt, 0);
+	}
+	//switch_to_m1();
+	ret = (ret==0) ? blkcnt : 0;
+	return ret; //1;
+}
+#endif
+uint32_t mmc_bwrite(int dev_num, uint32_t blknr, lbaint_t blkcnt, void *src)
+{
+	int ret = 1;
+	//switch_to_m2();
+	if(blkcnt <= 1)
+		ret = SDCardWrite((unsigned int)src, blknr, (int)blkcnt, 1);
+	else
+		ret = SDCardWrite((unsigned int)src, blknr, (int)blkcnt, 0);
+	//switch_to_m1();
+	ret = (ret==0) ? blkcnt : 0;
+	return ret;
+}
+uint32_t mmc_sendcmd(int dev_num, unsigned char cmd, unsigned int arg, unsigned int ctrl, void *data)
+{
+
+	int ret = 1;
+
+	printf("\nmmc send SD CMD%d ARG:%08x .. ", cmd, arg);
+	if (switch_to_m2() == 0)
+		return ret;
+	ret = HCmdNoData((arg>>24) & 0xff, (arg>>16) & 0xff, (arg>>8) & 0xff, arg & 0xff, (unsigned int)cmd, (ctrl>>8) & 0xff, ctrl & 0xff);
+	//ret = HCmdNoData(arg & 0xff, (arg>>8) & 0xff, (arg>>16) & 0xff, (arg>>24) & 0xff, (unsigned int)cmd, (ctrl>>8) & 0xff, ctrl & 0xff);
+	switch_to_m1();
+	if(ret == 0) {
+		if(ctrl & 0xC00) {
+			printf("\nRSP:%08x ", word_read(SDR_RESPONSE1_REG));
+			if((ctrl & 0xC00) == 0x400) //R2
+				printf("%08x %08x %08x ", word_read(SDR_RESPONSE2_REG), word_read(SDR_RESPONSE3_REG), word_read(SDR_RESPONSE4_REG));
+		}
+		//printf(" .. passed.\n");
+	}
+	//else
+	//printf(" failed.\n");
+	return ret;
+}
+
+int CardWrite_single_pin(unsigned int blk_no, int blk_num, unsigned char *buffer);
+
+/* find first device whose first partition is a DOS filesystem */
+int find_fat_partition (block_dev_desc_t *dev_desc)
+{
+//	int i;
+	int j;
+	unsigned char *part_table;
+	unsigned char buffer[512];
+	unsigned int part_offset = 0;
+
+	if (!dev_desc) {
+		debug ("couldn't get ide device!\n");
+		return (-1);
+	}
+	if (dev_desc->part_type == PART_TYPE_DOS) {
+		if (dev_desc->
+		    block_read (dev_desc->dev, 0, 1, (ulong *) buffer) != 1) {
+			debug ("can't perform block_read!\n");
+			return (-1);
+		}
+		part_table = &buffer[0x1be];	/* start with partition #4 */
+		for (j = 0; j < 4; j++) {
+			if ((part_table[4] == 1 ||	/* 12-bit FAT */
+			     part_table[4] == 4 ||	/* 16-bit FAT */
+			     part_table[4] == 6) &&	/* > 32Meg part */
+			    part_table[0] == 0x80) {	/* bootable? */
+				//curr_dev = i;
+				part_offset = part_table[11];
+				part_offset <<= 8;
+				part_offset |= part_table[10];
+				part_offset <<= 8;
+				part_offset |= part_table[9];
+				part_offset <<= 8;
+				part_offset |= part_table[8];
+				debug ("found partition start at %ld\n", (long int)part_offset);
+				return (0);
+			}
+			part_table += 16;
+		}
+	}
+
+
+	//debug ("no valid devices found!\n");
+	return (-1);
+}
+
+unsigned long buf[4096];
+unsigned long swctl;
+int fat_register_device(block_dev_desc_t *dev_desc, int part_no);
+int ka2000_sf_erase(struct spi_flash *flash, u32 offset, size_t len);
+int ka2000_sf_read(struct spi_flash *flash, u32 offset, size_t len, void *buf);
+int ka2000_sf_write(struct spi_flash *flash, u32 offset, size_t len, const void *buf);
+int CardErase_single(unsigned int blk_no);
+
+void rebuild_sd(void)
+{
+#ifdef CONFIG_SYS_PROGRAM_BIN
+	/* Clear SD signature */
+	memset(buf, 0, 512);
+
+	CardWrite_single_pin(0, 1, buf);
+	CardWrite_single_pin(6, 1, buf);
+	CardWrite_single_pin(8, 1, buf);
+	CardWrite_single_pin(30, 1, buf);
+	CardWrite_single_pin(31, 1, buf);
+	CardWrite_single_pin(238, 1, buf);
+	CardWrite_single_pin(240, 1, buf);
+	CardWrite_single_pin(262, 1, buf);
+
+	/* rebuild mbr and fat */
+	//CardWrite_single_pin(0, 1, mbr);
+	//CardWrite_single_pin(8192, 1, buf);
+#endif
+}
+
+extern void buzzer_off(void);
+extern void buzzer_on(int tone);
+
+int detect_program_bin(void)
+{
+//	int ret, count;
+	int size;
+	u32 *buf;
+	buf = (u32 *)0xe00000;
+
+	fat_register_device(&mmc_blk_dev,1);
+	//buzzer_off();
+
+	size = file_fat_read ("program.bin", buf, 128 * 1024);
+	if (size > 1 && (buf[0] == 0xea000012 || buf[0] == 0x120000ea)) {
+		buzzer_on(0);
+		run_command("go e00000", 0);
+		buzzer_off();
+	}
+	//buzzer_off();
+	return 0;
+}
+
+#ifdef CONFIG_SYS_PROGRAM_BIN
+int do_pretest(int *pretest)
+{
+	int size1 = -1;
+
+	if(*pretest == 1)
+		return 0;
+	*pretest = 1;
+
+	if ((size1 = file_fat_read ("preprog_chk.bin", NULL,  32)) != -1) {
+		run_command("fatload mmc 1 100000 preprog_chk.bin; sf erase 100000 1000; sf write 100000 100000 400; sf read 30000 100000 400; sf erase 100000 1000\0", 0);
+		if(memcmp((void *)0x100000, (void *)0x30000, 512) == 0)
+			printf("pre-program check passed.\n");
+		else
+			return -1;
+	}
+	return 0;
+}
+
+void detect_program_files(void)
+{
+	int size = -1, program = 0;
+	u32 buf[512];
+	void *tmp;
+	int chipRev = 0;
+	int pretest = 0;
+
+	if((word_read(SCU_CHIP_ID_HI) == 0x39323044) && (word_read(SCU_CHIP_ID_LO) == 0x004b4130))
+		chipRev = 3;
+	else if((word_read(SCU_CHIP_ID_HI) == 0x0) && (word_read(SCU_CHIP_ID_LO) == 0x0))
+		chipRev = 2;
+
+	if(m1_busy() == 0) {
+		buzzer_on(0);
+		printf("******          Program Mode (GEN%d)              ******\n", chipRev);
+		run_command("sf probe 0; mmc init", 0);
+
+
+		fat_register_device(&mmc_blk_dev,1);
+		run_command("mmc init", 0);
+		null_delay(10);
+
+#ifdef CONFIG_SYS_ALLOW_PROGRAM_AUTOLOAD_TABLE
+		if ((size = file_fat_read ("autoload.tbl", buf, 32)) != -1) {
+			printf("found autoload.tbl, start program.\n");
+			//printf("program autoload: %08x %08x %08x %08x\n", buf[0], buf[1], buf[2], buf[3]);
+			run_command("sf read 1000 0 1000; md 1000 10; fatload mmc 1 1000 autoload.tbl; sf erase 0 1000; sf write 1000 0 1000; sf read 3000 0 1000; md 3000 10\0", 0);
+		} else if (chipRev == 3) {
+			run_command("sf read 1000 0 400", 0);
+			if((*(unsigned int*)0x1004) != 0x00000300) {
+				printf("enable delay chain\n");
+				run_command("sf read 1000 0 1000; md 1000 10; mw 1004 00000300; sf erase 0 1000; sf write 1000 0 1000; sf read 3000 0 1000; md 3000 10\0", 0);
+			}
+		}
+		null_delay(5);
+#else
+
+/*
+		//"program_kernel=fatload mmc 1 208400 zImage; sf erase 200000 380000; sf write 200000 200000 380000\0" \
+		//"program_uboot=sf read e00000 3000 20000; fatload mmc 1 e00200 u-boot.bin;  sf erase 3000 20000; sf write e00000 3000 20000\0" \
+		//"program_mtd=fatload mmc 1 500000 mtd_jffs2.bin; sf erase 580000 280000; sf write 500000 580000 280000\0" \
+*/
+
+#ifdef CONFIG_SYS_ALLOW_PROGRAM_UBOOT
+		if ((size = file_fat_read ("u-boot.bin", NULL,  32)) != -1) {
+			if(do_pretest(&pretest) == -1)
+				goto abort_program;
+			//buzzer_on(0);
+			printf("found u-boot.bin, start program.\n");
+			run_command("sf read e00000 3000 20000; fatload mmc 1 e00200 u-boot.bin;  sf erase 3000 20000; sf write e00000 3000 20000\0", 0);
+			//tmp = 0xe00000;
+			//memset(tmp, 0, 0x20000);
+			program++;
+		}
+#endif
+#ifdef CONFIG_SYS_ALLOW_PROGRAM_BOOTLOADER
+		if ((size = file_fat_read ("ka_bootldr.bin", NULL, 32)) != -1) {
+			if(do_pretest(&pretest) == -1)
+				goto abort_program;
+			//buzzer_on(1);
+			printf("found ka_bootldr.bin, start program.\n");
+			//run_command("run 1st boot loader", 0);
+			run_command(" sf read d00000 0 4000; fatload mmc 1 d00400 ka_bootldr.bin; sf erase 0 4000; sf write d00000 0 4000\0", 0);
+			//size = file_fat_read ("ka_bootldr.bin", buf, 128 * 1024);
+			tmp = 0xd00000;
+			memset(tmp, 0, 0x4000);
+			program++;
+		}
+#endif
+
+		if(chipRev == 3) {
+			if ((size = file_fat_read ("image3", NULL,  32)) != -1) {
+				if(do_pretest(&pretest) == -1)
+					goto abort_program;
+				//buzzer_on(1);
+				printf("found image3, start program.\n");
+				if (size > 0x300000)
+					printf("image3 oversize, size 0x%x > 0x300000\n", size);
+				run_command("fatload mmc 1 208000 image3; sf erase 200000 300000; sf write 1ffc00 200000 300000\0", 0);
+				/*run_command("fatload mmc 1 208000 image3\0", 0);
+				if(pretest == 0)
+				{
+				    pretest = 1;
+				    run_command("sf erase 100000 1000; sf write 208000 100000 1000; sf read 30000 100000 1000; sf erase 100000 1000\0", 0);
+				    if(memcmp((void *)0x208000, (void *)0x30000, 512) != 0)
+				    {
+				        run_command("md 208000 10; md 30000 10\0", 0);
+				        goto abort_program;
+				    }
+				}
+				run_command("sf erase 200000 300000; sf write 1ffc00 200000 300000\0", 0);*/
+				program++;
+			}
+		} else {
+			if ((size = file_fat_read ("image", NULL,  32)) != -1) {
+				if(do_pretest(&pretest) == -1)
+					goto abort_program;
+				//buzzer_on(1);
+				printf("found image, start program.\n");
+				if (size > 0x300000)
+					printf("image oversize, size 0x%x > 0x300000\n", size);
+				run_command("fatload mmc 1 208000 image; sf erase 200000 300000; sf write 1ffc00 200000 300000\0", 0);
+				program++;
+			}
+		}
+#if 0
+		else if ((size = file_fat_read ("zImage", NULL, 32)) != -1) {
+			//buzzer_on(1);
+			printf("found zImage, start program.\n");
+			run_command("fatload mmc 1 208000 zimage; sf erase 200000 300000; sf write 1ffc00 200000 300000\0", 0);
+			program++;
+		}
+#endif
+
+		if(chipRev == 3) {
+			if ((size = file_fat_read ("initramfs3.gz", NULL, 32)) != -1) {
+				if(do_pretest(&pretest) == -1)
+					goto abort_program;
+				//buzzer_on(1);
+				printf("found initramfs3.gz, start program.\n");
+				if (size > 0x300000)
+					printf("initramfs3.gz oversize, size 0x%x > 0x300000\n", size);
+				run_command("fatload mmc 1 500000 initramfs3.gz; sf erase 500000 300000; sf write 4ffc00 500000 300000\0", 0);
+				program++;
+			}
+		} else {
+			if ((size = file_fat_read ("initramfs.gz", NULL, 32)) != -1) {
+				if(do_pretest(&pretest) == -1)
+					goto abort_program;
+				//buzzer_on(1);
+				printf("found initramfs.gz, start program.\n");
+				if (size > 0x300000)
+					printf("initramfs.gz oversize, size 0x%x > 0x300000\n", size);
+				run_command("fatload mmc 1 500000 initramfs.gz; sf erase 500000 300000; sf write 4ffc00 500000 300000\0", 0);
+				program++;
+			}
+		}
+
+		if ((size = file_fat_read ("mtd_jffs2.bin", NULL,  32)) != -1) {
+			if(do_pretest(&pretest) == -1)
+				goto abort_program;
+			//buzzer_on(0);
+			printf("found mtd_jffs2.bin, start program.\n");
+			//run_command("fatload mmc 1 d00000 mtd_jffs2.bin; sf erase 700000 100000; sf write d00000 700000 100000\0", 0);
+			run_command("fatload mmc 1 d00000 mtd_jffs2.bin; sf erase 80000 100000; sf write d00000 80000 100000\0", 0);
+
+			tmp = 0xd00000;
+			memset(tmp, 0, 0x100000);
+			program++;
+		}
+#if 0
+		if(chipRev == 3) {
+			setenv ("bootargs", "root=/dev/ram0 rw console=ttyS0,38400n8 mem=32M");
+			if (((tmp = getenv("misc_args")) == NULL) || (strcmp(tmp, "mem=32M") != 0))
+				setenv ("misc_args", "mem=32M");
+			run_command("saveenv", 0);
+		}
+#endif
+
+#endif //CONFIG_SYS_ALLOW_PROGRAM_AUTOLOAD_TABLE
+		//if(program == 1)
+		//    rebuild_sd();
+		buzzer_off();
+		return;
+	}
+abort_program:
+	printf("pre-program check failed! Abort programming.\n");
+	run_command("md 100000 10; md 30000 10\0", 0);
+	buzzer_off();
+	buzzer_on(1);
+	null_delay(10);
+	buzzer_off();
+}
+#endif
+
+int mmc_check_sw_signature(void)
+{
+//	unsigned long offset = 0;
+//	unsigned long count = 0x100;
+//	long size, size1;
+
+	mmc_bread(0, 30, 1, (unsigned char *)buf);
+
+	swctl = buf[0];
+
+	if ((swctl & 0xffffff) == 0x544d53) {
+		printf("******  Erase flash SWCTL Reg To Program Mode ******\n");
+		ka2000_sf_read(NULL, 0x3000, 0x1000, buf);
+		ka2000_sf_erase(NULL, 0x3000, 0x1000);
+		buf[0] = 0xffffffff;
+
+		ka2000_sf_write(NULL, 0x3000, 0x1000, buf);
+		run_command("go 0", 0);
+		return 1;
+	}
+	return 0;
+}
+
+int mmc_inited = 0;
+
+
+int mmc_legacy_init(int verbose)
+{
+//	unsigned long fat_tag, mbr_tag;
+
+	//test_switch_register();
+	if (mmc_inited == 1)
+		return 0;
+	if (mmc_inited == 0) {
+		//printf("MMC Init Card ...\n");
+		InitCardReader();
+		//InitCard();
+		if(InitCard())
+			printf("InitCard failed\n");
+
+		mmc_blk_dev.if_type = IF_TYPE_MMC;
+		mmc_blk_dev.part_type = PART_TYPE_UNKNOWN; //PART_TYPE_DOS;
+		mmc_blk_dev.dev = 1;
+		mmc_blk_dev.lun = 0;
+		mmc_blk_dev.type = 0;
+
+		/* FIXME fill in the correct size (is set to 32MByte) */
+		mmc_blk_dev.blksz = 512;
+		mmc_blk_dev.lba = 0x100000;
+		mmc_blk_dev.removable = 0;
+		mmc_blk_dev.block_read = mmc_bread;
+		mmc_blk_dev.block_write = mmc_bwrite;
+		mmc_blk_dev.sd_cmd = mmc_sendcmd;
+#ifndef CONFIG_SYS_PROGRAM_BIN
+		buzzer_off();
+#endif
+
+#if 0
+		if (find_fat_partition(&mmc_blk_dev) == 0) {
+			check_mbr_and_fat();
+		}
+#endif
+	}
+
+	if (fat_register_device(&mmc_blk_dev, 1) != 0) {
+		//printf("Could not register MMC fat device\n");
+		init_part(&mmc_blk_dev);
+	}
+
+	if (mmc_inited == 0) {
+		mmc_inited = 1;
+		//ka2000_isp();
+#ifndef CONFIG_SYS_PROGRAM_BIN
+		if (m1_busy() == 0)
+			detect_program_bin();
+#endif
+	}
+
+	mmc_inited = 1;
+
+	return 0;
+}
+
diff --git a/arch/arm/cpu/arm926ejs/keyasic/ka2000_spi.c b/arch/arm/cpu/arm926ejs/keyasic/ka2000_spi.c
new file mode 100644
index 0000000..23059a5
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/keyasic/ka2000_spi.c
@@ -0,0 +1,660 @@
+/*
+ * (C) Copyright 2009
+ * Frank Bodammer <frank.bodammer@gcd-solutions.de>
+ * (C) Copyright 2009 Semihalf, Grzegorz Bernacki
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <common.h>
+#include <asm/io.h>
+#include <malloc.h>
+#include <spi.h>
+#include <asm/arch/reg_defs.h>
+#include <spi_flash.h>
+
+#define show_str(a, b, c, d);  printf("%d, %d, %s", b, d, a);
+
+
+volatile unsigned int int_flag;
+int mode;
+#define SLOW_MODE		0
+#define NORMAL_50_MODE		1
+#define NORMAL_100_MODE		2
+#define NORMAL_200_MODE		3
+#define TIMER1_INTR		(0x1 << 22)
+
+/* pwm */
+#define PWM_BASE                 KA_PWM_BASE
+#define TCFG0                    PWM_BASE + 0x00
+#define TCFG1                    PWM_BASE + 0x04
+#define TCON0                    PWM_BASE + 0x08
+#define TCON1                    PWM_BASE + 0x0c
+#define TCNTB0                   PWM_BASE + 0x10
+#define TCMPB0                   PWM_BASE + 0x14
+#define TCNTO0                   PWM_BASE + 0x18
+#define TCNTB1                   PWM_BASE + 0x40
+#define TCNTO1                   PWM_BASE + 0x44
+#define TCNTB2                   PWM_BASE + 0x48
+#define TCNTO2                   PWM_BASE + 0x4c
+
+
+// SD Controller Registers
+#define MULTE 		(0x1 << 14)
+#define MIMSK 		(0x1 << 13)
+#define TAGD  		(0x1 << 12)
+#define SPIMW 		(0x1 << 11)
+#define MSTR  		(0x1 << 10)
+#define CSO   		(0x1 << 9)
+#define ENSCK 		(0x1 << 8)
+#define SMOD_PO 	(0x0 << 6)
+#define SMOD_INT 	(0x1 << 6)
+#define SMOD_DMA 	(0x2 << 6)
+#define DRD   		(0x1 << 5)
+#define DTD   		(0x1 << 4)
+#define CSLV  		(0x1 << 3)
+#define KEEP  		(0x1 << 2)
+#define CPOL  		(0x1 << 1)
+#define CPHA  		(0x1 << 0)
+#define TMOD_BYTE  	(0x0 << 4)
+#define TMOD_HWORD 	(0x1 << 4)
+#define TMOD_WORD  	(0x2 << 4)
+
+// NOR Flash MX25L6406E
+#define SERIAL_MODE_0	0x0
+#define SERIAL_MODE_3   0x3
+#define CODE_WREN       0x06
+#define CODE_WRDI       0x04
+#define CODE_RDSR       0x05
+#define CODE_WRSR       0x01
+#define CODE_READ       0x03
+#define CODE_PP         0x02    //Page Program
+#define CODE_SE         0x20    //sector erase
+#define CODE_BE         0xd8    //64KB block erase
+#define CODE_CE         0xc7    //chip erase
+#define CODE_DP         0xb9    //enter deep power down
+#define CODE_RDP        0xab    //release from deep power down
+#define CODE_REMS       0x90    //output manufacturer ID & DID
+#define CODE_RDSCUR     0x2b    //read security register
+#define CODE_WRSCUR     0x2f    //set lock-down bit as 1
+#define CODE_RDDMC      0x5a    //read DMC mode
+#define WIP             0x01
+#define WEL             0x02
+
+
+void init_timer1(void)
+{
+	//set timer 1 prescaler
+	word_write(TCON0, word_read(TCON0) & 0xff8fffff);
+	word_write(TCFG0, (word_read(TCFG0) & 0xff00ffff) | 0x00800000);
+	word_write(TCNTB1, 0x0);
+
+	//set timer 1 to interrupt mode & mux1
+	if(mode == NORMAL_200_MODE)		//mux1 = 1/8
+		word_write(TCFG1, (word_read(TCFG1) & 0xfefffcff) | 0x200);
+	else if (mode == NORMAL_100_MODE) 	//mux1 = 1/4
+		word_write(TCFG1, (word_read(TCFG1) & 0xfefffcff) | 0x100);
+	else 				//mux1 = 1/2
+		word_write(TCFG1, word_read(TCFG1) & 0xfefffcff);
+
+	//Unmask timer1 interrupt
+	word_write(INTC_INTMSK1_ADDR, word_read(INTC_INTMSK1_ADDR) & ~TIMER1_INTR);
+}
+void timer1_onoff(int usec)
+{
+	int val=0;
+
+	if(usec == 0) {	//stop timer
+		word_write(TCON0, word_read(TCON0) & 0xff8fffff);
+		word_write(TCNTB1, 0x0);
+	} else {
+		//set timer 1 count buffer value (= (freq * MUX * (msec/1000) / (PRE+1)) - 1)
+		if(mode == SLOW_MODE)
+			word_write(TCNTB1, (int)((47  * usec / 1000) - 1));
+		else
+			word_write(TCNTB1, (int)((194 * usec / 1000) - 1));
+		//start timer
+		val = word_read(TCON0) & 0xff8fffff;
+		word_write(TCON0, val | 0x00600000);	//load value to TCNTB1
+		word_write(TCON0, val | 0x00500000);
+	}
+}
+
+void set_wren(void)
+{
+	int i=0, done=0;
+
+	while(done == 0) {
+#ifdef DEBUG
+		//	show_str("Send WREN cmd.\n",0,"\n",1);
+#endif
+		while((word_read(SSI_STA) & 0x1) == 0) {} ;         		//SSI_CON ready
+		word_write(SSI_CON, TAGD+SPIMW+MSTR+ENSCK+SMOD_PO+KEEP+CSO);	//enabe CS
+		while((word_read(SSI_STA) & 0x1) == 0) {} ;         		//SSI_TDAT ready
+		word_write(SSI_TDAT, CODE_WREN);				//send WREN cmd
+		while((word_read(SSI_STA) & 0x1) == 0) {} ;			//cmd sent, data received
+		//word_read(SSI_RDAT);						//discard 1st data (will hang)
+		word_write(SSI_CON, TAGD+SPIMW+MSTR+ENSCK+SMOD_PO+KEEP);	//disable CS
+
+#ifdef DEBUG
+		//	show_str("Wait Write Enable status\n", 0, "\n", 1);
+#endif
+		while((word_read(SSI_STA) & 0x1) == 0) {} ;         		//SSI_CON ready
+		word_write(SSI_CON, TAGD+SPIMW+MSTR+ENSCK+SMOD_PO+KEEP+CSO);	//enable CS
+		while((word_read(SSI_STA) & 0x1) == 0) {} ;         		//SSI_TDAT ready
+		word_write(SSI_TDAT, CODE_RDSR);				//send RDSR cmd
+		while((word_read(SSI_STA) & 0x1) == 0) {} ;			//cmd sent, data received
+		word_read(SSI_RDAT);                                            //discard 1st dat
+		/*do {
+		    while((word_read(SSI_STA) & 0x1) == 0) {} ;
+		} while((word_read(SSI_RDAT) & WEL) == 0) ;*/
+		for(i=0, done=0; ((i<8) && !done); i++) {
+			while((word_read(SSI_STA) & 0x1) == 0) {} ;			//data received
+			if((word_read(SSI_RDAT) & 0x3) == WEL)			//check if WEL bit is set
+				done = 1;
+		}
+		while((word_read(SSI_STA) & 0x1) == 0) {} ;         		//SSI_CON ready
+		word_write(SSI_CON, TAGD+SPIMW+MSTR+ENSCK+SMOD_PO+KEEP);	//disable CS
+	}
+	while((word_read(SSI_STA) & 0x1) == 0) {} ;         		//wait ready
+#ifdef DEBUG
+	//  show_str("Exit set_wren().\n", 0, "\n", 1);
+#endif
+}
+
+int ssi_write(unsigned int start_addr,unsigned int *write_data, int len)
+{
+//	int i=0;
+	int j;
+//	unsigned int readSta = 0;
+	unsigned int v1, v2;
+	unsigned char *p;
+
+	//printf("SF Write: %x\n", start_addr);
+
+#ifndef CONFIG_SYS_PROGRAM_BIN
+	if (start_addr < 0x3000) {
+		printf("can't programe sf before 0x3000 at addr %x\n", start_addr);
+		return 0;
+	}
+#endif
+
+	//Set Write Enable & check Write Enable Latch bit
+	while((word_read(SSI_STA) & 0x1) == 0) {} ;         		//wait ready
+	word_write(SSI_STA, TMOD_BYTE);
+	while((word_read(SSI_STA) & 0x1) == 0) {} ;
+	word_read(SSI_RDAT);
+	set_wren();
+
+	//change to WORD mode
+	word_write(SSI_STA, TMOD_WORD);
+	while((word_read(SSI_STA) & 0x1) == 0) {} ;         		//wait ready
+	word_read(SSI_RDAT);
+
+#ifdef DEBUG
+	//show_str("Send SSI PAGE_PROGRAM command\n", start_addr, "\n", 1);
+#endif
+	while((word_read(SSI_STA) & 0x1) == 0) {} ;         		//SSI_CON ready
+	word_write(SSI_CON, TAGD+SPIMW+MSTR+ENSCK+SMOD_PO+KEEP+CSO);	//enable CS
+	while((word_read(SSI_STA) & 0x1) == 0) {} ;         		//SSI_TDAT ready
+	word_write(SSI_TDAT, (CODE_PP << 24) + start_addr);			//issue PAGE_PROGRAM cmd
+	while((word_read(SSI_STA) & 0x1) == 0) {} ;         		//cmd sent, data received
+
+	//write data 256 byte to spi flash
+	p = (unsigned char *)&v1;
+	for(j=0; (j<(len/4)); j++) {
+		v1 = write_data[j];					//read received data
+		v2 = (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3];
+//printf("v1 %x v2 %x\n", v1, v2);
+		word_write(SSI_TDAT, v2);				//transmit write data
+		while((word_read(SSI_STA) & 0x1) == 0) { } ; 			//data sent
+
+#ifdef DEBUG1
+		// show_str("Write:\n", write_data[j], "\n", 1);
+#endif
+	}
+	while((word_read(SSI_STA) & 0x1) == 0) {} ;         		//SSI_CON ready
+	word_write(SSI_CON, TAGD+SPIMW+MSTR+SMOD_PO+KEEP);			//disable CS
+	while((word_read(SSI_STA) & 0x1) == 0) {} ;         		//wait ready
+
+	//change to BYTE mode
+	word_write(SSI_STA, TMOD_BYTE);
+	while((word_read(SSI_STA) & 0x1) == 0) {} ;         		//wait Transfer ready (must have!)
+	word_read(SSI_RDAT);						//to reset counter
+
+#ifdef DEBUG
+	// show_str("Check program start (WIP set)\n", 0, "\n", 1);
+#endif
+	while((word_read(SSI_STA) & 0x1) == 0) {} ;         		//SSI_CON ready
+	word_write(SSI_CON, TAGD+SPIMW+MSTR+ENSCK+SMOD_PO+KEEP+CSO);	//enable CS
+	while((word_read(SSI_STA) & 0x1) == 0) {} ;         		//SSI_TDAT ready
+	word_write(SSI_TDAT, CODE_RDSR);					//issue RDSR cmd
+	while((word_read(SSI_STA) & 0x1) == 0) {} ;				//cmd sent, data received
+	word_read(SSI_RDAT);                                            	//discard 1st dat
+	//while(1) {
+	//    while((word_read(SSI_STA) & 0x1) == 0) {} ;			//data received
+	//    readSta = word_read(SSI_RDAT);					//read received data
+	//    if( (readSta & WIP) == 0x0) break;					//break if WIP set
+	//};
+	//for(i=0; i<120; i++);						//delay for programming
+
+#ifdef DEBUG
+	//show_str("Check Program Done (WIP reset)\n", 0, "\n", 1);
+#endif
+	timer1_onoff(5000);	//5ms
+	do {
+		while((word_read(SSI_STA) & 0x1) == 0) {} ;			//data received
+	} while(((word_read(SSI_RDAT) & WIP) == 1) && !int_flag);		//read received data & check if WIP set
+	timer1_onoff(0);
+	if(int_flag) { //timeout
+#ifdef DEBUG0
+		show_str("SSI write timeout.\n",int_flag, "\n", 1);
+#endif
+		int_flag = 0;
+		return 1;
+	}
+
+	while((word_read(SSI_STA) & 0x1) == 0) {} ;         		//SSI_CON ready
+	word_write(SSI_CON, TAGD+SPIMW+MSTR+SMOD_PO+KEEP);
+	while((word_read(SSI_STA) & 0x1) == 0) {} ;         		//wait ready
+
+	//disable Write Enable Latch (Flash reset WEL automatically)
+	//send_command(CODE_WRDI, 1, WEL, 1);
+	return 0;
+}
+
+
+void ssi_read(unsigned int start_addr, int len, unsigned int* read_buf)
+{
+	int i, j;
+//	unsigned int tmpBuf = 0;
+	unsigned int pi;
+	unsigned char *p;
+	//change to WORD mode
+	word_write(SSI_STA, TMOD_WORD);
+	while((word_read(SSI_STA) & 0x1) == 0) {} ;     			//data ready to read
+	word_read(SSI_RDAT); 						//reset counter
+
+
+	//printf("SF READ %d, ", len);
+	//printf(" addr %x\n", start_addr);
+
+	for(i=0; i<20; i++);
+	while((word_read(SSI_STA) & 0x1) == 0) {} ;         		//SSI_CON ready
+	word_write(SSI_CON, TAGD+SPIMW+MSTR+ENSCK+SMOD_PO+KEEP+CSO);	//enable CS
+	while((word_read(SSI_STA) & 0x1) == 0) {} ;         		//SSI_TDAT ready
+	word_write(SSI_TDAT, (CODE_READ << 24) + start_addr);		//issue READ cmd
+	while((word_read(SSI_STA) & 0x1) == 0) {} ;            		//cmd sent, data received
+
+	word_read(SSI_RDAT);					//read received data
+
+	p = (unsigned char *)(&pi);
+	for(i = 0, j=0; i< len; i+=4, j++) {
+		pi = word_read(SSI_RDAT);					//read received data
+		read_buf[j] = (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3] ;
+		//if(j > 0) read_buf[j-1] = tmpBuf & 0xffffffff;			//discard 1st data (dummy)
+		while((word_read(SSI_STA) & 0x1) == 0) {} 			//next data received
+
+		//printf("%08x, ", read_buf[j]);
+		//if ((i % 8)==7) printf("\n");
+	}
+
+	//show_str("SSI Read done.\n", 0, "\n", 1);
+	//printf("\n");
+
+	while((word_read(SSI_STA) & 0x1) == 0) {} ;         		//SSI_CON ready
+	word_write(SSI_CON, TAGD+SPIMW+MSTR+ENSCK+SMOD_PO+KEEP);		//disable CS
+	while((word_read(SSI_STA) & 0x1) == 0) {} ;         		//wait ready
+}
+
+
+int sector_erase(unsigned int start_addr)
+{
+	int i=0;
+
+	//printf("Erase sector %d\n",start_addr);
+	//printf(".");
+
+	//Set Write Enable & check Write Enable Latch bit
+	while((word_read(SSI_STA) & 0x1) == 0) {} ;         		//wait ready
+	word_write(SSI_STA, TMOD_BYTE);					//change to BYTE mode
+	while((word_read(SSI_STA) & 0x1) == 0) {} ;         		//receive data ready
+	word_read(SSI_RDAT);						//to reset counter
+	//while((word_read(SSI_STA) & 0x1) == 0) {} ;
+	set_wren();								//set WREN
+
+	//change to WORD mode
+	word_write(SSI_STA, TMOD_WORD);					//change to WORD mode
+	while((word_read(SSI_STA) & 0x1) == 0) {} ;         		//receive data ready
+	word_read(SSI_RDAT);						//to reset counter
+
+#ifdef DEBUG
+	//show_str("Send Sector Erase Cmd.\n",0,"\n",1);
+#endif
+	while((word_read(SSI_STA) & 0x1) == 0) {} ;         		//SSI_CON ready
+	word_write(SSI_CON, TAGD+SPIMW+MSTR+ENSCK+SMOD_PO+KEEP+CSO);	//enable CS
+	while((word_read(SSI_STA) & 0x1) == 0) {} ;         		//SSI_TDAT ready
+	word_write(SSI_TDAT, (CODE_SE << 24) + start_addr);			//issue SE cmd
+	while((word_read(SSI_STA) & 0x1) == 0) {} ;         		//cmd sent, data received
+	word_write(SSI_CON, TAGD+SPIMW+MSTR+ENSCK+SMOD_PO+KEEP);		//disable CS
+	while((word_read(SSI_STA) & 0x1) == 0) { } ; 			//wait Transfer ready
+
+#ifdef DEBUG
+	//show_str("Check in progress status (wait WIP set).\n",0,"\n",1);
+#endif
+	//check in progress status
+	word_write(SSI_STA, TMOD_BYTE);					//change to BYTE mode
+	while((word_read(SSI_STA) & 0x1) == 0) {} ;         		//wait data ready
+	word_read(SSI_RDAT);						//to reset counter
+
+	while((word_read(SSI_STA) & 0x1) == 0) {} ;         		//SSI_CON ready
+	word_write(SSI_CON, TAGD+SPIMW+MSTR+ENSCK+SMOD_PO+KEEP+CSO);	//enable CS
+	while((word_read(SSI_STA) & 0x1) == 0) {} ;         		//SSI_STA ready
+	word_write(SSI_TDAT, CODE_RDSR);					//send RDSR cmd
+	while((word_read(SSI_STA) & 0x1) == 0) {} ;         		//cmd sent, data received
+	word_read(SSI_RDAT);                                		//discard 1st data
+
+	timer1_onoff(10000); //10ms
+	do {
+		while((word_read(SSI_STA) & 0x1) == 0) {} ;			//next data received
+	} while(((word_read(SSI_RDAT) & WIP) == 0) && !int_flag);		//read received data & check if WIP set
+	timer1_onoff(0);
+	if(int_flag) { //timeout
+#ifdef DEBUG0
+		show_str("SSI erase timeout(80).\n",int_flag, "\n", 1);
+#endif
+		int_flag = 0;
+		return 1;
+	}
+
+	while((word_read(SSI_STA) & 0x1) == 0) {} ;         		//SSI_CON ready
+	word_write(SSI_CON, TAGD+SPIMW+MSTR+ENSCK+SMOD_PO+KEEP);		//disabe CS
+
+	for(i=0; i<400; i++);
+	//check program ok (wait WIP clear)
+	while((word_read(SSI_STA) & 0x1) == 0) {} ;         		//SSI_CON ready
+	word_write(SSI_CON, TAGD+SPIMW+MSTR+ENSCK+SMOD_PO+KEEP+CSO);	//enable CS
+	while((word_read(SSI_STA) & 0x1) == 0) {} ;         		//SSI_TDAT ready
+	word_write(SSI_TDAT, CODE_RDSR);					//issue RDSR cmd
+	while((word_read(SSI_STA) & 0x1) == 0) {} ;         		//cmd sent, data received
+	word_read(SSI_RDAT);                                		//discard 1st data
+
+	timer1_onoff(300000); //300ms
+	do {
+		while((word_read(SSI_STA) & 0x1) == 0) {} ;			//next data received
+	} while(((word_read(SSI_RDAT) & WIP) == 1) && !int_flag);		//read received data & check if WIP clear
+	timer1_onoff(0);
+	if(int_flag) { //timeout
+#ifdef DEBUG0
+		show_str("SSI erase timeout(300).\n",int_flag, "\n", 1);
+#endif
+		int_flag = 0;
+		return 1;
+	}
+
+	while((word_read(SSI_STA) & 0x1) == 0) {} ;         		//SSI_CON ready
+	word_write(SSI_CON, TAGD+SPIMW+MSTR+ENSCK+SMOD_PO+KEEP);		//disable CS
+	while((word_read(SSI_STA) & 0x1) == 0) {} ;         		//wait ready
+
+#ifdef DEBUG
+	// show_str("Erase sector done.\n",start_addr,"\n",1);
+#endif
+	return 0;
+}
+
+
+void ssi_init(void)
+{
+	init_timer1();	//setup timer 1 for timeout
+
+	//Initialize SSI Controller (NOR Flash)
+	while((word_read(SSI_STA) & 0x1) == 0) {}; //Transfer Ready
+	word_write(SSI_PRE, 0x0); //baud rate = PCLK/2/(SSI_PRE+1)
+
+}
+
+struct soft_spi_slave {
+	struct spi_slave slave;
+	unsigned int mode;
+};
+
+static inline struct soft_spi_slave *to_soft_spi(struct spi_slave *slave) {
+	return container_of(slave, struct soft_spi_slave, slave);
+}
+
+
+void spi_init (void)
+{
+	//printf("ka2000 spi_init\n");
+	ssi_init();
+}
+
+int spi_cs_is_valid(unsigned int bus, unsigned int cs)
+{
+	return bus == 0 && cs == 0;
+}
+
+
+struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
+                                  unsigned int max_hz, unsigned int mode) {
+	struct soft_spi_slave *ss;
+
+	if (!spi_cs_is_valid(bus, cs))
+		return NULL;
+
+	ss = malloc(sizeof(struct soft_spi_slave));
+	if (!ss)
+		return NULL;
+
+	ss->slave.bus = bus;
+	ss->slave.cs = cs;
+	ss->mode = mode;
+
+	/* TODO: Use max_hz to limit the SCK rate */
+
+	return &ss->slave;
+}
+
+void spi_free_slave(struct spi_slave *slave)
+{
+	struct soft_spi_slave *ss = to_soft_spi(slave);
+
+	free(ss);
+}
+
+int spi_claim_bus(struct spi_slave *slave)
+{
+//	struct soft_spi_slave *ss = to_soft_spi(slave);
+
+	return 0;
+}
+
+void spi_release_bus(struct spi_slave *slave)
+{
+	/* Nothing to do */
+}
+
+
+
+struct ka2000_spi_flash_params {
+	u16 idcode;
+	u16 page_size;
+	u16 pages_per_sector;
+	u16 sectors_per_block;
+	u16 nr_blocks;
+	const char *name;
+};
+
+struct ka2000_spi_flash {
+	struct spi_flash flash;
+	const struct ka2000_spi_flash_params *params;
+};
+
+int  spi_xfer(struct spi_slave *slave, unsigned int bitlen,
+              const void *dout, void *din, unsigned long flags)
+{
+	return 0;
+}
+
+static inline struct ka2000_spi_flash *to_ka2000_spi_flash(struct spi_flash
+                *flash) {
+	return container_of(flash, struct ka2000_spi_flash, flash);
+}
+
+
+/*
+static int ka2000_wait_ready(struct spi_flash *flash, unsigned long timeout)
+{
+	return 0;
+}
+*/
+
+int ka2000_sf_read(struct spi_flash *flash, u32 offset, size_t len, void *buf)
+{
+	int i, n, s;
+#define BLK_SZ (4096*4) //512
+	n = BLK_SZ;
+	s = len;
+	for (i = 0; i < len; i += BLK_SZ) {
+		if (s < BLK_SZ)
+			n = s;
+		else
+			n = BLK_SZ;
+		if (i & 1) printf(".");
+		ssi_read(offset+i, n, buf+i);
+		s -= BLK_SZ;
+	}
+	//printf("\n---->sf read done\n");
+	return 0;
+}
+
+
+int ka2000_sf_write(struct spi_flash *flash,
+                    u32 offset, size_t len, const void *buf)
+{
+	int i, n, s;
+
+#ifndef CONFIG_SYS_PROGRAM_BIN
+	if (offset < 0x3000) {
+		printf("skip - offset invalid %d\n", offset);
+		return 0;
+	}
+#endif
+
+#define W_BLK_SZ 256
+	n = BLK_SZ;
+	s = len;
+	//printf("len=%d\n", len);
+	for (i = 0; i < len; i += W_BLK_SZ) {
+		if (s < W_BLK_SZ)
+			n = s;
+		else
+			n = W_BLK_SZ;
+
+		if((i % 1000) == 0) printf(".");
+		//_ka2000_erase(offset+i, BLK_SZ);
+
+		ssi_write(offset+i, buf+i, n);
+		s -= W_BLK_SZ;
+	}
+
+	//printf("\n---->sf write done\n");
+	return 0;
+}
+
+
+int ka2000_sf_erase(struct spi_flash *flash, u32 offset, size_t len)
+{
+
+	int i, block;
+	int n = len / 4096;
+
+#ifndef CONFIG_SYS_PROGRAM_BIN
+	if (offset < 0x3000) {
+		printf("skip - offset invalid %d\n", offset);
+		return 0;
+	}
+#endif
+	if ((offset % 4096) != 0) {
+		printf("skip - offset not aligned %d\n", offset);
+		return 0;
+	}
+
+	if (len < 4096 || ((len % 4096) != 0)) {
+		printf("skip - len invalid %d\n", len);
+		return 0;
+	}
+
+	if (len % 4096)
+		n++;
+
+	for (i = 0; i < n; i++) {
+		block = offset / 4096;
+		sector_erase(block * 4096);
+		if((i % 100) == 0) printf(".");
+		offset += 4096;
+	}
+
+	//printf("\n---->sf erase done\n");
+	return 0;
+}
+
+struct ka2000_spi_flash ka2000_sf;
+struct ka2000_spi_flash_params ka2000_sf_params = {
+	.idcode = 0x2017,
+	.page_size = 256,
+	.pages_per_sector = 16,
+	.sectors_per_block = 16,
+	.nr_blocks = 128,
+	.name = "MX25L6405D",
+};
+
+struct spi_flash *spi_flash_probe_ka2000(struct spi_slave *spi, u8 *idcode) {
+	struct ka2000_spi_flash *sf;
+	struct ka2000_spi_flash_params *params;
+//	unsigned int i;
+//	u16 id = idcode[2] | idcode[1] << 8;
+
+	//printf("spi_flash_probe_ka2000 %d\n", id);
+
+	sf = &ka2000_sf; //malloc(sizeof(*sf));
+	//if (!sf) {
+	//	printf("SF: Failed to allocate memory\n");
+	//	return NULL;
+	//}
+
+	params = &ka2000_sf_params;
+	sf->params = params;
+	sf->flash.spi = spi;
+	sf->flash.name = params->name;
+
+	sf->flash.write = ka2000_sf_write;
+	sf->flash.erase = ka2000_sf_erase;
+	sf->flash.read = ka2000_sf_read;
+	sf->flash.size = params->page_size * params->pages_per_sector
+	                 * params->sectors_per_block * params->nr_blocks;
+
+	//printf("SF: Detected %s with page size %u, total %u bytes\n",
+	//      params->name, params->page_size, sf->flash.size);
+
+	return &sf->flash;
+}
+
+
+
+
diff --git a/arch/arm/cpu/arm926ejs/keyasic/lowlevel_init.S b/arch/arm/cpu/arm926ejs/keyasic/lowlevel_init.S
new file mode 100644
index 0000000..96b8e5c
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/keyasic/lowlevel_init.S
@@ -0,0 +1,58 @@
+/*
+ * Low-level board setup code for KA2000 SoC boards.
+ * Board specific setup info
+ *
+ * (C) Copyright 2010
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+
+.globl	lowlevel_init
+lowlevel_init:
+
+	/*------------------------------------------------------*
+	 * Mask all IRQs 					*
+	 *------------------------------------------------------*/
+	/*------------------------------------------------------*
+	 * PLL Initialization					*
+	 *------------------------------------------------------*/
+	/*------------------------------------------------------*
+	 * Issue Soft Reset 					*
+	 *------------------------------------------------------*/
+	/*------------------------------------------------------*
+	 * Turn Controller Clocks On				*
+	 *------------------------------------------------------*/
+	/*------------------------------------------------------*
+	 * System PLL Initialization				*
+	 *------------------------------------------------------*/
+
+	/*nop
+	nop */
+
+
+	/*
+	 * Call board-specific lowlevel init.
+	 * That MUST be present and THAT returns
+	 * back to arch calling code with "mov pc, lr."
+	 */
+	b	ka_board_init
+
+.ltorg
+
+DUMMY_VAL:
+	.word	0xa55aa55a
diff --git a/arch/arm/cpu/arm926ejs/keyasic/misc_init.S b/arch/arm/cpu/arm926ejs/keyasic/misc_init.S
new file mode 100644
index 0000000..67409b4
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/keyasic/misc_init.S
@@ -0,0 +1,53 @@
+/*
+ * Misc board setup code for KA2000 SoC boards.
+ *
+ * (C) Copyright 2010
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+.globl cpu_setup
+cpu_setup:
+	mov     r0, #0
+        mcr     p15, 0, r0, c7, c7, 0           /* invalidate I,D caches on v4 */
+        mcr     p15, 0, r0, c7, c10, 4          /* drain write buffer on v4 */
+        mcr     p15, 0, r0, c8, c7, 0           /* invalidate I,D TLBs on v4, for MMU */
+                                                                                                                                                                                   
+        /*mov     r0, r0, #(0x03 << 30)         // way3
+        orr     r0, r0, #(0x07 << 5)            // set=7
+        mcr     p15, 0, r0, c7, c14, 1          // write tag for d cache
+	*/
+                                                                                                                                                                                   
+        mov     r0, #(0x40 << 8)
+        orr     r0, r0, #(0xf0 << 16)           /* 0xf0 << 16 */
+        orr     r0, r0, #(0x01 << 24)           /* 0x01 << 24 */
+        mcr     p15, 0, r0, c2, c0, 0           /* write TTBR */
+                                                                                                                                                                                   
+        mov     r0, #0x1f
+        mcr     p15, 0, r0, c3, c0, 0           /* write domain */
+        MOV     pc,lr
+
+.globl test_clean_dcache
+test_clean_dcache:
+	mrc 	p15, 0, r15, c7, c10, 3
+        bne	test_clean_dcache
+        mov     pc, lr
+
+.globl goto_offset
+goto_offset:
+        mov     r0, #0x40000
+        mov     pc, r0
+
diff --git a/arch/arm/cpu/arm926ejs/keyasic/reset.S b/arch/arm/cpu/arm926ejs/keyasic/reset.S
new file mode 100644
index 0000000..fa92117
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/keyasic/reset.S
@@ -0,0 +1,31 @@
+/*
+ * Processor reset for KeyAsic KA2000 SoC.
+ *
+ * Copyright (C) 2010
+ *
+ * -----------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+.globl reset_cpu
+reset_cpu:
+	/* TODO: placeholder */
+	nop
+	nop
+reset_cpu_loop:
+	b	reset_cpu_loop
+
diff --git a/arch/arm/cpu/arm926ejs/keyasic/rw_support.S b/arch/arm/cpu/arm926ejs/keyasic/rw_support.S
new file mode 100644
index 0000000..de3f202
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/keyasic/rw_support.S
@@ -0,0 +1,105 @@
+/************************************************
+ * This confidential and proprietary software may be used only as
+ * authorised by a licensing agreement from ARM Limited
+ *   (C) COPYRIGHT 2001 ARM Limited
+ *       ALL RIGHTS RESERVED
+ * The entire notice above must be reproduced on all authorised
+ * copies and copies may only be made to the extent permitted
+ * by a licensing agreement from ARM Limited.
+ ************************************************/
+
+/*
+ * (C) Copyright 2010
+ *
+ * Read / Write support functions
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*   AREA rw_support, CODE, READONLY ;READONLY is default for CODE */
+
+/*----------------------------------------------------------------
+ word_write(int addr, int data)
+ writes a word to an address
+ r0 contains addr
+ r1 contains data
+ -----------------------------------------------------------------*/
+.globl word_write
+word_write:
+    stmfd SP!,{lr}  /* save return address to stack */
+    str r1,[r0,#0]  /* store data */
+    ldmfd SP!,{pc}  /* return */
+
+/*-----------------------------------------------------------------
+ word_read(int addr)
+ reads a word from an address
+ r0 contains addr
+ -----------------------------------------------------------------*/
+.globl word_read
+word_read:
+    STMFD SP!,{r1,lr}  /* save return address and r1 to stack */
+    LDR r1,[r0,#0]     /* load temp with data */
+    MOV r0, r1         /* copy temp to r0 for return value */
+    LDMFD SP!,{r1,pc}  /* return */
+ 
+/*-----------------------------------------------------------------
+ hword_write(int addr, int data)
+ writes a half word to an address
+ r0 contains addr
+ r1 contains data
+ -----------------------------------------------------------------*/
+.globl hword_write
+hword_write:
+    STMFD SP!,{lr}  /* save return address to stack */
+    STRH r1,[r0,#0] /* store data */
+    LDMFD SP!,{pc}  /* return */
+
+/*-----------------------------------------------------------------
+ hword_read(int addr)
+ reads a half word from an address
+ r0 contains addr
+ -----------------------------------------------------------------*/
+.globl hword_read
+hword_read:
+    STMFD SP!,{r1,lr}  /* save return address and r1 to stack */
+    LDRH r1,[r0,#0]    /* load temp with data */
+    MOV r0, r1         /* copy temp to r0 for return value */
+    LDMFD SP!,{r1,pc}  /* return */
+ 
+/*-----------------------------------------------------------------
+ byte_write(int addr, int data)
+ writes a byte to an address
+ r0 contains addr
+ r1 contains data
+ -----------------------------------------------------------------*/
+.globl byte_write
+byte_write:
+    STMFD SP!,{lr}  /* save return address to stack */
+    STRB r1,[r0,#0] /* store data */
+    LDMFD SP!,{pc}  /* return */
+ 
+/*-----------------------------------------------------------------
+ byte_read(int addr)
+ reads a byte from an address
+ r0 contains addr
+-----------------------------------------------------------------*/
+.globl byte_read
+byte_read:
+    STMFD SP!,{r1,lr}  /* save return address and r1 to stack */
+    LDRB r1,[r0,#0]    /* load temp with data */
+    MOV r0, r1         /* copy temp to r0 for return value */
+    LDMFD SP!,{r1,pc}  /* return */
+ 
diff --git a/arch/arm/cpu/arm926ejs/keyasic/sdctrl.c b/arch/arm/cpu/arm926ejs/keyasic/sdctrl.c
new file mode 100644
index 0000000..2f08f50
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/keyasic/sdctrl.c
@@ -0,0 +1,1568 @@
+/* SD Controller
+ *
+ * SD card must be written to 6 blks to prevent file system for message lost.
+ *
+ */
+#include <config.h>
+#include <common.h>
+#include <mmc.h>
+#include <asm/errno.h>
+#include <asm/arch/hardware.h>
+#include <part.h>
+
+#include <asm/arch/reg_defs.h>
+
+#include "sdctrl.h"
+
+#define M2_INIT_CARD 0
+
+//#define show_str_en
+//#define simulation
+#define SINGLE_BLOCK
+
+//#define SIYO_READER
+//#define GEN3
+#if CONFIG_SYS_VER > 1 //#ifdef CONFIG_V34
+#define SPECIAL_REG     0xa000a140
+#else
+#define SPECIAL_REG     0xa000a0c8
+#endif
+
+#define DMA_WADDR 	0x00b10000
+#define DMA_RADDR 	0x00b10000
+#define EN_INTR	  	(0x1  << 24)
+#define BLK_CNT		0x01
+#define XFER_COUNT	0x200
+#define BUF_BLK_CNT	(BLK_CNT << 16)
+#define BUF_XFER_START	(0x1  << 2)
+#define BUF_WRITE	(0x1  << 1)
+#define FIFO_XFER_DONE	0x1
+#define SD_XFER_DONE	0x2
+#define SD_CMD_DONE	0x4
+#define SD_DATA_BOUND	0x8
+#define DMA_CH0_INTR	0x1
+#define DMA_CH1_INTR	0x2
+
+#define SD_CLOCK_EN		(0x1 << 13)
+#define SDSW_CLOCK_EN		(0x1 << 17)
+#define SDIO_CLOCK_EN		(0x1 << 9)
+
+int HighCap;
+int RCA0, RCA1;
+unsigned int OCR1, OCR2, RSP1;
+int m1_m2 = 1;
+
+/* for interrupt in ISR */
+volatile int CRXferDone;
+volatile int CRCardErr;
+volatile int CRXferBDone;
+volatile int CRCmdDone;
+volatile int CRXferFinish;
+
+//#define show_str_en
+//#define show_str(a, b, c, d);  printf("%x %d %s", b, d, a);
+#ifdef show_str_en
+#define DBG printf
+//#define show_str(a, b, c, d);  printf("%d, %d, %s", b, d, a );
+#else
+#define DBG(...); {}
+//void show_str(char *start,unsigned int input,char *end,int end_len){}
+#endif
+
+int m1_err = 0;
+#ifdef SIYO_READER
+int special_cont = 0;
+#endif
+
+void buzzer_off(void);
+void buzzer_on(int tone);
+
+void InitCardReader(void)
+{
+#ifdef show_str_en
+	show_str("Enter InitCardReader().\n",0,"\n",1);
+#endif
+
+	word_write(SCU_CLK_SRC_CTL, word_read(SCU_CLK_SRC_CTL) | SD_CLOCK_EN | SDSW_CLOCK_EN | SDIO_CLOCK_EN);
+	word_write(0xa0000014, 0x1);
+
+	//Initialize DMA
+	word_write(SDR_DMA_TCCH0_REG, XFER_COUNT);
+	word_write(SDR_DMA_TCCH1_REG, XFER_COUNT);
+	word_write(SDR_Card_BLOCK_SET_REG,(0x00000100|BLK_CNT));
+	word_write(SDR_Error_Enable_REG, 0x6f);			//enable all errors
+
+	word_write(SDSW_M1_RDATA_TOUT_REG, 0xe000000);
+	word_write(SDSW_DIRECT_CTRL_REG, 0);
+
+	word_write(SDR_DMA_TRAN_RESP_REG, 0x1f);
+	word_write(SDR_DMA_INTS_REG, 0x3);
+
+	//word_write(0xa000a01c, 0x2);
+	//word_write(SPECIAL_REG, 0x2);
+}
+
+//------------------------------------------------------------------------------
+static int null_delay(int t)
+{
+	volatile int i = 0;
+	int j = 0;
+	for (i = 0; i < t; i++) {
+		j++;
+	}
+	return j;
+}
+//------------------------------------------------------------------------------
+
+int m1_busy(void)
+{
+	if (m1_err)
+		return 0;
+
+	if ((word_read(SDSW_M1_STATUS) & 0x3f3f0000) != 0x20200000) {
+		if (m1_m2 == 2)
+			switch_to_m1();
+		return 1;
+	}
+
+	return 0;
+}
+
+//------------------------------------------------------------------------------
+
+int wait_m1_ready(int time_out)
+{
+	volatile int t = time_out;
+
+	while (t-- > 0) {
+		RCA0 = word_read(0xa000a09c) & 0xff;
+		RCA1 = (word_read(0xa000a09c) & 0xff00) >> 8;
+		//printf("Status %x RCA0 %x, RCA1 %x\n", word_read(SDSW_M1_STATUS), RCA0, RCA1);
+		if (word_read(SDSW_M1_STATUS) == 0x20200804)
+			return 1;
+
+		//word_write(0xa000a01c, (1<<3) | (1<<2));
+	}
+	printf("Wait m1 timeout - Status %x RCA0 %x, RCA1 %x\n", word_read(SDSW_M1_STATUS), RCA0, RCA1);
+
+	m1_err = 1;
+
+	//while (1) {}
+	return 0;
+}
+
+//------------------------------------------------------------------------------
+void command_read_pre_clear_status(void)
+{
+	word_write(SDR_Card_BLOCK_SET_REG,(0x00000100|BLK_CNT));
+
+	word_write(SDR_DMA_TRAN_RESP_REG, (FIFO_XFER_DONE|SD_XFER_DONE|SD_CMD_DONE));	//clear all flags
+	word_write(SDR_DMA_INTS_REG, 0x3);							//clear interrupts
+}
+
+//------------------------------------------------------------------------------
+int command_read_single_block(unsigned int blk_flag)
+{
+	unsigned int LBA0, LBA1, LBA2;
+
+	LBA0 = (( blk_flag) & 0x000000ff);
+	LBA1 = (( blk_flag) & 0x0000ff00) >> 8;
+	LBA2 = (( blk_flag) & 0x00ff0000) >> 16;
+
+	// CMD17 (READ_SINGLE_BLOCK)
+	// [31:0]data addr, R1
+	if(HCmdNoData(0x00, LBA2, LBA1, LBA0, 0x11, 0x79, 0x11))
+		return 1;
+	return 0;
+}
+//------------------------------------------------------------------------------
+int CardRead_single_pin(unsigned int buf_dest_addr, unsigned int blk_no, int blk_num)
+{
+	unsigned int i;
+	int blk_flag=0;
+	unsigned int LBA0, LBA1, LBA2,DMA_RADDR_start;
+
+#ifdef show_str_en
+	show_str("Enter CardRead_single_pin().\n",0,"\n",1);
+#endif
+	//printf("r %d %d @%x\n", blk_no, blk_num, buf_dest_addr);
+	/*word_write(SDR_CTRL_REG, word_read(SDR_CTRL_REG) | 0x40);
+	for(i=0; i<100; i++); */
+	if (m1_busy())
+		goto  fail;
+
+	for(i = 0; i<blk_num ; i++) {
+		if (switch_to_m2() == 0)
+			goto fail;
+		WaitBusReady(0x0c);
+
+		blk_flag = blk_no + i;
+
+#ifdef show_str_en
+		show_str("Send Read Block CMD. Blk\n",blk_flag,"\n",1);
+#endif
+		CRXferDone = 0;
+		CRCardErr = 0;
+		CRXferBDone = 0;
+		CRXferFinish = 0;
+		word_write(SDR_Card_BLOCK_SET_REG,(0x00000100|BLK_CNT));
+
+#ifdef simulation
+		LBA0 = (( blk_flag * 512) & 0x000000ff);
+		LBA1 = (( blk_flag * 512) & 0x0000ff00) >> 8;
+		LBA2 = (( blk_flag * 512) & 0x00ff0000) >> 16;
+#else
+		LBA0 = (( blk_flag) & 0x000000ff);
+		LBA1 = (( blk_flag) & 0x0000ff00) >> 8;
+		LBA2 = (( blk_flag) & 0x00ff0000) >> 16;
+#endif
+
+		word_write(SDR_DMA_TRAN_RESP_REG, (FIFO_XFER_DONE|SD_XFER_DONE|SD_CMD_DONE));	//clear all flags
+		word_write(SDR_DMA_INTS_REG, 0x3);							//clear interrupts
+
+		// CMD17 (READ_SINGLE_BLOCK)
+		// [31:0]data addr, R1
+		if(HCmdNoData(0x00, LBA2, LBA1, LBA0, 0x11, 0x79,0x11))
+			goto fail;
+
+		if(i > 0) { //the (i>0)th blk
+			DMA_RADDR_start = DMA_RADDR + (512 * (i-1));
+
+			//start DMA
+			word_write(SDR_DMA_TCCH1_REG, XFER_COUNT);
+			word_write(SDR_DMA_DACH1_REG, DMA_RADDR_start);
+			word_write(SDR_DMA_CTRCH1_REG, 0x3F);
+			word_write(SDR_DMA_CTRCH1_REG, 0x33);
+			word_write(SDR_BUF_TRAN_CTRL_REG, BUF_BLK_CNT | BUF_XFER_START);
+
+			//wait sd card transfer done for i-th block, transfer finish for (i-1)th block
+			if(WaitResp(FIFO_XFER_DONE|SD_XFER_DONE, 0))
+				goto fail;
+			WaitDMAIntr(DMA_CH1_INTR);			//data moved to memory
+
+		} else if(i==0) {
+			if(WaitResp(SD_XFER_DONE, 0))			//first block of data read from SD card
+				goto fail;
+		}
+		switch_to_m1();
+	}
+	if((i-1)==(blk_num-1)) {
+		printf(".");
+		//if (switch_to_m2() == 0)
+		//    return 0;
+		CardRead_dma(buf_dest_addr, blk_flag, (i-1));
+		//   if ((word_read(SDSW_M1_STATUS) & 0x3f3f0000) != 0x20200000)
+		//        switch_to_m1();
+	}
+//pass:
+	switch_to_m1();
+	return 0;
+fail:
+#ifdef show_str_en
+	show_str("CardRead_single() Fail.\n",0,"\n",1);
+#endif
+	switch_to_m1();
+	return 1;
+}
+
+int CardRead_dma(unsigned int buf_dest_addr, unsigned int blk_no, int blk_order)
+{
+	int DMA_RADDR_start, i;
+
+	//start FIFO & DMA transfer
+	DMA_RADDR_start = DMA_RADDR + (512 * (blk_order));
+	word_write(SDR_DMA_DACH1_REG, DMA_RADDR_start);
+	word_write(SDR_DMA_CTRCH1_REG,0x3F);
+	word_write(SDR_DMA_CTRCH1_REG,0x33);
+	word_write(SDR_BUF_TRAN_CTRL_REG, (BUF_BLK_CNT | BUF_XFER_START));
+
+	if(WaitResp(FIFO_XFER_DONE, 0))		//last block of data moved to FIFO
+		goto fail;
+	WaitDMAIntr(DMA_CH1_INTR);			//last block of data moved to DMA
+
+	//write all read data to destination buffer
+	for (i = 0; i <= blk_order; i++)
+		write_512_buffer(buf_dest_addr + (512*(i)), DMA_RADDR + (512*(i)));
+	return 0;
+
+fail:
+	return 1;
+}
+
+void write_512_buffer(unsigned int dest_addr, unsigned int DMA_RADDR_start)
+{
+//	unsigned int data;
+	unsigned int data_temp;
+	int j;
+
+	for(j=0; j<128; j++) {
+		data_temp = word_read( DMA_RADDR_start + (j*4));
+		/*
+		            data  = ((data_temp & 0xff000000) >> 24)|
+		                    ((data_temp & 0x00ff0000) >> 8 )|
+		                    ((data_temp & 0x0000ff00) << 8 )|
+		                    ((data_temp & 0x000000ff) << 24);
+		*/
+		word_write(dest_addr + (j*4), data_temp);
+#ifdef show_str_en_v
+		show_str("bufRd:\n",data_temp,"\n",1);
+#endif
+	}
+}
+
+int CardErase_single(unsigned int blk_no)
+{
+	unsigned int LBA0, LBA1, LBA2;
+
+#ifdef show_str_en
+	show_str("Enter CardErase_single().\n",blk_no,"\n",1);
+#endif
+	if (switch_to_m2() == 0)
+		return 0;
+	//Wait SD card turn to transfer state (0xc: wait SD card exist, DAT[0] free)
+	WaitBusReady(0x0c);
+
+	CRXferDone = 0;
+	CRCardErr = 0;
+	CRXferBDone = 0;
+	CRXferFinish = 0;
+
+#ifdef simulation
+	LBA0 = (( blk_no * 512) & 0x000000ff);
+	LBA1 = (( blk_no * 512) & 0x0000ff00) >> 8;
+	LBA2 = (( blk_no * 512) & 0x00ff0000) >> 16;
+#else
+	LBA0 = ( blk_no & 0x000000ff);
+	LBA1 = ( blk_no & 0x0000ff00) >> 8;
+	LBA2 = ( blk_no & 0x00ff0000) >> 16;
+#endif
+
+	word_write(SDR_Card_BLOCK_SET_REG,(0x00000100|BLK_CNT));
+
+	// CMD32 (ERASE WR BLOCK START ADDR - set the addr of 1st write block to be erased)
+	// [31:0]data addr, R1
+	if(HCmdNoData(0x00, LBA2, LBA1, LBA0, 0x20, 0x38, 0x11))
+		goto fail;
+
+	// CMD33 (ERASE WR BLOCK END ADDR - set the addr of last write block to be erased)
+	// [31:0]data addr, R1
+	if(HCmdNoData(0x00, LBA2, LBA1, LBA0, 0x21, 0x38, 0x11))
+		goto fail;
+
+	// CMD38 (ERASE - erase all selected write blocks)
+	// [31:0]stuff bits, R1b
+	if(HCmdNoData(0x00, 0x00, 0x00, 0x00, 0x26, 0x38, 0x11))
+		goto fail;
+
+	//wait sd card transfer done
+	if(WaitResp(SD_XFER_DONE, 0))
+		goto fail;
+
+	//clear transfer done and finish flags
+	word_write(SDR_DMA_TRAN_RESP_REG, SD_XFER_DONE);
+
+#ifdef show_str_en
+	show_str("CardErase_single() Passed.\n",blk_no,"\n",1);
+#endif
+	switch_to_m1();
+	return 0;
+fail:
+#ifdef show_str_en
+	show_str("CardErase_single() Failed.\n",blk_no,"\n",1);
+#endif
+	switch_to_m1();
+	return 1;
+}
+
+extern int switch_to_m2_sw(int flag);
+int m2_err = 0;
+int switch_to_m2(void)
+{
+	int time_out = 100;
+	int i;
+	int res;
+	//printf("->M2\n");
+
+	if (m1_err)
+		return 0;
+#ifdef SIYO_READER
+	if(special_cont) {
+		do {
+			word_write(SDSW_M1_CTRL0, 0x0);
+		} while((word_read(SDSW_M1_CTRL0) & 0x1) == 0x1);
+		goto tom2;
+	}
+#endif
+
+//#ifndef GEN3
+	res = switch_to_m2_sw(0);
+	if(!res)
+		m1_m2 = 2;
+	return !res; // !switch_to_m2_sw();
+//#endif
+
+#ifdef DEBUG
+	//show_str("Switch to M2\n",0,"\n",1);
+#endif
+	if ((SDSW_M2_CTRL0) == 1 && word_read(SDSW_M1_CTRL0) == 0) //if (m1_m2 == 2)
+		return 1;
+	for (i = 0; i < 10; i++) {
+		if ((word_read(SDSW_M1_STATUS) & 0x3f3f0000) == 0x20200000)
+			break;
+	}
+	if ((word_read(SDSW_M1_STATUS) & 0x3f3f0000) != 0x20200000)
+		return 0;
+
+	while ((word_read(SDSW_M1_CTRL0) & 0x1) == 0x1) { 	//deselect m1
+		if ((word_read(SDSW_M1_STATUS) & 0x3f3f0000) != 0x20200000)
+			return 0;
+		if (time_out-- <= 0) {
+			m2_err++;
+			//printf("switch to m2 timeout\n");
+			switch_to_m1();
+			return 0;
+		}
+
+		word_write(SDSW_M1_CTRL0, 0x0);
+	}
+//tom2:
+	word_write(SDSW_M2_CTRL0, 0x1); 			//select m2
+	m1_m2 = 2;
+	return 1;
+}
+
+extern void switch_to_m1_sw(void);
+
+int do_switch_to_m1(void)
+{
+	volatile int time_out = 100000;
+	//printf("->M1\n");
+	switch_to_m1_sw();
+
+#ifdef DEBUG
+	//show_str("Switch to M1\n",0,"\n",1);
+#endif
+
+	while ((word_read(SDSW_M2_CTRL0) & 0x1) == 0x1) { 	//deselect m2
+		if (time_out-- <= 0) {
+			printf("switch to m1 timeout\n");
+			break;
+		}
+		word_write(SDSW_M2_CTRL0, 0x0);
+	}
+
+	word_write(SDSW_M1_CTRL0, 0x1); 			//select m1
+
+	time_out = 1000;
+	while ((word_read(SDSW_M2_CTRL0) & 0x1) == 0x1) { 	//deselect m2
+		if (time_out-- <= 0) {
+			printf("switch to m1 timeout\n");
+			break;
+		}
+		word_write(SDSW_M2_CTRL0, 0x0);
+	}
+
+	word_write(SDSW_M1_CTRL0, 0x1); 			//select m1
+	null_delay(100);
+
+	m1_m2 = 1;
+	return 1;
+}
+
+int switch_to_m1(void)
+{
+	volatile int time_out = 100000;
+	//printf("->M1\n");
+	if (m1_err)
+		return 0;
+//#ifndef GEN3
+	switch_to_m1_sw();
+	m1_m2 = 1;
+	return 1;
+//#endif
+#ifdef DEBUG
+	//show_str("Switch to M1\n",0,"\n",1);
+#endif
+	if ((SDSW_M2_CTRL0) == 0 && word_read(SDSW_M1_CTRL0) == 1) //if (m1_m2 == 1)
+		return 1;
+
+	while ((word_read(SDSW_M2_CTRL0) & 0x1) == 0x1) { 	//deselect m2
+		if (time_out-- <= 0) {
+			printf("switch to m1 timeout\n");
+			break;
+		}
+		word_write(SDSW_M2_CTRL0, 0x0);
+	}
+
+	word_write(SDSW_M1_CTRL0, 0x1); 			//select m1
+
+	time_out = 1000;
+	while ((word_read(SDSW_M2_CTRL0) & 0x1) == 0x1) { 	//deselect m2
+		if (time_out-- <= 0) {
+			printf("switch to m1 timeout\n");
+			break;
+		}
+		word_write(SDSW_M2_CTRL0, 0x0);
+	}
+
+	word_write(SDSW_M1_CTRL0, 0x1); 			//select m1
+	null_delay(100);
+
+	m1_m2 = 1;
+	return 1;
+}
+
+int InitCard(void)
+{
+//	int j;
+	int waitCnt=5;
+//	unsigned int reg, lastRdArg=0;
+
+#ifdef show_str_en
+	show_str("Enter InitCard().\n",0,"\n",1);
+#endif
+	word_write(SDSW_M1_CMD_FLG_REG0, 0xffffffff);     //clear all cmd flags
+	word_write(SDSW_M1_CMD_FLG_REG1, 0xffffffff);
+	word_write(SDSW_M1_CMD_FLG_REG2, 0xffffffff);
+	word_write(SDSW_M1_CMD_FLG_REG3, 0xffffffff);
+	word_write(0xa000a01c, 0x2);
+#if CONFIG_SYS_VER > 1 //#ifdef CONFIG_V34
+	word_write(SPECIAL_REG, 0x22);
+#else
+	word_write(SPECIAL_REG, 0x2);
+#endif
+	word_write(SDSW_M1_CTRL0, 0x1);
+	word_write(SDSW_M2_CTRL0, 0x0);
+
+//wait_again:
+	if(wait_m1_ready(500000)) {        //eee
+		//printf("(%d)m1 ready", waitCnt);
+		word_write(SDSW_M1_CSR_REG, word_read(SDSW_M1_CSR_REG) | 0x100);        //set Ready For Data bit
+	} else
+		printf("(%d)m1 not ready", waitCnt);
+#ifdef SIYO_READER
+	printf("(m1:%x, m2:%x, sw:%x@%x:%x, bw:%x)\n", word_read(0xa000a008), word_read(0xa000a00c), word_read(0xa0000014), word_read(0xa000a000), word_read(0xa000a004), word_read(SDSW_M1_SBW_REG));
+	for(reg = 0xa000a000; reg<=0xa000a12c; reg+=4)
+		printf("[%08x]%08x\n", reg, word_read(reg));
+#endif
+
+	/*
+	    RCA0 = word_read(0xa000a09c) & 0xff;
+	    RCA1 = (word_read(0xa000a09c) & 0xff00) >> 8;
+	    printf("RCA0 %x, RCA1 %x\n", RCA0, RCA1);
+	    word_write(0xa000a01c, 0x2);
+	#ifdef GEN3
+	    word_write(SPECIAL_REG, 0x22);
+	#else
+	    word_write(SPECIAL_REG, 0x2);
+	#endif*/
+
+	printf("Status %x\n", word_read(SDSW_M1_STATUS));
+#ifdef SIYO_READER
+	if((word_read(SDSW_M1_STATUS) != 0x20200804) && --waitCnt) {
+		printf("curr cmd:%x %x, prev cmd: %x\n", word_read(0xa000a040), word_read(0xa000a044), word_read(0xa000a030));
+		if(word_read(SDSW_M1_STATUS) == 0x20100815) {
+			if(waitCnt == 4) lastRdArg = word_read(0xa000a044);
+			else if(word_read(0xa000a044) == lastRdArg) {
+				printf("conditional continue\n");
+				m1_err = 0;
+				special_cont = 1;
+				goto cond_cont;
+			}
+		}
+		goto wait_again;
+	} else if(!waitCnt) {
+		printf("m1 still busy, m2 abort!\n");
+		goto fail;
+	}
+#endif
+
+	if (m1_err)
+		goto fail;
+	// if (m1_busy())
+	//     return;
+//cond_cont:
+	if (word_read(SDSW_M1_STATUS) != 0x20200800) {
+		/* m1 idle ready */
+		RCA0 = word_read(0xa000a09c) & 0xff;
+		RCA1 = (word_read(0xa000a09c) & 0xff00) >> 8;
+		printf("RCA0 %x, RCA1 %x\n", RCA0, RCA1);
+		word_write(0xa000a01c, 0x2);
+#if CONFIG_SYS_VER > 1 //#ifdef CONFIG_V34
+		word_write(SPECIAL_REG, 0x22);
+#else
+		word_write(SPECIAL_REG, 0x2);
+#endif
+		goto pass;
+	}
+	//switch_to_m1();
+	//WaitBusReady(0x8c);
+	/*
+	    switch_to_m2();
+	    for(j=0; j<100000; j++);
+	    if(HCmdNoData(RCA1, RCA0, 0x00, 0x00, 0x07, 0x3C, 0x11)) {
+		RCA0 = (word_read(0xa000a09c) & 0xff00) >> 8;
+		RCA1 = word_read(0xa000a09c) & 0xff;
+		if(HCmdNoData(RCA1, RCA0, 0x00, 0x00, 0x07, 0x3C, 0x11))
+	     		goto fail;
+	    }
+	    else
+	        WaitBusReady(0x8c);
+	    if(HCmdNoData(RCA1, RCA0, 0x00, 0x00, 0x0D, 0x38, 0x11))
+		goto fail;
+	    switch_to_m1();
+	*/
+#if M2_INIT_CARD //1
+	switch_to_m2();
+
+	//wait for power up
+#ifdef simulation
+	for(j=0; j<10; j++);
+#else
+	for(j=0; j<100000; j++);
+#endif
+
+	// CMD0 (GO_IDLE_STATE - reset SD memory card)
+	// [31:0]stuff bits, no resp
+	CRXferDone = 0;
+	CRCardErr = 0;
+	CRXferBDone = 0;
+	if(HCmdNoData(0x00, 0x00, 0x00, 0x00, 0x00, 0x30,0x11))
+		goto fail;
+
+	RCA0 = 0;
+	RCA1 = 0;
+
+	// CMD8 (SEND_IF_COND - send SD memory card interface condition)
+	// [31:12]reserved, [11:8]supply voltage, [7:0]check pattern, R7
+	CRXferDone = 0;
+	CRCardErr = 0;
+	CRXferBDone = 0;
+	if(HCmdNoData(0x00, 0x00, 0x01, 0xaa, 0x08, 0x38, 0x11)) {
+		// ACMD41 (SD_SEND_OP_COND - send host capacity support (HCS) info & request operating condition reg (OCR) content)
+		if(InCaIsSDVer(1,0))
+			goto fail;
+	} else {
+		// to check if card ver 2.0x -ACMD41
+		if(InCaIsSDVer(2, 0x40))
+			goto fail;
+	}
+
+	// CMD2 (ALL_SEND_CID - ask any connected card to send CID num on CMD line)
+	// [31:0]stuff bits, R2
+	CRXferDone = 0;
+	CRCardErr = 0;
+	CRXferBDone = 0;
+	if(HCmdNoData(0x00, 0x00, 0x00, 0x00, 0x02, 0x34, 0x11))
+		goto fail;
+
+	// CMD3 (SEND_RELATIVE_ADDR - ask card to publish new relative address (RCA))
+	// [31:0]stuff bits, R6
+	CRXferDone = 0;
+	CRCardErr = 0;
+	CRXferBDone = 0;
+	if(HCmdNoData(0x00, 0x00, 0x00, 0x00, 0x03, 0x38, 0x11))
+		goto fail;
+
+	RCA0 = (word_read(SDR_RESPONSE1_REG) & 0x00ff0000) >> 16;
+	RCA1 = (word_read(SDR_RESPONSE1_REG) & 0xff000000) >> 24;
+
+#ifdef show_str_en
+	show_str("RCA0 \n",RCA0,"\n",1);
+	show_str("RCA1 \n",RCA1,"\n",1);
+#endif
+	word_write(0xa000a09c, RCA0 | (RCA1 << 8));
+
+	// CMD7 (SELECT/DESELECT_CARD - toggle card btw standby/disconnect & transfer/programming state)
+	// [31:16]RCA, [15:0]stuff, R1b
+	CRXferDone = 0;
+	CRCardErr = 0;
+	CRXferBDone = 0;
+	if(HCmdNoData(RCA1, RCA0, 0x00, 0x00, 0x07, 0x3C, 0x11))
+		goto fail;
+	else
+		WaitBusReady(0x8c);
+
+#ifdef simulation
+#else
+	// CMD55
+	if(HCmdNoData(RCA1, RCA0, 0x00, 0x00, 0x37, 0x38, 0x11))
+		goto fail;
+
+	// ACMD6 (SET_BUS_WIDTH - define data bus width for data transfer)
+	// [31:2]stuff, [1:0]bus width (00=1bit, 10=4bits), R1
+	if(HCmdNoData(0x00, 0x00, 0x00, 0x02, 0x06, 0x38, 0x11))
+		goto fail;
+#endif
+
+#endif
+
+pass:
+#ifdef show_str_en
+	show_str("InitCard() Passed.\n",0,"\n",1);
+#endif
+	return 0;
+fail:
+#ifdef show_str_en
+	show_str("InitCard() Failed.\n",0,"\n",1);
+#endif
+	return 1;
+}
+
+//------------------------------------------------------------------------------
+int WaitResp(unsigned int expResp, int delay)
+{
+//	volatile unsigned int i;
+	volatile unsigned int result = 0;
+	volatile int time_out = 1000+delay;
+
+	DBG("Enter WaitResp from %d to %d\n", word_read(SDR_DMA_TRAN_RESP_REG), expResp);
+
+	while( (word_read(SDR_DMA_TRAN_RESP_REG) & expResp) != expResp ) {
+		if (time_out-- <= 0) {
+			printf("Time out - WaitResp %x got %x (%d)\n", expResp, word_read(SDR_DMA_TRAN_RESP_REG), delay);
+			break;
+		}
+		null_delay(2);
+	}
+
+	word_write(SDR_DMA_TRAN_RESP_REG, expResp);
+
+	result = word_read(SDR_STATUS_REG);
+	/* check if CRC error */
+	if (result & 0x200000) {
+		printf("\n!!!! CRC Error\n");
+	}
+
+	/* check other error */
+	if( (result & 0x4f0000)) { // skip crc error 0x200000
+		printf("WaitResp() error status:%x\n", result);
+		result = 1;
+	} else
+		result = 0;
+
+	return result;
+}
+//------------------------------------------------------------------------------
+void WaitDMAIntr(unsigned int channel)
+{
+	volatile int time_out = 1000;
+	DBG("wait dma channel %d\n", channel);
+	while((word_read(SDR_DMA_INTS_REG) & channel) == 0) { //wait DMA transfer done
+		if (time_out-- <= 0) {
+			printf("Wait dma %d got %x time out\n", channel, word_read(SDR_DMA_INTS_REG));
+			break;
+		}
+	}
+	DBG("SDR_DMA_INTS_REG %x\n", word_read(SDR_DMA_INTS_REG));
+	//word_write(SDR_DMA_INTS_REG, channel);                 	//reset DMA interrupt pin
+	word_write(SDR_DMA_INTS_REG, word_read(SDR_DMA_INTS_REG));
+}
+//------------------------------------------------------------------------------
+int WaitCardReady()
+{
+	// CMD13 (SEND_STATUS - card sends its status register)
+	// [31:16]RCA, [15:0]stuff bits, R1
+	if (HCmdNoData(RCA1, RCA0, 0x00, 0x00, 0x0D, 0x38, 0x11))
+		goto fail;
+	else
+		return ~( (word_read(SDR_RESPONSE1_REG) & 0x00000001));
+fail:
+	printf("WaitCardReady() Failed.\n");
+	return 1;
+}
+//------------------------------------------------------------------------------
+int WaitBusReady(unsigned int expStatus)
+{
+	unsigned int CR_BUS_STS;
+	volatile int time_out = 100000; //10000
+	do {
+		CR_BUS_STS = word_read(SDR_STATUS_REG);
+		if (time_out-- <= 0) {
+			printf("WaitBusReady timeout\n");
+			break;
+		}
+	} while(  ((CR_BUS_STS >> 8) & expStatus ) != expStatus);
+
+	//DBG("Exit WaitBusReady().\n");
+	return(time_out == 0);
+}
+//------------------------------------------------------------------------------
+int InCaIsSDVer(int Ver, int CCap)
+{
+//	int i;
+#ifdef simulation
+	for(i=0; i<10; i++);
+#else
+	//for(i=0; i<50000; i++);
+#endif
+	if (m1_err)
+		return 0;
+	if(Ver==1) {
+#ifdef show_str_en
+		show_str("InCaIsSDVer1x().\n", 0, "\n",1);
+#endif
+		HighCap=0;
+		OCR1=0;
+		OCR2=0;
+#ifdef simulation
+#else
+		if(ACMD41tillReady(0x00) == 1)
+			goto fail;
+#endif
+	} else {
+		/* to check if card ver 2.0x -ACMD41*/
+		/* CMD55 */
+#ifdef show_str_en
+		show_str("InCaIsSDVer2x().\n", 0, "\n",1);
+#endif
+		if(HCmdNoData(RCA1, RCA0, 0x00, 0x00, 0x37, 0x38, 0x11))
+			goto fail;
+
+		/* CMD41 */
+#ifdef show_str_en
+		show_str("Send ACMD41.\n",0,"\n",1);
+#endif
+
+#ifdef simulation
+		if(HCmdNoData(0x80, 0xff, 0x80, 0x00, 0x29, 0x38, 0x11))
+			goto fail;
+#else
+		if(HCmdNoData(CCap, 0xff, 0x80, 0x00, 0x29, 0x38, 0x11))
+			goto fail;
+#endif
+
+		OCR1 = (word_read(SDR_RESPONSE1_REG) & 0x0000ff00);
+		OCR2 = (word_read(SDR_RESPONSE1_REG) & 0x00ff0000) >> 16;
+
+#ifdef show_str_en
+		show_str("OCR1 \n",OCR1,"\n",1);
+		show_str("OCR2 \n",OCR2,"\n",1);
+#endif
+
+#ifdef simulation
+#else
+		if(ACMD41tillReady(0x40) == 1)
+			goto fail;
+#endif
+	}
+
+//pass:
+	return 0;
+fail:
+#ifdef show_str_en
+	show_str("InCaIsSDVer() Fail.",0,"\n",1);
+#endif
+	return 1;
+}
+
+//------------------------------------------------------------------------------
+int ACMD41tillReady(int CCap)
+{
+	int retry = 100;
+	if (m1_err)
+		return 0;
+	while(1) {
+		/* ACMD commands are preceded by CMD55 (APP_CMD) */
+		// [31:16]RCA, [15:0]stuff bits, R1 (0x40 = HC)
+		if(HCmdNoData(RCA1, RCA0, 0x00, 0x00, 0x37, 0x38, 0x11))
+			goto fail;
+
+		// ACMD41 (SD_SEND_OP_COND - send host capacity support (HCS) info & request operating condition reg (OCR) content)
+		// [31]reserved, [30]HCS(OCR[30]), [29:24]reserved, [23:0]Vdd voltage window(OCR[23:0]), R3
+		if(HCmdNoData(CCap, OCR2, OCR1, 0x00, 0x29, 0x38, 0x11)) {
+			if (retry-- > 0)
+				continue;
+			else
+				goto fail;
+		}
+
+
+		HighCap = word_read(SDR_RESPONSE1_REG);
+#ifdef show_str_en
+		show_str("HighCap \n",HighCap,"\n",1);
+#endif
+		if( (HighCap & 0x80000000) == 0x80000000)  //To check RSP3 7th bit == 1
+			goto pass;
+	}
+pass:
+	return 0;
+fail:
+#ifdef show_str_en
+	show_str("ACMD41tillReady() Fail.",0,"\n",1);
+#endif
+	return 1;
+}
+
+int HCmdNoData(unsigned int CMD_ARG3,unsigned int CMD_ARG2, unsigned int CMD_ARG1, unsigned int CMD_ARG0, unsigned int CMD, unsigned int CTRL, unsigned int reader_set)
+{
+	unsigned int flag=0;
+	unsigned int CMD_ARG;
+
+	CRCardErr = 0;
+	CRCmdDone = 0;
+	CRXferDone = 0;
+	CRXferBDone = 0;
+	CRXferFinish = 0;
+
+	//if (m1_busy())
+	//    goto  fail;
+	if (m1_err)
+		return 0;
+	word_write(SDR_DMA_TRAN_RESP_REG, word_read(SDR_DMA_TRAN_RESP_REG));
+
+	//cmd arguments
+	CMD_ARG = (CMD_ARG3 << 24) |  (CMD_ARG2 << 16) | (CMD_ARG1 << 8) | CMD_ARG0;
+	word_write(SDR_CMD_ARGUMENT_REG, CMD_ARG);
+
+	// when write CTRL_REG, SD will ready to send out cmd
+	flag = flag | (CTRL << 8) | (CMD << 16) | reader_set | EN_INTR;   //bit 0-0x01: card bus width : 4 bit;
+	word_write(SDR_CTRL_REG, flag);
+	//printf("hcmd: a%x f%x\n", CMD_ARG, flag);
+
+#ifdef show_str_en
+	show_str("Sent CMD, wait Done: \n", CMD,"\n",1);
+#endif
+
+	//Polling
+	if(WaitResp(SD_CMD_DONE, 30)) {
+		if (CMD == 8) {
+			word_write(SDSW_SW_CTRL0, 1<<2);
+			printf("a000a00c %08x\n", word_read(0xa000a00c));
+			goto fail;
+		} else
+			goto fail;
+	} else if((CTRL & 0xC) == 0)		//bit[11:10], 00=no response
+		goto pass;
+
+	//Read response if command is expecting response
+#ifdef show_str_en
+	RSP1 = word_read(SDR_RESPONSE1_REG);
+	show_str("RESP1 \n", RSP1, "\n",1);
+#endif
+
+//ISR
+//    while(CRCmdDone == 0){
+//          if( (CRCardErr & 0x01) == 0x01)
+//             {
+//                  //show_str("CRCardErr.\n",0,"\n",1);
+//                  goto fail;
+//             }
+//    }
+
+pass:
+#ifdef show_str_en
+	show_str("Send CMD Passed! CMD: \n",CMD,"\n",1);
+#endif
+	if((CMD==6) && (CMD_ARG==2))
+		word_write(0xa000a0c8, 0x2);
+	return 0;
+fail:
+#ifdef show_str_en
+	show_str("Send CMD Failed! CMD: \n",CMD,"\n",1);
+	RSP1 =  word_read(SDR_STATUS_REG);
+	show_str("Status: \n",RSP1,"\n",1);
+#endif
+	return 1;
+}
+
+#if 0
+void show_str(char *start,unsigned int input,char *end,int end_len)
+{
+#if 0
+
+	int i;
+	unsigned int temp, flag;
+
+	for(i=0; ; i++) {
+		if(start[i]=='\n')
+			break;
+		sim_uart_tx(start[i]);
+	}
+
+	for(i=7; i>=0; i--) {
+		temp=0xf0000000 >> ((7-i)*4);
+		flag = (input & temp) >> (4*i);
+
+		if(flag > 0x09)
+			sim_uart_tx( (0x37 + flag));
+		else
+			sim_uart_tx(0x30 + flag);
+	}
+
+	for(i=0; i<end_len; i++)
+		sim_uart_tx(end[i]);
+#endif
+}
+#endif
+
+void sim_uart_tx(char out)
+{
+	/* Send message */
+	while((byte_read(UART_LINE) & 0x20) != 0x20) {}; //check LSR bit5
+	byte_write(UART_RECV ,out);
+}
+
+int CardWrite_cmd(unsigned int blk_no, int blk_order)
+{
+	unsigned int LBA0, LBA1, LBA2;
+	if (m1_err)
+		return 0;
+#ifdef show_str_en
+	show_str("Enter CardWrite_single().\n",0,"\n",1);
+#endif
+
+	//CMD24 (WRITE_BLOCK)
+#ifdef show_str_en
+	show_str("Send Write Block CMD.\n",0,"\n",1);
+#endif
+	CRXferDone = 0;
+	CRCardErr = 0;
+	CRXferBDone = 0;
+	CRXferFinish = 0;
+
+	if (m1_busy())
+		goto fail;
+
+	word_write(SDR_Card_BLOCK_SET_REG,(0x00000100|BLK_CNT));
+	//HCmdData(0x01,0x00, 0x01, 0x01);  //blk_size, blk_Len_LowB, blk_Len_HighB,blk_num(1),sector;
+
+#ifdef simulation
+	LBA0 = (( blk_no * 512) & 0x000000ff);
+	LBA1 = (( blk_no * 512) & 0x0000ff00) >> 8;
+	LBA2 = (( blk_no * 512) & 0x00ff0000) >> 16;
+#else
+	LBA0 = (( blk_no) & 0x000000ff);
+	LBA1 = (( blk_no) & 0x0000ff00) >> 8;
+	LBA2 = (( blk_no) & 0x00ff0000) >> 16;
+#endif
+
+	// CMD24 (WRITE BLOCK - write the (blk_flag-1)th blk)
+	// [31:0]data addr, R1
+	if(HCmdNoData(0x00, LBA2, LBA1, LBA0, 0x18, 0x78,0x11))
+		goto fail;
+
+	//wait sd card transfer done
+	if(WaitResp(SD_XFER_DONE, 0))
+		goto fail;
+
+#ifdef show_str_en
+	show_str("WRITE data to BLK \n", blk_order,"\n",1);
+#endif
+
+//pass:
+	return 0;
+fail:
+#ifdef show_str_en
+	show_str("CardWrite_single() Fail.\n",0,"\n",1);
+#endif
+	return 1;
+}
+int CardWrite_single_pin(unsigned int blk_no, int blk_num, unsigned char *buffer)
+{
+	unsigned int i;
+//	unsigned int j, k, data;
+//	unsigned char m;
+	int blk_flag=0;
+//	int blkWritten = 0;
+	unsigned int LBA0, LBA1, LBA2,DMA_ADDR_start;
+
+	if (m1_err)
+		return 0;
+	if (switch_to_m2() == 0)
+		goto fail;
+#ifdef show_str_en
+	show_str("Enter CardWrite().\n",0,"\n",1);
+#endif
+	memcpy((void *)DMA_WADDR, buffer, 512 * blk_num);
+
+	for(i = 0; i<blk_num ; i++) {
+		//Wait SD card turn to transfer state (0xc: wait SD card exist, DAT[0] free)
+		WaitBusReady(0x0c);
+		blk_flag = blk_no + i;
+
+		//Transfer data to FIFO
+		DMA_ADDR_start = DMA_WADDR + (512 * i);
+		word_write(SDR_DMA_SACH0_REG, DMA_ADDR_start);		//set DMA Ch0 source addr
+		//for(k=0, m=0; (k<(512*BLK_CNT)); k+=4, m=k) 			//write ascending numbers to memory
+		//{
+		//     data = ((m+3) << 24) | ((m+2) << 16) | ((m+1) << 8) | m;
+		//     word_write( DMA_ADDR_start+k, data);
+		//}
+		word_write(SDR_DMA_CTRCH0_REG,0x3F); 			//set DMA Ch0 control to start DMA
+		word_write(SDR_DMA_CTRCH0_REG,0x33); 			//reset DMA Ch0 control
+		word_write(SDR_BUF_TRAN_CTRL_REG, (BUF_BLK_CNT | BUF_WRITE | BUF_XFER_START));  //set FIFO control & start transfer
+		WaitDMAIntr(DMA_CH0_INTR);					//wait for data move to memory
+
+#ifdef SINGLE_BLOCK
+		if(i>0) {
+#else
+		if(WaitResp(FIFO_XFER_DONE, 0))  			//wait for data move to FIFO
+			goto fail;
+		blk_flag = blk_no + 1;
+#endif
+			//Transfer data to SD card
+			CRXferDone = 0;
+			CRCardErr = 0;
+			CRXferBDone = 0;
+			CRXferFinish = 0;
+#ifdef simulation
+			LBA0 = (( (blk_flag-1) * 512) & 0x000000ff);
+			LBA1 = (( (blk_flag-1) * 512) & 0x0000ff00) >> 8;
+			LBA2 = (( (blk_flag-1) * 512) & 0x00ff0000) >> 16;
+#else
+			LBA0 = (( blk_flag-1) & 0x000000ff);
+			LBA1 = (( blk_flag-1) & 0x0000ff00) >> 8;
+			LBA2 = (( blk_flag-1) & 0x00ff0000) >> 16;
+#endif
+			word_write(SDR_Card_BLOCK_SET_REG,(0x00000100|BLK_CNT));
+#ifdef show_str_en
+			show_str("Send Write Block CMD. Blk:\n",blk_flag,"\n",1);
+#endif
+
+#ifdef SINGLE_BLOCK
+			// CMD24 (WRITE BLOCK - write the (blk_flag-1)th blk)
+			// [31:0]data addr, R1
+			if(HCmdNoData(0x00, LBA2, LBA1, LBA0, 0x18, 0x78,0x11))
+				goto fail;
+#else
+			// CMD25 (WRITE MULTIPLE BLOCK - write the (blk_flag-1)th blk until interrupted by CMD12)
+			// [31:0]data addr, R1
+			if(HCmdNoData(0x00, LBA2, LBA1, LBA0, 0x19, 0x7A,0x11))
+				goto fail;
+#endif
+			//wait sd card transfer done and fifo transfer finish
+#ifdef SINGLE_BLOCK
+			if(WaitResp(FIFO_XFER_DONE|SD_XFER_DONE, 0))		//wait data write to FIFO & SD card done
+				goto fail;
+#else
+			if(WaitResp(FIFO_XFER_DONE, 0))   			//(eee:still needed?)
+				goto fail;
+			for(i=0; (i<(BLK_CNT-1)); i++) {
+				if(WaitResp(SD_DATA_BOUND, 0))			//current block write to SD card
+					goto fail;
+				word_write(SDR_ADDRESS_REG, 0x1);			//continue write next block
+			}
+			if(WaitResp(SD_XFER_DONE, 0))				//all blocks transferred to SD card
+				goto fail;
+			if(WaitResp(SD_CMD_DONE, 0))				//for CMD12 (STOP_TRANSMISSION)
+				goto fail;
+			WaitBusReady(0x0c);					//wait SD card exist and not busy
+
+			// confirm write was successful
+			// CMD55
+			if(HCmdNoData(RCA1, RCA0, 0x00, 0x00, 0x37, 0x38, 0x11))
+				goto fail;
+
+			// ACMD22 (SEND_NUM_WR_BLOCKS - send num of written (no error) blocks. Responds with 32bit+CRC data blocks)
+			// [31:0]stuff bits
+			word_write(SDR_Card_BLOCK_SET_REG, 0x00040001);    	 //1 block, 4 bytes data transfer
+			word_write(SDR_Error_Enable_REG, 0x6f);                  //enable all errors
+			if(HCmdNoData(0x00, 0x00, 0x00, 0x00, 0x16, 0x79, 0x11))
+				goto fail;
+			if(WaitResp(SD_XFER_DONE, 0))				 //wait SD data transfer done
+				goto fail;
+
+			//transfer data to FIFO
+			word_write(SDR_DMA_TCCH1_REG, 0x4);
+			word_write(SDR_DMA_DACH1_REG, DMA_RADDR);
+			word_write(SDR_DMA_CTRCH1_REG, 0x3F);
+			word_write(SDR_DMA_CTRCH1_REG, 0x33);
+			word_write(SDR_BUF_TRAN_CTRL_REG, 0x00010000 | BUF_XFER_START);
+			if(WaitResp(FIFO_XFER_DONE, 0))				//data moved to FIFO
+				goto fail;
+
+			//read returned data & compare with expected block count
+			data = word_read(DMA_RADDR);
+			blkWritten = ((data & 0xff000000)>>24) | ((data & 0xff0000)>>8) | ((data & 0xff00)<<8) | ((data & 0xff)<<24);
+			if(blkWritten != BLK_CNT) {
+#ifdef show_str_en
+				show_str("Block written NOT as expected.\n", blkWritten,"\n",1);
+#endif
+				goto fail;
+			} else
+#ifdef show_str_en
+				show_str("Block Written: \n", blkWritten,"\n",1);
+#endif
+
+#ifdef simulation
+			// CMD7 (SELECT/DESELECT_CARD - toggle card btw standby/disconnect & transfer/programming state)
+			// [31:16]RCA, [15:0]stuff, R1b
+			CRXferDone = 0;
+			CRCardErr = 0;
+			CRXferBDone = 0;
+			if(HCmdNoData(0x12, 0x34, 0x00, 0x00, 0x07, 0x3C, 0x11))
+				goto fail;     		//else WaitBusReady();
+#endif
+			goto pass;
+#endif
+
+#ifdef SINGLE_BLOCK
+		} else if(i==0) { //Wait for DMA to complete block 0 transfer
+#ifdef show_str_en
+			show_str("Write data to BLK \n", i,"\n",1);
+#endif
+			if(WaitResp(FIFO_XFER_DONE, 0))		//wait for data move to FIFO
+				goto fail;
+		}
+#endif
+	}
+
+#ifdef SINGLE_BLOCK
+	if( (i-1) == (blk_num-1))
+	{
+		//clear flags & write last block to SD
+		word_write(SDR_DMA_TRAN_RESP_REG, (FIFO_XFER_DONE|SD_XFER_DONE));
+		CardWrite_cmd(blk_flag, (i-1));
+	}
+#endif
+
+//pass:
+	//clear transfer done and finish flags
+	word_write(SDR_DMA_TRAN_RESP_REG,(FIFO_XFER_DONE|SD_XFER_DONE));
+#ifdef show_str_en
+	show_str("CardWrite() Pass.\n",0,"\n",1);
+#endif
+	switch_to_m1();
+
+	return 0;
+fail:
+#ifdef show_str_en
+	show_str("CardWrite() Fail.\n",0,"\n",1);
+#endif
+	switch_to_m1();
+	return 1;
+}
+
+
+int SendWriteCmd(unsigned int cmdarg, int single)
+{
+	DBG("Enter SendWriteCmd(). BLK%d\n", cmdarg);
+	if (m1_err)
+		return 0;
+	//Transfer data to SD card
+	if(single) {
+		// CMD24 (WRITE BLOCK - write the (cur_blk-1)th blk)
+		// [31:0]data addr, R1
+		if(HCmdNoData(((cmdarg>>24)&0xff), ((cmdarg>>16)&0xff), ((cmdarg>>8)&0xff), (cmdarg&0xff), 0x18, 0x78, 0x11))
+			goto fail;
+	} else { //Multi Block
+		// CMD25 (WRITE MULTIPLE BLOCK - write all blocks until interrupted by CMD12)
+		// [31:0]data addr, R1
+		//if(HCmdNoData(cmdarg, 0x19, 0x7A, 0x11))
+		if(HCmdNoData(((cmdarg>>24)&0xff), ((cmdarg>>16)&0xff), ((cmdarg>>8)&0xff), (cmdarg&0xff), 0x19, 0x7A, 0x11))
+			goto fail;
+	}
+
+	return 0;
+fail:
+	DBG("SendWriteCmd(Blk %d) Failed!\n", cmdarg);
+	return 1;
+}
+
+
+int SDCardWrite(unsigned int buf_src_addr, unsigned int cmd_arg, int blk_num, int single)
+{
+	unsigned int i;
+//	unsigned int data;
+	int cur_blk=0;
+//	int blkWritten=0;
+	unsigned int DMA_ADDR_start;
+//	unsigned int cmdarg=0;
+	//unsigned int *pBuf=NULL;
+	if (m1_err)
+		return 0;
+	//if (m1_busy())
+	//    goto fail;
+
+	//DBG("Write(s%d) %d blk from %x to %x\n", single, blk_num, buf_src_addr, cmd_arg);
+	printf("w.%s %d %d\n", (single?"s":"m"), cmd_arg, blk_num);
+	word_write(SDR_BUF_TRAN_CTRL_REG, 0);   //clear buffer transfer start bit
+
+	if(!single) { /* Multi Block Write */
+		if (switch_to_m2() == 0)
+			goto fail;
+		if(WaitBusReady(0x0c))	//0xc=SD card exist, DAT0 free
+			goto fail;
+		//Init FIFO
+		word_write(SDR_DMA_TCCH0_REG, (512 * blk_num));  		//Transfer Count
+		word_write(SDR_DMA_SACH0_REG, buf_src_addr);			//Start Addr, DMA_WADDR
+
+		//Transfer write data to FIFO
+		//for(i = 0; i < blk_num ; i++) read_512_buffer(buf_src_addr + (512 * i), DMA_WADDR + (512 * i));
+		word_write(SDR_DMA_CTRCH0_REG,0x3F); 			//set DMA CH0 control to start DMA
+		word_write(SDR_DMA_CTRCH0_REG,0x33); 			//reset DMA CH0 control
+		word_write(SDR_BUF_TRAN_CTRL_REG, ((blk_num << 16) | BUF_WRITE | BUF_XFER_START));
+		//WaitDMAIntr(DMA_CH0_INTR);					//wait for data move to memory
+		if(WaitResp(FIFO_XFER_DONE, 0)) 				//Wait until data moved to FIFO
+			goto fail;
+		word_write(SDR_Card_BLOCK_SET_REG,(0x00000100|blk_num));
+		SendWriteCmd(cmd_arg, single);
+
+		for(i=0; (i<(blk_num-1)); i++) {
+			if(WaitResp(SD_DATA_BOUND, 100))				//current block written to SD card
+				goto fail;
+			word_write(SDR_SPECIAL_CTRL_REG, 0x1);			//continue write next block
+		}
+		if(WaitResp(SD_XFER_DONE, 100))				//all blocks transferred to SD card
+			goto fail;
+		if(WaitResp(SD_CMD_DONE, 1000))					//for CMD12 (STOP_TRANSMISSION)
+			goto fail;
+		WaitBusReady(0x0c);
+		switch_to_m1();
+
+#if 0
+		//confirm write was successful with ACMD22
+		cmdarg = (RCA1 << 24) | (RCA0 << 16) | 0x0;
+		if(HCmdNoData(cmdarg, 0x37, 0x38, 0x11))	//CMD55
+			goto fail;
+		// ACMD22 (SEND_NUM_WR_BLOCKS - send num of written (no error) blocks. Responds with 32bit+CRC data blocks)
+		// [31:0]stuff bits
+		word_write(SDR_Card_BLOCK_SET_REG, 0x00040001);    	 	//1 block, 4 bytes data transfer
+		word_write(SDR_Error_Enable_REG, 0x6f);                  	//enable all errors
+		if(HCmdNoData(0x00, 0x16, 0x79, 0x11))
+			goto fail;
+		if(WaitResp(SD_XFER_DONE, 50))
+			goto fail;
+		pBuf = (unsigned int *)kmalloc(128, GFP_KERNEL);
+		word_write(SDR_DMA_TCCH1_REG, 0x4);
+		word_write(SDR_DMA_DACH1_REG, (unsigned int)pBuf);	//DMA_RADDR
+		word_write(SDR_DMA_CTRCH1_REG, 0x3F);
+		word_write(SDR_DMA_CTRCH1_REG, 0x33);
+		word_write(SDR_BUF_TRAN_CTRL_REG, 0x00010000 | BUF_XFER_START);
+		if(WaitResp(FIFO_XFER_DONE, 0))
+			goto fail;
+		data = *pBuf;
+		blkWritten = ((data & 0xff000000)>>24) | ((data & 0xff0000)>>8) | ((data & 0xff00)<<8) | ((data & 0xff)<<24);
+		if(blkWritten != blk_num) {
+			DBG("Block written NOT as expected. Exp: %d, Actual: %d.\n", blk_num, blkWritten);
+			goto fail;
+		}
+#endif
+		goto pass;
+	}
+
+	/* Single block Write */
+	for(i = 0; i < blk_num ; i++) {
+		if (switch_to_m2() == 0)
+			goto fail;
+		if(WaitBusReady(0x0c))					//0xC=SD card exist, DAT0 free
+			goto fail;
+		//Init FIFO
+		cur_blk = cmd_arg + i; //1124-2:16a
+		word_write(SDR_DMA_TCCH0_REG, 512);  			//Transfer Count
+		DMA_ADDR_start = buf_src_addr + (512 * i);		//DMA_WADDR
+		word_write(SDR_DMA_SACH0_REG, DMA_ADDR_start);		//Start Addr
+
+		//Transfer write data to FIFO
+		//read_512_buffer(buf_src_addr + (512 * i), DMA_ADDR_start);
+		//word_write(SDR_Card_BLOCK_SET_REG,(0x00000100|0x1));
+		word_write(SDR_DMA_CTRCH0_REG,0x3F); 			//set DMA CH0 control to start DMA
+		word_write(SDR_DMA_CTRCH0_REG,0x33); 			//reset DMA CH0 control
+		word_write(SDR_BUF_TRAN_CTRL_REG, ((0x1 << 16) | BUF_WRITE | BUF_XFER_START));
+		null_delay(10);
+
+		WaitDMAIntr(DMA_CH0_INTR);					//wait for data move to memory
+		word_write(SDR_Card_BLOCK_SET_REG,(0x00000100|0x1));
+		if(i > 0) {
+			SendWriteCmd(cur_blk, 1);
+			if(WaitResp(FIFO_XFER_DONE|SD_XFER_DONE, 100)) {
+				DBG("wait fifo_xfer_done and sd_xfer_done error \n");
+				goto fail;
+			}
+		} else if(i==0) {
+			if(WaitResp(FIFO_XFER_DONE, 0)) {			//Wait for DMA to complete block 0 transfer
+				DBG("wait FIFO_XFER_DONE error\n");
+				goto fail;
+			}
+		}
+		switch_to_m1();
+
+	} //single block for loop
+
+	//Transfer last/only block of write data to SD Card
+	if(i == blk_num) {
+		if (switch_to_m2() == 0)
+			goto fail;
+		word_write(SDR_Card_BLOCK_SET_REG,(0x00000100|0x1));
+		SendWriteCmd(cur_blk, 1);
+		if(WaitResp(SD_XFER_DONE, 100)) {
+			DBG("end blk write error \n");
+			goto fail;
+		}
+		switch_to_m1();
+	}
+
+pass:
+	word_write(SDR_DMA_TRAN_RESP_REG,(FIFO_XFER_DONE|SD_XFER_DONE));
+	word_write(SDR_DMA_INTS_REG, word_read(SDR_DMA_INTS_REG));
+	DBG("SDCardWrite() Passed.\n");
+	return 0;
+fail:
+	DBG("SDCardWrite() Failed!\n");
+	DBG("Write(s%d) %d blk from %x to %x\n", single, blk_num, buf_src_addr, cmd_arg);
+	word_write(SDR_DMA_TRAN_RESP_REG,(FIFO_XFER_DONE|SD_XFER_DONE));
+	word_write(SDR_DMA_INTS_REG, word_read(SDR_DMA_INTS_REG));
+	return 1;
+}
+#if 0
+int ReadDma(unsigned int blk_no, unsigned int blk_cnt, unsigned int startAddr)
+{
+	int DMA_RADDR_start;
+	if (m1_err)
+		return 0;
+	//start FIFO & DMA transfer
+	DMA_RADDR_start = startAddr + (512 * blk_no);	//compute FIFO addr
+	word_write(SDR_DMA_TCCH1_REG, (512 * blk_cnt));
+	word_write(SDR_DMA_DACH1_REG, DMA_RADDR_start);
+
+	word_write(SDR_DMA_CTRCH1_REG,0x3F);
+	word_write(SDR_DMA_CTRCH1_REG,0x33);
+	word_write(SDR_BUF_TRAN_CTRL_REG, ((blk_cnt << 16) | BUF_XFER_START));
+
+	return 0;
+}
+#else
+int ReadDma(unsigned int blk_no, unsigned int blk_cnt, unsigned int startAddr)
+{
+	int DMA_RADDR_start;
+	if (m1_err)
+		return 0;
+
+
+	//start FIFO & DMA transfer
+	DMA_RADDR_start = startAddr + (512 * blk_no);	//compute FIFO addr
+	word_write(SDR_DMA_TCCH1_REG, (512 * blk_cnt));
+	word_write(SDR_DMA_DACH1_REG, DMA_RADDR_start);
+
+	/* only enable XFER whether single block or not the last block */
+	if (blk_no < blk_cnt || blk_cnt == 1) {
+		word_write(SDR_BUF_TRAN_CTRL_REG, ((blk_cnt << 16) | BUF_XFER_START));
+		null_delay(1);
+	}
+
+	word_write(SDR_DMA_CTRCH1_REG,0x3F);
+	word_write(SDR_DMA_CTRCH1_REG,0x33);
+
+	return 0;
+}
+#endif
+
+int SDCardRead(unsigned int buf_dest_addr, unsigned int cmd_arg, int blk_num, int single)
+{
+	unsigned int i, k;
+	int cur_blk=0;
+	if (m1_err)
+		return 0;
+	//DBG("Read(s%d) %d blk from blk %x to addr %x\n", single, blk_num, cmd_arg, buf_dest_addr);
+	//if (m1_busy())    //0401
+	//    goto fail;
+	//printf("r.%s %d %d\n", (single?"s":"m"), cmd_arg, blk_num);
+	printf(".");
+	if (switch_to_m2() == 0)      //0401
+		goto fail;
+
+	for(i=0; i<blk_num; i++) {
+		if(WaitBusReady(0x0c))
+			goto fail;
+		cur_blk = cmd_arg + i;
+
+		//Prepare to send SD command
+		if(single)
+			word_write(SDR_Card_BLOCK_SET_REG,(0x00000100|0x1));
+		else
+			word_write(SDR_Card_BLOCK_SET_REG,(0x00000100|blk_num));
+
+		word_write(SDR_DMA_TRAN_RESP_REG, 0x1f); //clear all flags
+		word_write(SDR_DMA_INTS_REG, 0x3);						 //clear interrupts
+
+#ifdef SIYO_READER
+		if(special_cont && (word_read(SDSW_M1_STATUS) == 0x20100815)) {
+			//send cmd12
+			if(HCmdNoData(0, 0, 0, 0, 12, 0x3c, 0x11))
+				goto fail;
+			if(WaitResp(SD_CMD_DONE, 100))  				//for CMD12(STOP_TRANMISSION)
+				//goto fail;
+				printf("cmd12 failed\n");
+			special_cont = 0;
+		}
+#endif
+
+		if(single) {
+			// CMD17 (READ_SINGLE_BLOCK)
+			// [31:0]data addr, R1
+			if(HCmdNoData(((cur_blk>>24)&0xff), ((cur_blk>>16)&0xff), ((cur_blk>>8)&0xff), (cur_blk&0xff), 0x11, 0x79, 0x11))
+				goto fail;
+
+			if(WaitResp(SD_XFER_DONE, 1000))			//first block of data read from SD card
+				goto fail;
+
+			ReadDma(i, 0x1, buf_dest_addr);					//start DMA to store read data
+			//if(WaitResp(FIFO_XFER_DONE|SD_XFER_DONE, 1000))
+			//    goto fail;
+			WaitDMAIntr(DMA_CH1_INTR);				//data moved to memory
+		} else { //Multi Block
+			// CMD18 (READ_MULTIPLE_BLOCK) - continuously transfer data blocks from card to host until STOP_TRANSMISSION cmd
+			// [31:0]data addr, R1
+			//DBG("multi blk read blk_no %x total blk_num %x\n", cmd_arg, blk_num);
+			if(HCmdNoData(((cmd_arg>>24)&0xff), ((cmd_arg>>16)&0xff), ((cmd_arg>>8)&0xff), (cmd_arg&0xff), 0x12, 0x7B, 0x11))
+				goto fail;
+			null_delay(100);
+
+
+			for(k=0; k<blk_num-1; k++) {
+				if(WaitResp(SD_DATA_BOUND, 1000))				//first block of data read from SD card (500)
+					goto fail;
+
+				word_write(SDR_SPECIAL_CTRL_REG, 0x1);		//continue read next block from SD card
+
+				ReadDma(k, 1, buf_dest_addr);	//start DMA to store read data
+
+				if(WaitResp(FIFO_XFER_DONE, 100))			//data moved to FIFO
+					goto fail;
+
+				WaitDMAIntr(2);			//DMA transfer for all data completed
+			}
+
+			if(WaitResp(SD_XFER_DONE, 100))				//last data read from SD card
+				goto fail;
+
+			if(WaitResp(SD_CMD_DONE, 100))  				//for CMD12(STOP_TRANMISSION)
+				goto fail;
+
+			//if(WaitResp(FIFO_XFER_DONE, 100))				//last block of data moved to FIFO
+			//    goto fail;
+
+			//WaitDMAIntr(DMA_CH1_INTR);			//DMA transfer for all data completed
+			//switch_to_m1();
+
+			//if (switch_to_m2() == 0)      //0401
+			//    goto fail;
+			ReadDma(k, 0x1, buf_dest_addr);
+
+			//if(WaitResp(FIFO_XFER_DONE, 100))                     		//last block of data moved to FIFO
+			//    goto fail;
+
+			WaitDMAIntr(2);                          		//last block of data moved to DMA
+			//switch_to_m1();
+
+			goto strdata;
+		}
+
+	} //for loop
+
+strdata:
+	switch_to_m1(); //0401
+	//write all read data to destination buffer
+	//for (j = 0; j < blk_num; j++) write_512_buffer(buf_dest_addr + (512*(j)), DMA_RADDR + (512*(j)));
+	word_write(SDR_DMA_TRAN_RESP_REG,(FIFO_XFER_DONE|SD_XFER_DONE));
+	word_write(SDR_DMA_INTS_REG, word_read(SDR_DMA_INTS_REG));
+	return 0;
+fail:
+	switch_to_m1();
+	printf("SDCardRead() Failed!\n");
+	printf("Read(s%d) %d blk from blk %x to addr %x\n", single, blk_num, cmd_arg, buf_dest_addr);
+	word_write(SDR_DMA_TRAN_RESP_REG,(FIFO_XFER_DONE|SD_XFER_DONE));
+	word_write(SDR_DMA_INTS_REG, word_read(SDR_DMA_INTS_REG));
+	return 1;
+}
diff --git a/arch/arm/cpu/arm926ejs/keyasic/sdctrl.h b/arch/arm/cpu/arm926ejs/keyasic/sdctrl.h
new file mode 100644
index 0000000..b39ca2d
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/keyasic/sdctrl.h
@@ -0,0 +1,30 @@
+
+void InitCardReader(void);
+int CardRead_single_pin(unsigned int buf_dest_addr, unsigned int blk_no,int blk_num );
+int CardRead_dma(unsigned int buf_dest_addr, unsigned int blk_no, int blk_order);
+int CardErase_single(unsigned int blk_no);
+void data_compare(int blk_order);
+void write_512_buffer(unsigned int dest_addr, unsigned int DMA_RADDR_start);
+int InitCard(void);
+int WaitCardReady(void);
+int WaitBusReady(unsigned int expStatus);
+int InCaIsSDVer(int Ver, int CCap);
+int ACMD41tillReady(int CCap);
+int HCmdNoData(unsigned int CMD_ARG3,unsigned int CMD_ARG2, unsigned int CMD_ARG1,unsigned  int CMD_ARG0, unsigned int CMD, unsigned int CTRL, unsigned int reader_set);
+int WaitResp(unsigned int expResp, int delay);
+void WaitDMAIntr(unsigned int channel);
+
+int switch_to_m2(void);
+int switch_to_m1(void);
+
+void show_str(char *start,unsigned int input,char *end, int end_len);
+void sim_uart_tx(char tmp);
+
+int CardWrite_single_pin(unsigned int blk_no, int blk_num, unsigned char *buffer);
+int CardWrite_cmd(unsigned int blk_no, int blk_order);
+
+int SendWriteCmd(unsigned int cmdarg, int single);
+int SDCardWrite(unsigned int buf_src_addr, unsigned int cmd_arg, int blk_num, int single);
+int ReadDma(unsigned int blk_no, unsigned int blk_cnt, unsigned int startAddr);
+int SDCardRead(unsigned int buf_dest_addr, unsigned int cmd_arg, int blk_num, int single);
+
diff --git a/arch/arm/cpu/arm926ejs/keyasic/sdswitch.c b/arch/arm/cpu/arm926ejs/keyasic/sdswitch.c
new file mode 100644
index 0000000..e7a3a0b
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/keyasic/sdswitch.c
@@ -0,0 +1,919 @@
+#include <config.h>
+#include <common.h>
+#include <mmc.h>
+#include <asm/errno.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/reg_defs.h>
+#include "sdswitch.h"
+
+#define KCARD_BUSY_TIME 100
+/*#ifdef CONFIG_SYS_RESISTOR
+#define CFG_BOARD_RESISTOR
+#endif*/
+
+//#define GEN3
+#define V	          printf("%d\n", __LINE__)
+#define DEBUG
+#ifdef DEBUG
+#define DBG(fmt, args...) printf("SW: %s(): " fmt, __FUNCTION__, ## args)
+#define T(v)	          printf("%s-%d: 0x%x\n", __FUNCTION__, __LINE__, v)
+#else
+#define DBG(fmt, args...)
+#endif
+
+#define SDSW_CLOCK_EN           (1 << 17)
+#define COMMANDS_TIMEOUT        1000000 //10000 //
+#define SWITCH_DELAY            1000000 //20000 //3000000
+
+extern volatile int RCA0, RCA1;
+#ifdef CONFIG_SYS_RESISTOR //CFG_BOARD_RESISTOR
+static void enter_switch_mode(void);
+#endif // CONFIG_SYS_RESISTOR
+//extern int  HCmdNoData(unsigned int CMD_ARG, unsigned int CMD, unsigned int CTRL, unsigned int reader_set);
+extern int HCmdNoData(unsigned int CMD_ARG3,unsigned int CMD_ARG2, unsigned int CMD_ARG1, unsigned int CMD_ARG0, unsigned int CMD, unsigned int CTRL, unsigned int reader_set);
+extern int WaitResp(unsigned int expResp, int delay); //int  WaitResp(int line, unsigned int expResp, int delay);
+extern void WaitDMAIntr(unsigned int channel);
+extern int do_switch_to_m1(void);
+static int M2_send_cmd7(int loop);
+
+/*volatile*/
+int usage_flag = 1;
+/*volatile*/
+unsigned int CardInfo_width = 0;       //0:1bit  2:4bit       //TBU:eee
+/*volatile*/
+unsigned int M1_status = 0;
+/*volatile*/
+unsigned int M2_status = 0;
+/*volatile*/
+unsigned int current_m1_cmd;
+/*volatile*/
+unsigned int M1_RCA = 0;
+/*volatile*/
+unsigned int M1_want_use_flag = 0;     //From ISR or set by Switch driver when M1 send special cmd, reset after M1_request_flag set
+/*volatile*/
+unsigned int new_cmd_flag = 0;         //From ISR or set by Switch driver when M1 send new cmd, reset after cmd is processed //eee
+/*volatile*/
+unsigned int special = 0;
+static int kcard_busy = KCARD_BUSY_TIME;
+
+#define sflags0 (CMD24 | CMD25 | CMD17 | CMD18 | CMD7 | CMD6 | CMD0)
+#define sflags1 (CMD38 | CMD42 | CMD56)
+
+int bomb_alarmed = 0;
+
+/*static*/
+void dump_buffer(unsigned char *buf, int count)
+{
+	int i;
+	printf("--------------------------------------------------------\n");
+	for (i = 0; i < count; i++) {
+		printf("%02X ", buf[i]);
+		if ((i & 0xf) == 0xf)
+			printf("\n");
+	}
+}
+
+/* TODO : during wait switch m2, if m1 busy, should swtich back to m1 and wait again */
+static int pre_switch_to_m2(void);
+static int pre_switch_to_m1(void);
+static int process_special_cmd(void);
+void switch_to_m1_special(void)
+{
+	unsigned int timeout = 500;
+
+	while((usage_flag != 0) && timeout--);     //wait for m2 to complete
+	if(!timeout)
+		printf("m2 overtime.");
+
+	timeout = 500;
+	while(pre_switch_to_m1() && timeout-- )
+		printf("*");
+	if(!timeout)
+		printf("2m1 timeout!\n");
+
+	word_write(SDSW_M2_CTRL0, 0x0);
+	word_write(SDSW_READ_SWDAT, 0x0);
+	word_write(SDSW_M1_CTRL0, 0x1);
+
+	usage_flag = 1;
+	M1_want_use_flag = 0;
+	special = 0;
+	//word_write(SCU_PLL_FREQ_SEL2, word_read(SCU_PLL_FREQ_SEL2) & 0xfdffffff);   //restore switch clock
+	//printf("1");
+}
+
+#define at_m1_mode()            ((word_read(SDSW_M1_CTRL0) & 0x1) == 0x1)
+#define at_m2_mode()            ((word_read(SDSW_M2_CTRL0) & 0x1) == 0x1)
+
+#define set_m1_mode()           word_write(SDSW_M1_CTRL0, 0x1)
+#define set_m2_mode()           word_write(SDSW_M2_CTRL0, 0x1)
+#define force_set_m1_mode()     word_write(SDSW_M1_CTRL0, 0x5)
+#define force_reset_m1_mode()   word_write(SDSW_M1_CTRL0, 0x8)
+
+#define reset_m1_mode()         word_write(SDSW_M1_CTRL0, 0x0)
+#define reset_m2_mode()         word_write(SDSW_M2_CTRL0, 0x0)
+
+#define select_m1(t)            do { set_m1_mode(); } while(!at_m1_mode() && t--)
+#define select_m2(t)            do { set_m2_mode(); } while(!at_m2_mode() && t--)
+#define deselect_m1(t)          do { reset_m1_mode(); } while(at_m1_mode() && t--)
+#define deselect_m2(t)          do { reset_m2_mode(); } while(at_m2_mode() && t--)
+
+#define m1_idle()               (word_read(SDSW_M1_STATUS) == 0x20200804)
+
+static __inline__ int null_delay(int t)
+{
+	volatile int i = 0;
+	volatile int j = 0;
+	for (i = 0; i < t; i++) {
+		for (j = 0; j < 5; j++);
+	}
+	return j;
+}
+
+
+void switch_to_m1_sw(void)
+{
+	unsigned int timeout = 500;
+
+	word_write(SDSW_M2_CTRL0, 0);
+#ifdef CONFIG_SYS_RESISTOR //CFG_BOARD_RESISTOR
+	if(usage_flag != 1)
+		enter_switch_mode(); //usage_flag = 0;
+	return;
+#else
+	if(at_m1_mode()) {                              //already at m1
+		deselect_m2(timeout);                       //deselect m2
+		goto tom1;
+	}
+
+	while(pre_switch_to_m1() && timeout-- )         //prepare to switch to m1
+		printf("*");
+	if(!timeout) printf("2m1 timeout!\n");
+
+#if CONFIG_SYS_VER == 3  //#ifdef CONFIG_V34                                   //clear cmd flags
+	//if(word_read(SDSW_M1_CMD_FLG_REG0) != 0)
+	//    printf("{%08x:%08x}", word_read(SDSW_M1_CMD_FLG_REG0), word_read(SDSW_M1_CMD_FLG_REG1));
+	word_write(SDSW_M1_CMD_FLG_REG0, 0xffffffff);
+	word_write(SDSW_M1_CMD_FLG_REG1, 0xffffffff);
+#endif
+
+	timeout = COMMANDS_TIMEOUT;
+	deselect_m2(timeout);                           //deselect m2
+
+	timeout = COMMANDS_TIMEOUT / 2;
+	select_m1(timeout);                             //select m1
+#if CONFIG_SYS_VER > 1 //#ifdef CONFIG_V34
+	if(!at_m1_mode())
+		force_set_m1_mode();                        //force switch to m1
+#endif
+
+tom1:
+	//word_write(SCU_PLL_FREQ_SEL2, word_read(SCU_PLL_FREQ_SEL2) & 0xfdffffff);   //restore switch clock
+	usage_flag = 1;
+	M1_want_use_flag = 0;
+	word_write(SDSW_M1_OCR_REG, word_read(SDSW_M1_OCR_REG) | 0x80000000);
+	if(special) {
+		special = 0;
+		null_delay(800);
+	}
+	//printf("1");
+#endif
+}
+
+int switch_to_m2_sw(int flag)
+{
+	unsigned int timeout = 100;
+
+	if(at_m2_mode()) {                              //already at m2
+		printf("@m2 ady\n");
+		deselect_m1(timeout);                       //deselect m1
+#if CONFIG_SYS_VER > 1 //#ifdef CONFIG_V34                                   //force reset m1
+		if(at_m1_mode())
+			force_reset_m1_mode();
+#endif
+		if(!timeout && at_m1_mode()) goto back2m1;
+		usage_flag = 2;
+		return 0;
+	}
+
+	word_write(SCU_SYSTEM_CTL3, 0x1);               //enable switch clock in SCU
+	while(pre_switch_to_m2());                      //prepare to switch to m2
+
+	timeout = COMMANDS_TIMEOUT;
+	deselect_m1(timeout);                           //deselect m1
+#if CONFIG_SYS_VER > 1 //#ifdef CONFIG_V34
+	if(at_m1_mode())
+		force_reset_m1_mode();
+#endif
+	if(!timeout && at_m1_mode()) goto back2m1;
+
+	timeout = COMMANDS_TIMEOUT;
+	select_m2(timeout);                             //select m2
+	if(!timeout && !at_m2_mode()) goto back2m1;
+
+#if CONFIG_SYS_VER == 3 //#ifdef CONFIG_V34
+	//if(word_read(SDSW_M1_CMD_FLG_REG0) != 0)
+	//    printf("{%08x:%08x}", word_read(SDSW_M1_CMD_FLG_REG0), word_read(SDSW_M1_CMD_FLG_REG1));
+	word_write(SDSW_M1_CMD_FLG_REG0, 0xffffffff);   //clear cmd flags b4 enter m2 mode
+	word_write(SDSW_M1_CMD_FLG_REG1, 0xffffffff);
+#endif
+//tom2:
+	usage_flag = 2;
+	word_write(SDSW_M1_OCR_REG, word_read(SDSW_M1_OCR_REG) & 0x7fffffff);
+	return 0;
+
+back2m1:
+	switch_to_m1_sw();
+	return 1;
+}
+
+/*static*/ void switch_send_cmd(unsigned int command, unsigned int argument, char check_type)
+{
+	unsigned int timeout=COMMANDS_TIMEOUT;
+
+	if((word_read(SDSW_M2_STATUS) & 0x1f) == 0x3) {
+		if(M2_send_cmd7(3))
+			return;
+	}
+
+	//spin_lock(&sd_rw_lock);
+	printf("switch send: cmd%d arg 0x%x", command, argument);
+	word_write(SDSW_DIRECT_CMD_INDEX_REG,   command);                 // CMD IDX
+	word_write(SDSW_DIRECT_CMD_ARGU_REG,    argument);                // CMD ARGU
+	word_write(SDSW_DIRECT_START_TRANS_REG, 0x1);                     // CMD START
+
+	while (timeout--) {
+		if ((word_read(SDSW_DIRECT_CTRL_REG) & CMD_RDY) == CMD_RDY) {  // check cmd ready
+			word_write(SDSW_DIRECT_CTRL_REG, CMD_RDY);                  // clear cmd ready flag
+			break ;
+		}
+	}
+	if (!timeout) {
+		printf("%s: Failed to send CMD%d, arg %x\n", __FUNCTION__, command, argument);
+		//spin_unlock(&sd_rw_lock);
+		return;
+	}
+	if (check_type == 1) {
+		timeout=COMMANDS_TIMEOUT;
+		while (timeout--) {
+			if ((word_read(SDSW_DIRECT_CTRL_REG) & RSP_RDY) == RSP_RDY) {// check rsp ready
+				word_write(SDSW_DIRECT_CTRL_REG, RSP_RDY);                // clear rsp ready flag
+				break ;
+			}
+		}
+	}
+	if (!timeout)
+		printf("%s: Failed to get resp for CMD%d\n", __FUNCTION__, command);
+	printf(" done. Rsp %d\n", check_type);
+	//spin_unlock(&sd_rw_lock);
+}
+
+/*static*/ int M1_send_cmd0(void)
+{
+	int timeout = COMMANDS_TIMEOUT, timeo1;
+
+	timeout = 10;
+	while(timeout) {
+		current_m1_cmd = word_read(SDSW_M1_CURR_CMD_REG) & 0x7f;
+		printf("cmd %x status %x\n", current_m1_cmd, word_read(SDSW_M1_STATUS));
+
+		timeo1 = 30; //COMMANDS_TIMEOUT;
+		do {
+			current_m1_cmd = word_read(SDSW_M1_CURR_CMD_REG) & 0x7f;
+			printf("%x,", current_m1_cmd);
+		} while((current_m1_cmd != 0x37) && (current_m1_cmd != 0x77) && timeo1--);//CMD55
+		//null_delay(1);
+		current_m1_cmd = word_read(SDSW_M1_CURR_CMD_REG) & 0x7f;
+		if ((current_m1_cmd != 0x29) && (current_m1_cmd != 0x69))               //CMD41
+			continue;
+		else
+			printf("m1 sent ACMD41\n");
+
+		if ((word_read(SDSW_M1_STATUS) & 0x3f3f0000) == 0x20200000)             //M1 CMD & DATA Idle
+			break;
+		timeout--;
+	}
+	printf("M1_send_cmd0: %d\n", timeout);
+	return (timeout == 0);
+}
+static int M2_send_cmd7(int loop)
+{
+	switch_to_m2_sw(7);
+	word_write(SDSW_M2_CTRL0, 0x1);                                         //sel M2
+
+	while(loop-- > 0) {                                                     //M2 send CMD7
+		//if(!HCmdNoData(M1_RCA, 0x7, 0x38, word_read(SDSW_M1_SBW_REG)|0x10))
+		RCA0 = (M1_RCA >> 16) & 0xff;
+		RCA1 = (M1_RCA >> 24) & 0xff;
+		if(!HCmdNoData(RCA1, RCA0, 0x0, 0x0, 0x7, 0x38, word_read(SDSW_M1_SBW_REG)|0x10))
+			break;
+	}
+	printf("M2_send_cmd7: %d\n", loop);
+	if (loop == 3) { // error handler call camera help
+		switch_send_cmd(0x0, 0x0, 0x0);                                 //SW send CMD0
+		word_write(SDSW_M2_CTRL0, 0x0) ;                                //unsel M2
+		M1_send_cmd0();                                                 //wait M1 resend CMD0
+		return 1;
+	}
+	word_write(SDSW_M2_CTRL0, 0x0);                                         //unsel M2
+	switch_to_m1_sw();
+	return 0;
+}
+static int M2_send_acmd41(void)
+{
+	unsigned int OCR1=0, OCR2=0;
+
+	if(HCmdNoData(RCA1, RCA0, 0x00, 0x00, 0x37, 0x38, 0x11))
+		goto fail;
+	//HCmdNoData(RCA1, RCA0, 0x00, 0x00, 0x37, 0x38, 0x11);
+
+	if(HCmdNoData(0x40, 0xff, 0x80, 0x00, 0x29, 0x38, 0x11))
+		goto fail;
+
+	OCR1 = (word_read(SDR_RESPONSE1_REG) & 0x0000ff00);
+	OCR2 = (word_read(SDR_RESPONSE1_REG) & 0x00ff0000) >> 16;
+	printf("ocr1=%x, ocr2=%x, m1=%x, m2=%x\n", OCR1, OCR2, word_read(SDSW_M1_STATUS), word_read(SDSW_M2_STATUS));
+	return 0;
+
+fail:
+	printf("M2_send_acmd41 failed (m1=%x, m2=%x)\n", word_read(SDSW_M1_STATUS), word_read(SDSW_M2_STATUS));
+	return 1;
+}
+/*static*/ int M2_send_cmd8(int loop)
+{
+	int ret=1;
+	//spin_lock(&sd_rw_lock);
+	switch_to_m2_sw(8);
+	//word_write(SDSW_M2_CTRL0, 0x1);                                         //sel M2
+
+	while(loop-- > 0) {                                                     //M2 send CMD8
+		//if(!HCmdNoData((0x01 << 8) | 0xaa, 0x08, 0x38, 0x11))
+		if(!HCmdNoData(0x00, 0x00, (0x01 << 8), 0xaa, 0x08, 0x38, 0x11))
+			break;
+		else
+			printf("failed to send cmd8\n");
+	}
+	ret = M2_send_acmd41();
+	do_switch_to_m1(); //switch_to_m1_sw();
+	//spin_unlock(&sd_rw_lock);
+	printf("M2_send_cmd8: %d\n", loop);
+	return ret;
+}
+static int M2_send_acmd22(void)
+{
+	unsigned int blkWritten=0, data=0;
+	unsigned int Buf[128]; //*pBuf=NULL;
+
+	switch_to_m2_sw(22);
+	word_write(SDSW_M2_CTRL0, 0x1);                                          //sel M2
+
+	// ACMD22 (SEND_NUM_WR_BLOCKS - send num of written (no error) blocks.) [adtc]
+	word_write(SDR_Card_BLOCK_SET_REG, 0x00040001);    	 	        //1 blk, 4B data
+	//word_write(SDR_Error_Enable_REG, 0x6f);                  	        //enable all errors
+	//if(HCmdNoData(M1_RCA, 0x37, 0x38, word_read(SDSW_M1_SBW_REG)|0x10))          //CMD55
+	RCA0 = (M1_RCA >> 16) & 0xff;
+	RCA1 = (M1_RCA >> 24) & 0xff;
+	if(HCmdNoData(RCA1, RCA0, 0x0, 0x0, 0x37, 0x38, word_read(SDSW_M1_SBW_REG)|0x10))          //CMD55
+		goto fail;
+	//if(HCmdNoData(0x00, 0x16, 0x79, word_read(SDSW_M1_SBW_REG)|0x10))            //ACMD22
+	if(HCmdNoData(0x0, 0x0, 0x0, 0x0, 0x16, 0x79, word_read(SDSW_M1_SBW_REG)|0x10))            //ACMD22
+		goto fail;
+	if(WaitResp(SD_XFER_DONE, 0)) //if(WaitResp(__LINE__, SD_XFER_DONE, 0))
+		goto fail;
+
+	//Prepare DMA
+	//pBuf = (unsigned int *)malloc(128); //pBuf = (unsigned int *)kmalloc(128, GFP_KERNEL);
+	//printf("phahaBuf=%p\n", pBuf);
+	word_write(SDR_DMA_TCCH1_REG, 0x4);
+	word_write(SDR_DMA_DACH1_REG, (unsigned int)Buf); //(unsigned int)virt_to_phys(pBuf));
+	word_write(SDR_DMA_CTRCH1_REG, 0x3F);
+	word_write(SDR_DMA_CTRCH1_REG, 0x33);
+	word_write(SDR_BUF_TRAN_CTRL_REG, 0x00010004);                          //Buffer xfer start
+	if(WaitResp(FIFO_XFER_DONE, 0)) { //if(WaitResp(__LINE__, FIFO_XFER_DONE, 0)) {
+		//kfree(pBuf);
+		goto fail;
+	}
+	data = Buf[0]; //*pBuf;
+	//kfree(pBuf);
+	blkWritten = ((data & 0xff000000)>>24) | ((data & 0xff0000)>>8) | ((data & 0xff00)<<8) | ((data & 0xff)<<24);
+	printf("ACMD22 blkWritten = %d\n", blkWritten);
+	word_write(SDSW_M2_CTRL0, 0x0);                                         //unsel M2
+	switch_to_m1_sw();
+	return 0;
+
+fail:
+	word_write(SDSW_M2_CTRL0, 0x0);                                         //unsel M2
+	DBG("M1 ACMD22 failed\n");
+	switch_to_m1_sw();
+	return 1;
+}
+static int M2_send_cmd27(void)
+{
+	unsigned int i=0;
+	unsigned char buff[128];                //tbu:eee
+
+	if((word_read(SDSW_M2_STATUS) & 0x1f) == 0x3) {
+		if(M2_send_cmd7(3))
+			return 1;
+	}
+	word_write(SDSW_M2_CTRL0, 0x1);                                         //sel M2
+
+	//Prepare DMA
+	word_write(SDR_DMA_TCCH0_REG, 128);
+	word_write(SDR_DMA_SACH0_REG, buff);
+	for(i = 0; i < 4; i++)                                                  //Write data to SDRAM
+		word_write(buff + (i*4), word_read(SDSW_M1_CSD_REG0) + (i*4));
+	dump_buffer(buff, 512);
+	word_write(SDR_DMA_CTRCH0_REG,0x3F); 			                //start DMA
+	word_write(SDR_DMA_CTRCH0_REG,0x33); 			                //reset DMA CH0 control
+	word_write(SDR_BUF_TRAN_CTRL_REG, ((0x1 << 16) | 0x6));                 //start buffer xfer
+	WaitDMAIntr(DMA_CH0_INTR);
+	word_write(SDR_Card_BLOCK_SET_REG, 0x00800001); //0x00000101 //tbu:eee
+	if(WaitResp(FIFO_XFER_DONE, 0)) //if(WaitResp(__LINE__, FIFO_XFER_DONE, 0))
+		goto fail;
+
+	//Send CMD27
+	//if(HCmdNoData(0x00, 0x1b, 0x78, word_read(SDSW_M1_SBW_REG)|0x10))            //CMD27
+	if(HCmdNoData(0x0, 0x0, 0x0, 0x0, 0x1b, 0x78, word_read(SDSW_M1_SBW_REG)|0x10))            //CMD27
+		goto fail;
+	if(WaitResp(SD_XFER_DONE, 0)) //if(WaitResp(__LINE__, SD_XFER_DONE, 0))
+		goto fail;
+	word_write(SDSW_M2_CTRL0, 0x0);                                         //unsel M2
+	return 0;
+
+fail:
+	word_write(SDSW_M2_CTRL0, 0x0);                                         //unsel M2
+	DBG("M1 CMD27 failed\n");
+	return 1;
+}
+static void process_new_cmd(void)
+{
+//	unsigned int BUS_WIDTH=0, WR_BLK_ERASE_COUNT=0
+	unsigned int m1cmd;
+	//DBG("cf0:%x cf1:%x\n", word_read(SDSW_M1_CMD_FLG_REG0), word_read(SDSW_M1_CMD_FLG_REG1));
+	//if(word_read(SDSW_M1_CMD_FLG_REG0) != 0)
+	//    printf("{n:%08x:%08x}", word_read(SDSW_M1_CMD_FLG_REG0), word_read(SDSW_M1_CMD_FLG_REG1));
+
+	m1cmd = word_read(SDSW_M1_CMD_FLG_REG0);
+	if ((m1cmd & CMD16) == CMD16) {                                         //CMD16 (Set Block Len) [ac]
+		word_write(SDSW_M1_CMD_FLG_REG0, CMD16);
+		switch_send_cmd(16, word_read(SDSW_M1_BLR_REG), 1);
+	}
+
+#if 0
+	BUS_WIDTH = word_read(SDSW_M1_SBW_REG);
+	if (CardInfo_width != BUS_WIDTH) {                                      //ACMD6 (Set Bus Width) [ac]
+		printf("bw 2:%x, 1:%x\n", CardInfo_width, BUS_WIDTH);
+		switch_send_cmd(55, M1_RCA, 1);
+		switch_send_cmd(6, BUS_WIDTH, 1);
+	}
+#endif
+	/*
+	        WR_BLK_ERASE_COUNT = word_read(SDSW_M1_SWBEC_REG);                      //ACMD23 (Set WR Blk Erase Count) [ac]
+	        if (WR_BLK_ERASE_COUNT != 0x1) {
+	                T(WR_BLK_ERASE_COUNT);
+	                switch_send_cmd(55, M1_RCA, 1);
+	                switch_send_cmd(23, WR_BLK_ERASE_COUNT, 1); //WR_BLK_ERASE_COUNT //tbd:eee
+	        }
+	*/
+	//printf("BW=%x, WBEC=%x\n", BUS_WIDTH, WR_BLK_ERASE_COUNT);
+	M1_status = word_read(SDSW_M1_STATUS) & 0x1f;
+	if((M1_status == 3) || (M1_status == 8) || (M1_status == 0))
+		return;
+
+	if ((m1cmd & CMD27) == CMD27) {                                         //CMD27 (Program CSD) [adtc]
+		word_write(SDSW_M1_CMD_FLG_REG0, CMD27);
+		M2_send_cmd27();
+	}
+
+	m1cmd = word_read(SDSW_M1_CMD_FLG_REG1);                                //CMD32 (Erase Wr Blk Start) [ac]
+	if ((m1cmd & CMD32) == 0x00000041) {
+		word_write(SDSW_M1_CMD_FLG_REG1, CMD32) ;
+		switch_send_cmd(32, word_read(SDSW_M1_EWBS_REG), 1);
+	}
+
+	if ((m1cmd & CMD33) == 0x00000042) {                                    //CMD33 (Erase Wr Blk End) [ac]
+		word_write(SDSW_M1_CMD_FLG_REG1, CMD33) ;
+		switch_send_cmd(33, word_read(SDSW_M1_EWBE_REG), 1);
+	}
+}
+static void switch_send_special(unsigned int cmd, unsigned int arg, int write)
+{
+	unsigned int timeout = 50;
+
+	word_write(SCU_SYSTEM_CTL3, 0x1);
+	//spin_lock(&sd_rw_lock);
+	deselect_m1(timeout);
+#if CONFIG_SYS_VER > 1 //#ifdef CONFIG_V34                                           //force reset m1
+	if(at_m1_mode())
+		force_reset_m1_mode();
+#endif
+	deselect_m2(timeout);
+#if CONFIG_SYS_VER != 3
+	word_write(SDSW_M1_CMD_FLG_REG0, 0xffffffff);     //clear all cmd flags
+	word_write(SDSW_M1_CMD_FLG_REG1, 0xffffffff);
+#endif
+	if(cmd < 32)
+		word_write(SDSW_M1_CMD_FLG_REG0, 1 << cmd);
+	else
+		word_write(SDSW_M1_CMD_FLG_REG1, 1 << (cmd - 32));
+	word_write(SDSW_DIRECT_CMD_INDEX_REG, cmd);
+	word_write(SDSW_DIRECT_CMD_ARGU_REG,  arg);
+	if(write)
+		word_write(SDSW_READ_SWDAT, 1);         //WDAT MEM SWITCH
+	word_write(SDSW_DIRECT_START_TRANS_REG, 0x1);   //CMD START
+	//spin_unlock(&sd_rw_lock);
+	word_write(SCU_SYSTEM_CTL3, 0x1);
+}
+static int process_special_cmd(void)
+{
+//	unsigned int i=0, swclk, cmd;
+	unsigned int m1cmd=0;
+
+	m1cmd = word_read(SDSW_M1_CMD_FLG_REG0);
+	if(!special && !(m1cmd & sflags0)) {
+		goto done;
+	}
+	//if(word_read(SDSW_M1_CMD_FLG_REG0) != 0)
+	//    printf("{s:%08x:%08x}", word_read(SDSW_M1_CMD_FLG_REG0), word_read(SDSW_M1_CMD_FLG_REG1));
+	special = 1;
+	//printf("s");
+
+	if( (m1cmd & CMD25) == CMD25) {
+		word_write(SDSW_M1_CMD_FLG_REG0, CMD25);
+		if(m1_idle())
+			goto done;
+//#ifndef GEN3
+		word_write(SCU_PLL_FREQ_SEL2, word_read(SCU_PLL_FREQ_SEL2) | 0x02000000); //invert switch clock
+		word_write(SDSW_M1_CSR_REG, 0xc00);
+//#endif
+		while((word_read(SDSW_M1_CTRL0) & 0x2) != 0x2);
+		{
+			switch_send_special(25, word_read(SDSW_M1_PREV_ARGU_REG), 1);
+			while (((word_read(SDSW_M1_CTRL0) & 0x1) == 0x0)) {
+				printf("+%x ", word_read(SDSW_M1_STATUS));
+			};
+			printf("s%d(%x)\n", word_read(SDSW_M1_PREV_CMD_REG), word_read(SDSW_M1_CMD_FLG_REG0));
+			return 0;
+		}
+		goto done;
+	}
+	if( (m1cmd & CMD24) == CMD24) {
+		if ((word_read(SDSW_M1_CTRL0) & 0x2) == 0x2) {          //M1 Write cmd busy flag
+			word_write(SDSW_M1_CMD_FLG_REG0, CMD24);        //clear CMD flag
+			switch_send_special(word_read(SDSW_M1_PREV_CMD_REG) & 0x7f, word_read(SDSW_M1_PREV_ARGU_REG), 1);
+			while ((word_read(SDSW_M1_CTRL0) & 0x1) == 0x0);
+			goto done;
+		}
+	}
+	if( (m1cmd & CMD17) == CMD17) {
+		word_write(SDSW_M1_CMD_FLG_REG0, CMD17);
+		if(!m1_idle()) {
+			switch_send_special(word_read(SDSW_M1_PREV_CMD_REG) & 0x7f, word_read(SDSW_M1_PREV_ARGU_REG), 0);
+			while ((word_read(SDSW_M1_CTRL0) & 0x1) == 0x0);
+			printf("d");
+		}
+		goto done;
+	}
+	if( (m1cmd & CMD18) == CMD18) {
+		word_write(SDSW_M1_CMD_FLG_REG0, CMD18);
+		if(!m1_idle()) {
+			switch_send_special(18, word_read(SDSW_M1_PREV_ARGU_REG), 0);
+			while ((word_read(SDSW_M1_CTRL0) & 0x1) == 0x0);
+			printf("s18:%x\n", word_read(SDSW_M1_PREV_ARGU_REG));
+			return 0;
+		}
+		goto done;
+	}
+	if( (m1cmd & CMD7) == CMD7) { //TBD:eee
+		DBG("cmd7\n");                          //tbd:eee
+		word_write(SDSW_M1_CMD_FLG_REG0, CMD7);
+		if(word_read(SDSW_M1_PREV_ARGU_REG) == M1_RCA)
+			M2_send_cmd7(3);
+		else
+			switch_send_cmd(0x7, 0x0, 0x0);
+		printf("arg:%x\n", word_read(SDSW_M1_PREV_ARGU_REG));
+		goto done;
+	}
+	if( (m1cmd & CMD6) == CMD6) {
+		DBG("cmd6\n");
+		word_write(SDSW_M1_CMD_FLG_REG0, CMD6);
+		switch_send_special(word_read(SDSW_M1_PREV_CMD_REG) & 0x7f, word_read(SDSW_M1_PREV_ARGU_REG), 0);
+		while ((word_read(SDSW_M1_CTRL0) & 0x1) == 0x0);
+		goto done;
+	}
+
+	m1cmd = word_read(SDSW_M1_CMD_FLG_REG1);
+	if( (m1cmd & CMD38) == CMD38) {
+		word_write(SDSW_M1_CMD_FLG_REG1, CMD38);
+		goto done;
+	}
+	if( (m1cmd & CMD42) == CMD42) {
+		if ((word_read(SDSW_M1_CTRL0) & 0x2) == 0x2) {
+			word_write(SDSW_M1_CMD_FLG_REG1, CMD42);
+			switch_send_special(word_read(SDSW_M1_PREV_CMD_REG) & 0x7f, 0x0, 1);
+			while ((word_read(SDSW_M1_CTRL0) & 0x1) == 0x0);
+			goto done;
+		}
+	}
+	if( (m1cmd & CMD56) == CMD56) {
+		if ((word_read(SDSW_M1_PREV_ARGU_REG) & 0x1) == 0x1) {          //CMD56r
+			word_write(SDSW_M1_CMD_FLG_REG1, CMD56);
+			switch_send_special(word_read(SDSW_M1_PREV_CMD_REG) & 0x7f, word_read(SDSW_M1_PREV_ARGU_REG), 0);
+			while ((word_read(SDSW_M1_CTRL0) & 0x1) == 0x0);
+			goto done;
+		}
+		if ((word_read(SDSW_M1_PREV_ARGU_REG) & 0x1) == 0x0) {
+			if ((word_read(SDSW_M1_CTRL0) & 0x2) == 0x2) {          //CMD56w
+				word_write(SDSW_M1_CMD_FLG_REG1, CMD56);
+				switch_send_special(word_read(SDSW_M1_PREV_CMD_REG) & 0x7f, word_read(SDSW_M1_PREV_ARGU_REG), 1);
+				while ((word_read(SDSW_M1_CTRL0) & 0x1) == 0x0);
+				goto done;
+			}
+		}
+	}
+done:
+	return 0;
+}
+static void clear_all_regs(void)
+{
+	//if(word_read(SDSW_M1_CMD_FLG_REG0) != 0)
+	//    printf("{%08x:%08x}", word_read(SDSW_M1_CMD_FLG_REG0), word_read(SDSW_M1_CMD_FLG_REG1));
+	word_write(SDSW_M1_CMD_FLG_REG0,       0xffffffff/*0x00000000*/); // clear CMD0 ~ CMD29 flag
+	word_write(SDSW_M1_CMD_CRC_FLG_REG0,   0x00000000); // clear CMD0 ~ CMD29 crc flag
+	word_write(SDSW_M1_CMD_FLG_REG1,       0xffffffff/*0x00000000*/); // clear CMD32 ~ CMD59 flag
+	word_write(SDSW_M1_CMD_CRC_FLG_REG1,   0x00000000); // clear CMD32 ~ CMD59 crc flag
+	word_write(SDSW_M1_CMD_FLG_REG2,       0x00000000); // clear ACMD6 ACMD13 ACMD22 ACMD23 flag
+	word_write(SDSW_M1_CMD_CRC_FLG_REG2,   0x00000000); // clear ACMD6 ACMD13 ACMD22 ACMD23 crc flag
+	word_write(SDSW_M1_CMD_FLG_REG3,       0x00000000); // clear ACMD41 ACMD42 ACMD51 flag
+	word_write(SDSW_M1_CMD_CRC_FLG_REG3,   0x00000000); // clear ACMD41 ACMD42 ACMD51 crc flag
+}
+
+#ifdef CONFIG_SYS_RESISTOR //CFG_BOARD_RESISTOR
+static void enter_switch_mode(void)
+{
+	usage_flag = 0;
+	return;
+}
+#endif // CONFIG_SYS_RESISTOR
+
+static int pre_switch_to_m2(void)
+{
+//	unsigned int i=0;
+//	unsigned int cf0, cf1;
+
+	/*cf0 = word_read(SDSW_M1_CMD_FLG_REG0) & (CMD25 | CMD18 | CMD0);
+	if (cf0 != 0)
+	{
+	        printf("&%x:%d:%d:%x:%x,", word_read(SDSW_M1_STATUS), word_read(SDSW_M1_CTRL0), word_read(SDSW_M2_CTRL0),word_read(SDSW_M1_CMD_FLG_REG0), word_read(SDSW_M1_CMD_FLG_REG1));
+	//return 1;
+	}*/
+	M1_status = word_read(SDSW_M1_STATUS) & 0x1f; //IDLE:0, READY:1, IDENT:2, STBY:3 , TRAN: 4 , DATA:5 , RCV: 6,
+	M2_status = word_read(SDSW_M2_STATUS) & 0x1f; //PRG: 7, DIS:  8, INA:  9, SPI: 16, DATA2:21, RCV2:22, PRG2:23
+	if (M2_status != M1_status) {                                           //Match M1 & M2 card status
+		//printf("m1=%d, m2=%d\n", M1_status, M2_status);
+		switch(M1_status) {
+		case 0x3:
+			word_write(SDSW_SW_CTRL0, 0x1);
+			break;          //GOTOSTBY_M2
+		case 0x4:
+			word_write(SDSW_SW_CTRL0, 0x2);
+			break;          //GOTOTRAN_M2
+		case 0x0:
+			null_delay(SWITCH_DELAY);
+			break; //null_delay(SWITCH_DELAY); return 1; //
+		default:
+			printf("(M1:%d:%d:%d)\n", M1_status, word_read(SDSW_M1_CTRL0), word_read(SDSW_M2_CTRL0));
+			//printf("(%08x:%08x:%08x:%08x)", word_read(0xa0000000), word_read(SCU_PLL_FREQ_SEL2), word_read(SCU_SYSTEM_CTL3), word_read(SDSW_M1_CSR_REG));
+			null_delay(SWITCH_DELAY*5); //*10
+			return 1;
+		}
+		M2_status = M1_status;
+	}
+
+	CardInfo_width  = word_read(SDSW_M1_SBW_REG);
+	return 0;
+}
+static int pre_switch_to_m1(void)
+{
+start:
+	//IDLE:0, READY:1, IDENT:2, STBY:3 , TRAN: 4 , DATA:5 , RCV: 6,
+	//PRG: 7, DIS:  8, INA:  9, SPI: 16, DATA2:21, RCV2:22, PRG2:23
+
+	M1_status = word_read(SDSW_M1_STATUS) & 0x1f;
+	M2_status = word_read(SDSW_M2_STATUS) & 0x1f;
+	switch(M1_status) {
+	case 0:     //M1=idle: Switch send CMD0 & wait for M1 to send ACMD41
+		word_write(SDSW_M1_CMD_FLG_REG0, 0x11);
+		switch_send_cmd(0x0, 0x0, 0x0); //CMD0
+		M2_send_cmd8(1);
+		M1_send_cmd0();
+		break;
+
+	case 3:     //stby
+	case 8:     //dis
+		//disable interrupt from CMD7
+		word_write(SDSW_M1_CMD_FLAG_INTEN_REG0, (word_read(SDSW_M1_CMD_FLAG_INTEN_REG0) & 0xffffff7f));
+		M1_RCA = (word_read(SDSW_M1_RCA_REG) << 16);
+		T(M1_status);
+
+		while(1) {
+			/*if (new_cmd_flag) {                                         //command to send
+			    new_cmd_flag = 0;
+			    if(M2_status == 0x3) {                                  //but both M1 & M2 in stby
+			            if(M2_send_cmd7(3))                             //move card to tran with CMD7
+			                    break;                                  //if failed, abort & switch to m1
+			    }
+			    process_new_cmd();                                      //process the command
+			} */
+			process_new_cmd();
+			if((word_read(SDSW_M2_STATUS) & 0x1f) != 0x3) {                                      //M2 not in stby
+				switch_send_cmd(0x7, 0x0, 0x0);                         //deselect card with CMD7
+			}
+			if ((word_read(SDSW_M1_CMD_FLG_REG0) & CMD4) == CMD4) {     //CMD4 (Set DSR)
+				word_write(SDSW_M1_CMD_FLG_REG0, CMD4);
+				switch_send_cmd(0x04, (word_read(SDSW_M1_DSR_REG) << 16), 0x0);
+			}
+			//if (new_cmd_flag)                                           //detect command again
+			//    continue;
+			if ((word_read(SDSW_M1_CMD_FLG_REG0) & CMD7) == CMD7) {     //M1 requested CMD7
+				word_write(SDSW_M1_CMD_FLG_REG0, CMD7);
+				M2_send_cmd7(3);
+			} else if ((word_read(SDSW_M1_STATUS) & 0x3f3f0000) != 0x20200000)
+				continue;
+			break;
+		}
+		//enable interrupt from CMD7
+		word_write(SDSW_M1_CMD_FLAG_INTEN_REG0, (word_read(SDSW_M1_CMD_FLAG_INTEN_REG0) | 0x80));
+		clear_all_regs();
+		break;
+
+	case 4:     //tran
+	case 5:     //data
+	case 6:     //rcv
+	case 7:     //prg
+		//case 8:   //dis
+	case 9:     //ina           //TBD:eee
+	case 16:    //spi           //TBD:eee
+	case 21:    //data2
+	case 22:    //rcv2
+	case 23:    //prg2
+		M1_RCA = (word_read(SDSW_M1_RCA_REG) << 16);
+		if (M2_status == 0x3) {                                         //M2 in stby, send CMD7
+			if(M2_send_cmd7(3))
+				break;
+		}
+
+		if ((word_read(SDSW_M1_CMD_FLG_REG2) & ACMD22) == ACMD22) {
+			word_write(SDSW_M1_CMD_FLG_REG2, ACMD22);
+			M2_send_acmd22();
+		}
+
+		//while(1) {
+		process_new_cmd();
+		M1_status = (word_read(SDSW_M1_STATUS) & 0x1f);
+		if ((M1_status == 0x3) || (M1_status == 0x0)) {         //STBY and IDLE
+			T(M1_status);
+			goto start;
+		}
+		//if(new_cmd_flag)
+		//        continue;
+		//break;
+		//}
+		process_special_cmd();
+		break;
+
+	default:
+		break;
+	}
+	//switch_to_m1_sw();
+	return 0;
+}
+
+//int kcard_check_m1_cmd_flags(unsigned long time_ticks)
+int kcard_check_m1_cmd_flags(void)
+{
+	unsigned int cf0=0, cf1=0;
+//	unsigned int m1state;
+//	static int special_busy;
+
+	cf0 = word_read(SDSW_M1_CMD_FLG_REG0);
+	cf1 = word_read(SDSW_M1_CMD_FLG_REG1);
+	if(special == 1 || (cf0 & sflags0) || (cf1 & sflags1)) {
+		{
+			M1_want_use_flag = 1;
+			special = 1;
+			kcard_busy = KCARD_BUSY_TIME; //200;
+#ifdef CONFIG_SYS_RESISTOR //CFG_BOARD_RESISTOR
+			if (/*usage_flag == 0 && */special_busy == 0) {
+				special_busy = 1;
+				switch_to_m1_special();
+				special_busy = 0;
+			}
+#endif
+			//M1_request_flag = 1;
+		}
+
+	}
+
+	if (word_read(SDSW_BOMB_Flag_ADDR_REG) == 0x01) {
+		if (kcard_busy < KCARD_BUSY_TIME)
+			kcard_busy += 10;
+
+		bomb_alarmed = 1;
+		word_write(SDSW_BOMB_Flag_ADDR_REG, 0x1);
+	}
+
+	if (kcard_busy > 0)
+		kcard_busy--;
+	return 0;
+}
+
+#if 0
+int M1_check_sdsw_rw = 1;
+typedef enum {
+	SW_STATE_INIT = 0,
+	SW_STATE_POWER_UP,
+	SW_STATE_SCAN_CACHE,
+	SW_STATE_CHECK_IMAGE,
+	SW_STATE_RESTORE_IMAGE,
+	SW_STATE_NORMAL_STATE,
+	SW_STATE_M1_BUSY,
+	SW_STATE_SYNC_SD,
+} switch_status_t;
+
+switch_status_t switch_status = SW_STATE_INIT;
+
+static int kcard_check_status(void)
+{
+	int ret = 0;
+
+	if(M1_check_sdsw_rw && bomb_alarmed) { //word_read(SDSW_BOMB_Flag_ADDR_REG) == 0x01)
+		word_write(SDSW_BOMB_Flag_ADDR_REG, 0x01);
+		//bomb_alarmed++;
+		bomb_alarmed = 0;
+
+		ret = kcard_check_fat(1);
+		return ret;
+	}
+
+	return 0;
+}
+
+int set_switch_status(switch_status_t new_status)
+{
+	printf("set_switch_status %d\n", new_status);
+	switch_status = new_status;
+	return 0;
+}
+
+static void kcard_status_work(struct work_struct *work)
+{
+	int t = 50;
+	int ret = 0;
+	//printf("kcard_check_status %d\n", M1_check_sdsw_rw);
+
+	switch (switch_status) {
+	case SW_STATE_POWER_UP :
+		do_fat_scan_cache();
+		set_switch_status(SW_STATE_CHECK_IMAGE);
+		break;
+	case SW_STATE_SCAN_CACHE :
+		printf("scan cache\n");
+		do_fat_scan_cache();
+		//t = 300;
+		set_switch_status(SW_STATE_CHECK_IMAGE);
+		break;
+	case SW_STATE_SYNC_SD :
+		if (M1_check_sdsw_rw && kcard_busy <= 0) {
+			//spin_lock(&sd_rw_lock);
+			fluapp_cmd = 7;
+			send_sig(SIGUSR1,fluapp_task, 0);// send signal to userspace process
+			//spin_unlock(&sd_rw_lock);
+			set_switch_status(SW_STATE_CHECK_IMAGE);
+		}
+		break;
+	default:
+		if (M1_check_sdsw_rw) {
+			if(fluapp8) {
+				fluapp8 = 0;
+				do_fat_scan_cache();
+				goto end;
+			}
+
+			if (kcard_busy > 0) // || ((word_read(SDSW_M1_STATUS) & 0x3f3f0000) != 0x20200000))
+				t = 20;
+			else {
+				ret = kcard_check_status();
+			}
+		}
+		break;
+	}
+
+end:
+	schedule_delayed_work(&status_work, t);
+}
+#endif
+
+
+
diff --git a/arch/arm/cpu/arm926ejs/keyasic/sdswitch.h b/arch/arm/cpu/arm926ejs/keyasic/sdswitch.h
new file mode 100644
index 0000000..af50f81
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/keyasic/sdswitch.h
@@ -0,0 +1,69 @@
+#ifndef __ASM_ARCH_SWITCH_H
+#define __ASM_ARCH_SWITCH_H
+
+//#define word_write(a, v) 	__raw_writel(v, IO_ADDRESS(a))
+//#define word_read(a)  		__raw_readl(IO_ADDRESS(a))
+
+//SDSW_M1_CMD_FLG_REG0
+#define CMD0                    (0x1 << 0)
+#define CMD1                    (0x1 << 1)
+#define CMD2                    (0x1 << 2)
+#define CMD3                    (0x1 << 3)
+#define CMD4                    (0x1 << 4)
+#define CMD6                    (0x1 << 6)
+#define CMD7                    (0x1 << 7)
+#define CMD8                    (0x1 << 8)
+#define CMD9                    (0x1 << 9)
+#define CMD10                   (0x1 << 10)
+#define CMD7_DESEL              (0x1 << 11)
+#define CMD12                   (0x1 << 12)
+#define CMD13                   (0x1 << 13)
+#define CMD15                   (0x1 << 15)
+#define CMD16                   (0x1 << 16)
+#define CMD17                   (0x1 << 17)
+#define CMD18                   (0x1 << 18)
+#define CMD24                   (0x1 << 24)
+#define CMD25                   (0x1 << 25)
+#define CMD27                   (0x1 << 27)
+#define CMD28                   (0x1 << 28)
+#define CMD29                   (0x1 << 29)
+#define CMD30                   (0x1 << 30)
+
+//SDSW_M1_CMD_FLG_REG1
+#define CMD32                   (0x1 << 0)
+#define CMD33                   (0x1 << 1)
+#define CMD38                   (0x1 << 6)
+#define CMD42                   (0x1 << 10)
+#define CMD55                   (0x1 << 23)
+#define CMD56                   (0x1 << 24)
+#define CMD58                   (0x1 << 26)
+#define CMD59                   (0x1 << 27)
+
+//SDSW_M1_CMD_FLG_REG2
+#define ACMD6                   (0x1 << 6)
+#define ACMD13                  (0x1 << 13)
+#define ACMD22                  (0x1 << 22)
+#define ACMD23                  (0x1 << 23)
+
+//SDSW_M1_CMD_FLG_REG3
+#define ACMD41                  (0x1 << 9)
+#define ACMD42                  (0x1 << 10)
+#define ACMD51                  (0x1 << 19)
+
+//SDSW_DIRECT_CTRL_REG
+#define CRC_ERR_STILL_SW        0x1
+#define RSP_RDY		        0x2
+#define RSP_CRC_ERR_LAG	        0x4
+#define CMD_RDY		        0x8
+
+//SDR_DMA_TRAN_RESP_REG
+#define FIFO_XFER_DONE		0x1
+#define SD_XFER_DONE		0x2
+#define SD_CMD_DONE		0x4
+#define SD_DATA_BOUND		0x8
+
+//SDR_DMA_INTS_REG
+#define DMA_CH0_INTR		0x1
+#define DMA_CH1_INTR		0x2
+
+#endif /* __ASM_ARCH_SWITCH_H */
diff --git a/arch/arm/cpu/arm926ejs/keyasic/timer.c b/arch/arm/cpu/arm926ejs/keyasic/timer.c
new file mode 100644
index 0000000..63f6695
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/keyasic/timer.c
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 2010
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/hardware.h>
+
+struct ka_timer {
+	u_int32_t	timmercr;
+	u_int32_t	wdtcr;
+};
+
+static struct ka_timer * const timer =
+        (struct ka_timer *)KA_TIMER0_BASE;	//CONFIG_SYS_TIMERBASE;
+
+#define TIMER_LOAD_VAL	(CONFIG_SYS_HZ_CLOCK / CONFIG_SYS_HZ)
+#define TIM_CLK_DIV	16
+
+static ulong timestamp;
+//static ulong lastinc;
+
+int timer_init(void)
+{
+	// We do not need to initialize timer, dummy function
+	//writel(TIMER_LOAD_VAL, &timer->prd34);
+	timestamp = 0;
+	return(0);
+}
+
+void reset_timer(void)
+{
+	// dummy function
+	timestamp = 0;
+}
+
+static ulong get_timer_raw(void)
+{
+	static ulong t;
+
+	if (t == timestamp)
+		timestamp++;
+	t = timestamp;
+	// dummy function
+	return timestamp;
+}
+
+ulong get_timer(ulong base)
+{
+	return((get_timer_raw() / (TIMER_LOAD_VAL / TIM_CLK_DIV)) - base);
+}
+
+void set_timer(ulong t)
+{
+	timestamp = t;
+}
+
+void __udelay(unsigned long usec)
+{
+#if 1
+	ulong tmo;
+	ulong endtime;
+	signed long diff;
+
+	tmo = CONFIG_SYS_HZ_CLOCK / 1000;
+	tmo *= usec;
+	tmo /= (1000 * TIM_CLK_DIV);
+
+	endtime = get_timer_raw() + tmo;
+
+	do {
+		ulong now = get_timer_raw();
+		diff = endtime - now;
+	} while (diff >= 0);
+#else
+	volatile int i;
+	for(i=0; i<(33*usec); i++);
+#endif
+}
+
+/*
+ * This function is derived from PowerPC code (read timebase as long long).
+ * On ARM it just returns the timer value.
+ */
+unsigned long long get_ticks(void)
+{
+	return(get_timer(0));
+}
+
+/*
+ * This function is derived from PowerPC code (timebase clock frequency).
+ * On ARM it returns the number of timer ticks per second.
+ */
+ulong get_tbclk(void)
+{
+	return CONFIG_SYS_HZ;
+}
diff --git a/arch/arm/include/asm/arch-keyasic/emac_defs.h b/arch/arm/include/asm/arch-keyasic/emac_defs.h
new file mode 100644
index 0000000..b0ec8f5
--- /dev/null
+++ b/arch/arm/include/asm/arch-keyasic/emac_defs.h
@@ -0,0 +1,393 @@
+/*
+ * Copyright (C) 2007 Sergey Kubushyn <ksi@koi8.net>
+ *
+ * Based on:
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * dm644x_emac.h
+ *
+ * TI DaVinci (DM644X) EMAC peripheral driver header for DV-EVM
+ *
+ * Copyright (C) 2005 Texas Instruments.
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+
+ * Modifications:
+ * ver. 1.0: Sep 2005, TI PSP Team - Created EMAC version for uBoot.
+ *
+ */
+
+#ifndef _DM644X_EMAC_H_
+#define _DM644X_EMAC_H_
+
+#include <asm/arch/hardware.h>
+
+#ifdef CONFIG_SOC_DM365
+#define EMAC_BASE_ADDR			(0x01d07000)
+#define EMAC_WRAPPER_BASE_ADDR		(0x01d0a000)
+#define EMAC_WRAPPER_RAM_ADDR		(0x01d08000)
+#define EMAC_MDIO_BASE_ADDR		(0x01d0b000)
+#define DAVINCI_EMAC_VERSION2
+#elif defined(CONFIG_SOC_DA8XX)
+#define EMAC_BASE_ADDR			DAVINCI_EMAC_CNTRL_REGS_BASE
+#define EMAC_WRAPPER_BASE_ADDR		DAVINCI_EMAC_WRAPPER_CNTRL_REGS_BASE
+#define EMAC_WRAPPER_RAM_ADDR		DAVINCI_EMAC_WRAPPER_RAM_BASE
+#define EMAC_MDIO_BASE_ADDR		DAVINCI_MDIO_CNTRL_REGS_BASE
+#define DAVINCI_EMAC_VERSION2
+#else
+#define EMAC_BASE_ADDR			(0x01c80000)
+#define EMAC_WRAPPER_BASE_ADDR		(0x01c81000)
+#define EMAC_WRAPPER_RAM_ADDR		(0x01c82000)
+#define EMAC_MDIO_BASE_ADDR		(0x01c84000)
+#endif
+
+#ifdef CONFIG_SOC_DM646X
+#define DAVINCI_EMAC_VERSION2
+#define DAVINCI_EMAC_GIG_ENABLE
+#endif
+
+#ifdef CONFIG_SOC_DM646X
+/* MDIO module input frequency */
+#define EMAC_MDIO_BUS_FREQ		76500000
+/* MDIO clock output frequency */
+#define EMAC_MDIO_CLOCK_FREQ		2500000		/* 2.5 MHz */
+#elif defined(CONFIG_SOC_DM365)
+/* MDIO module input frequency */
+#define EMAC_MDIO_BUS_FREQ		121500000
+/* MDIO clock output frequency */
+#define EMAC_MDIO_CLOCK_FREQ		2200000		/* 2.2 MHz */
+#elif defined(CONFIG_SOC_DA8XX)
+/* MDIO module input frequency */
+#define EMAC_MDIO_BUS_FREQ		clk_get(DAVINCI_MDIO_CLKID)
+/* MDIO clock output frequency */
+#define EMAC_MDIO_CLOCK_FREQ		2000000		/* 2.0 MHz */
+#else
+/* MDIO module input frequency */
+#define EMAC_MDIO_BUS_FREQ		99000000	/* PLL/6 - 99 MHz */
+/* MDIO clock output frequency */
+#define EMAC_MDIO_CLOCK_FREQ		2000000		/* 2.0 MHz */
+#endif
+
+/* PHY mask - set only those phy number bits where phy is/can be connected */
+#define EMAC_MDIO_PHY_NUM           1
+#define EMAC_MDIO_PHY_MASK          (1 << EMAC_MDIO_PHY_NUM)
+
+/* Ethernet Min/Max packet size */
+#define EMAC_MIN_ETHERNET_PKT_SIZE	60
+#define EMAC_MAX_ETHERNET_PKT_SIZE	1518
+#define EMAC_PKT_ALIGN			18	/* 1518 + 18 = 1536 (packet aligned on 32 byte boundry) */
+
+/* Number of RX packet buffers
+ * NOTE: Only 1 buffer supported as of now
+ */
+#define EMAC_MAX_RX_BUFFERS		10
+
+
+/***********************************************
+ ******** Internally used macros ***************
+ ***********************************************/
+
+#define EMAC_CH_TX			1
+#define EMAC_CH_RX			0
+
+/* Each descriptor occupies 4 words, lets start RX desc's at 0 and
+ * reserve space for 64 descriptors max
+ */
+#define EMAC_RX_DESC_BASE		0x0
+#define EMAC_TX_DESC_BASE		0x1000
+
+/* EMAC Teardown value */
+#define EMAC_TEARDOWN_VALUE		0xfffffffc
+
+/* MII Status Register */
+#define MII_STATUS_REG			1
+
+/* Number of statistics registers */
+#define EMAC_NUM_STATS			36
+
+
+/* EMAC Descriptor */
+typedef volatile struct _emac_desc
+{
+	u_int32_t	next;		/* Pointer to next descriptor in chain */
+	u_int8_t	*buffer;	/* Pointer to data buffer */
+	u_int32_t	buff_off_len;	/* Buffer Offset(MSW) and Length(LSW) */
+	u_int32_t	pkt_flag_len;	/* Packet Flags(MSW) and Length(LSW) */
+} emac_desc;
+
+/* CPPI bit positions */
+#define EMAC_CPPI_SOP_BIT		(0x80000000)
+#define EMAC_CPPI_EOP_BIT		(0x40000000)
+#define EMAC_CPPI_OWNERSHIP_BIT		(0x20000000)
+#define EMAC_CPPI_EOQ_BIT		(0x10000000)
+#define EMAC_CPPI_TEARDOWN_COMPLETE_BIT	(0x08000000)
+#define EMAC_CPPI_PASS_CRC_BIT		(0x04000000)
+
+#define EMAC_CPPI_RX_ERROR_FRAME	(0x03fc0000)
+
+#define EMAC_MACCONTROL_MIIEN_ENABLE		(0x20)
+#define EMAC_MACCONTROL_FULLDUPLEX_ENABLE	(0x1)
+#define EMAC_MACCONTROL_GIGABIT_ENABLE		(1 << 7)
+#define EMAC_MACCONTROL_GIGFORCE		(1 << 17)
+#define EMAC_MACCONTROL_RMIISPEED_100		(1 << 15)
+
+#define EMAC_MAC_ADDR_MATCH		(1 << 19)
+#define EMAC_MAC_ADDR_IS_VALID		(1 << 20)
+
+#define EMAC_RXMBPENABLE_RXCAFEN_ENABLE	(0x200000)
+#define EMAC_RXMBPENABLE_RXBROADEN	(0x2000)
+
+
+#define MDIO_CONTROL_IDLE		(0x80000000)
+#define MDIO_CONTROL_ENABLE		(0x40000000)
+#define MDIO_CONTROL_FAULT_ENABLE	(0x40000)
+#define MDIO_CONTROL_FAULT		(0x80000)
+#define MDIO_USERACCESS0_GO		(0x80000000)
+#define MDIO_USERACCESS0_WRITE_READ	(0x0)
+#define MDIO_USERACCESS0_WRITE_WRITE	(0x40000000)
+#define MDIO_USERACCESS0_ACK		(0x20000000)
+
+/* Ethernet MAC Registers Structure */
+typedef struct  {
+	dv_reg		TXIDVER;
+	dv_reg		TXCONTROL;
+	dv_reg		TXTEARDOWN;
+	u_int8_t	RSVD0[4];
+	dv_reg		RXIDVER;
+	dv_reg		RXCONTROL;
+	dv_reg		RXTEARDOWN;
+	u_int8_t	RSVD1[100];
+	dv_reg		TXINTSTATRAW;
+	dv_reg		TXINTSTATMASKED;
+	dv_reg		TXINTMASKSET;
+	dv_reg		TXINTMASKCLEAR;
+	dv_reg		MACINVECTOR;
+	u_int8_t	RSVD2[12];
+	dv_reg		RXINTSTATRAW;
+	dv_reg		RXINTSTATMASKED;
+	dv_reg		RXINTMASKSET;
+	dv_reg		RXINTMASKCLEAR;
+	dv_reg		MACINTSTATRAW;
+	dv_reg		MACINTSTATMASKED;
+	dv_reg		MACINTMASKSET;
+	dv_reg		MACINTMASKCLEAR;
+	u_int8_t	RSVD3[64];
+	dv_reg		RXMBPENABLE;
+	dv_reg		RXUNICASTSET;
+	dv_reg		RXUNICASTCLEAR;
+	dv_reg		RXMAXLEN;
+	dv_reg		RXBUFFEROFFSET;
+	dv_reg		RXFILTERLOWTHRESH;
+	u_int8_t	RSVD4[8];
+	dv_reg		RX0FLOWTHRESH;
+	dv_reg		RX1FLOWTHRESH;
+	dv_reg		RX2FLOWTHRESH;
+	dv_reg		RX3FLOWTHRESH;
+	dv_reg		RX4FLOWTHRESH;
+	dv_reg		RX5FLOWTHRESH;
+	dv_reg		RX6FLOWTHRESH;
+	dv_reg		RX7FLOWTHRESH;
+	dv_reg		RX0FREEBUFFER;
+	dv_reg		RX1FREEBUFFER;
+	dv_reg		RX2FREEBUFFER;
+	dv_reg		RX3FREEBUFFER;
+	dv_reg		RX4FREEBUFFER;
+	dv_reg		RX5FREEBUFFER;
+	dv_reg		RX6FREEBUFFER;
+	dv_reg		RX7FREEBUFFER;
+	dv_reg		MACCONTROL;
+	dv_reg		MACSTATUS;
+	dv_reg		EMCONTROL;
+	dv_reg		FIFOCONTROL;
+	dv_reg		MACCONFIG;
+	dv_reg		SOFTRESET;
+	u_int8_t	RSVD5[88];
+	dv_reg		MACSRCADDRLO;
+	dv_reg		MACSRCADDRHI;
+	dv_reg		MACHASH1;
+	dv_reg		MACHASH2;
+	dv_reg		BOFFTEST;
+	dv_reg		TPACETEST;
+	dv_reg		RXPAUSE;
+	dv_reg		TXPAUSE;
+	u_int8_t	RSVD6[16];
+	dv_reg		RXGOODFRAMES;
+	dv_reg		RXBCASTFRAMES;
+	dv_reg		RXMCASTFRAMES;
+	dv_reg		RXPAUSEFRAMES;
+	dv_reg		RXCRCERRORS;
+	dv_reg		RXALIGNCODEERRORS;
+	dv_reg		RXOVERSIZED;
+	dv_reg		RXJABBER;
+	dv_reg		RXUNDERSIZED;
+	dv_reg		RXFRAGMENTS;
+	dv_reg		RXFILTERED;
+	dv_reg		RXQOSFILTERED;
+	dv_reg		RXOCTETS;
+	dv_reg		TXGOODFRAMES;
+	dv_reg		TXBCASTFRAMES;
+	dv_reg		TXMCASTFRAMES;
+	dv_reg		TXPAUSEFRAMES;
+	dv_reg		TXDEFERRED;
+	dv_reg		TXCOLLISION;
+	dv_reg		TXSINGLECOLL;
+	dv_reg		TXMULTICOLL;
+	dv_reg		TXEXCESSIVECOLL;
+	dv_reg		TXLATECOLL;
+	dv_reg		TXUNDERRUN;
+	dv_reg		TXCARRIERSENSE;
+	dv_reg		TXOCTETS;
+	dv_reg		FRAME64;
+	dv_reg		FRAME65T127;
+	dv_reg		FRAME128T255;
+	dv_reg		FRAME256T511;
+	dv_reg		FRAME512T1023;
+	dv_reg		FRAME1024TUP;
+	dv_reg		NETOCTETS;
+	dv_reg		RXSOFOVERRUNS;
+	dv_reg		RXMOFOVERRUNS;
+	dv_reg		RXDMAOVERRUNS;
+	u_int8_t	RSVD7[624];
+	dv_reg		MACADDRLO;
+	dv_reg		MACADDRHI;
+	dv_reg		MACINDEX;
+	u_int8_t	RSVD8[244];
+	dv_reg		TX0HDP;
+	dv_reg		TX1HDP;
+	dv_reg		TX2HDP;
+	dv_reg		TX3HDP;
+	dv_reg		TX4HDP;
+	dv_reg		TX5HDP;
+	dv_reg		TX6HDP;
+	dv_reg		TX7HDP;
+	dv_reg		RX0HDP;
+	dv_reg		RX1HDP;
+	dv_reg		RX2HDP;
+	dv_reg		RX3HDP;
+	dv_reg		RX4HDP;
+	dv_reg		RX5HDP;
+	dv_reg		RX6HDP;
+	dv_reg		RX7HDP;
+	dv_reg		TX0CP;
+	dv_reg		TX1CP;
+	dv_reg		TX2CP;
+	dv_reg		TX3CP;
+	dv_reg		TX4CP;
+	dv_reg		TX5CP;
+	dv_reg		TX6CP;
+	dv_reg		TX7CP;
+	dv_reg		RX0CP;
+	dv_reg		RX1CP;
+	dv_reg		RX2CP;
+	dv_reg		RX3CP;
+	dv_reg		RX4CP;
+	dv_reg		RX5CP;
+	dv_reg		RX6CP;
+	dv_reg		RX7CP;
+} emac_regs;
+
+/* EMAC Wrapper Registers Structure */
+typedef struct  {
+#ifdef DAVINCI_EMAC_VERSION2
+	dv_reg		idver;
+	dv_reg		softrst;
+	dv_reg		emctrl;
+	dv_reg		c0rxthreshen;
+	dv_reg		c0rxen;
+	dv_reg		c0txen;
+	dv_reg		c0miscen;
+	dv_reg		c1rxthreshen;
+	dv_reg		c1rxen;
+	dv_reg		c1txen;
+	dv_reg		c1miscen;
+	dv_reg		c2rxthreshen;
+	dv_reg		c2rxen;
+	dv_reg		c2txen;
+	dv_reg		c2miscen;
+	dv_reg		c0rxthreshstat;
+	dv_reg		c0rxstat;
+	dv_reg		c0txstat;
+	dv_reg		c0miscstat;
+	dv_reg		c1rxthreshstat;
+	dv_reg		c1rxstat;
+	dv_reg		c1txstat;
+	dv_reg		c1miscstat;
+	dv_reg		c2rxthreshstat;
+	dv_reg		c2rxstat;
+	dv_reg		c2txstat;
+	dv_reg		c2miscstat;
+	dv_reg		c0rximax;
+	dv_reg		c0tximax;
+	dv_reg		c1rximax;
+	dv_reg		c1tximax;
+	dv_reg		c2rximax;
+	dv_reg		c2tximax;
+#else
+	u_int8_t	RSVD0[4100];
+	dv_reg		EWCTL;
+	dv_reg		EWINTTCNT;
+#endif
+} ewrap_regs;
+
+/* EMAC MDIO Registers Structure */
+typedef struct  {
+	dv_reg		VERSION;
+	dv_reg		CONTROL;
+	dv_reg		ALIVE;
+	dv_reg		LINK;
+	dv_reg		LINKINTRAW;
+	dv_reg		LINKINTMASKED;
+	u_int8_t	RSVD0[8];
+	dv_reg		USERINTRAW;
+	dv_reg		USERINTMASKED;
+	dv_reg		USERINTMASKSET;
+	dv_reg		USERINTMASKCLEAR;
+	u_int8_t	RSVD1[80];
+	dv_reg		USERACCESS0;
+	dv_reg		USERPHYSEL0;
+	dv_reg		USERACCESS1;
+	dv_reg		USERPHYSEL1;
+} mdio_regs;
+
+int davinci_eth_phy_read(u_int8_t phy_addr, u_int8_t reg_num, u_int16_t *data);
+int davinci_eth_phy_write(u_int8_t phy_addr, u_int8_t reg_num, u_int16_t data);
+void davinci_eth_set_mac_addr(const u_int8_t *addr);
+
+typedef struct
+{
+	char	name[64];
+	int	(*init)(int phy_addr);
+	int	(*is_phy_connected)(int phy_addr);
+	int	(*get_link_speed)(int phy_addr);
+	int	(*auto_negotiate)(int phy_addr);
+} phy_t;
+
+#define PHY_LXT972	(0x001378e2)
+int lxt972_is_phy_connected(int phy_addr);
+int lxt972_get_link_speed(int phy_addr);
+int lxt972_init_phy(int phy_addr);
+int lxt972_auto_negotiate(int phy_addr);
+
+#define PHY_DP83848	(0x20005c90)
+int dp83848_is_phy_connected(int phy_addr);
+int dp83848_get_link_speed(int phy_addr);
+int dp83848_init_phy(int phy_addr);
+int dp83848_auto_negotiate(int phy_addr);
+
+#endif  /* _DM644X_EMAC_H_ */
diff --git a/arch/arm/include/asm/arch-keyasic/emif_defs.h b/arch/arm/include/asm/arch-keyasic/emif_defs.h
new file mode 100644
index 0000000..b48ec17
--- /dev/null
+++ b/arch/arm/include/asm/arch-keyasic/emif_defs.h
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2007 Sergey Kubushyn <ksi@koi8.net>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _EMIF_DEFS_H_
+#define _EMIF_DEFS_H_
+
+#include <asm/arch/hardware.h>
+
+struct davinci_emif_regs {
+	u_int32_t	ercsr;
+	u_int32_t	awccr;
+	u_int32_t	sdbcr;
+	u_int32_t	sdrcr;
+	u_int32_t	ab1cr;
+	u_int32_t	ab2cr;
+	u_int32_t	ab3cr;
+	u_int32_t	ab4cr;
+	u_int32_t	sdtimr;
+	u_int32_t	ddrsr;
+	u_int32_t	ddrphycr;
+	u_int32_t	ddrphysr;
+	u_int32_t	totar;
+	u_int32_t	totactr;
+	u_int32_t	ddrphyid_rev;
+	u_int32_t	sdsretr;
+	u_int32_t	eirr;
+	u_int32_t	eimr;
+	u_int32_t	eimsr;
+	u_int32_t	eimcr;
+	u_int32_t	ioctrlr;
+	u_int32_t	iostatr;
+	u_int8_t	rsvd0[8];
+	u_int32_t	nandfcr;
+	u_int32_t	nandfsr;
+	u_int8_t	rsvd1[8];
+	u_int32_t	nandfecc[4];
+	u_int8_t	rsvd2[60];
+	u_int32_t	nand4biteccload;
+	u_int32_t	nand4bitecc[4];
+	u_int32_t	nanderradd1;
+	u_int32_t	nanderradd2;
+	u_int32_t	nanderrval1;
+	u_int32_t	nanderrval2;
+};
+
+#define davinci_emif_regs \
+	((struct davinci_emif_regs *)DAVINCI_ASYNC_EMIF_CNTRL_BASE)
+
+#define DAVINCI_NANDFCR_NAND_ENABLE(n)			(1 << (n-2))
+#define DAVINCI_NANDFCR_4BIT_ECC_SEL_MASK		(3 << 4)
+#define DAVINCI_NANDFCR_4BIT_ECC_SEL(n)			((n-2) << 4)
+#define DAVINCI_NANDFCR_1BIT_ECC_START(n)		(1 << (8 + (n-2)))
+#define DAVINCI_NANDFCR_4BIT_ECC_START			(1 << 12)
+#define DAVINCI_NANDFCR_4BIT_CALC_START			(1 << 13)
+
+/* Chip Select setup */
+#define DAVINCI_ABCR_STROBE_SELECT			(1 << 31)
+#define DAVINCI_ABCR_EXT_WAIT				(1 << 30)
+#define DAVINCI_ABCR_WSETUP(n)				(n << 26)
+#define DAVINCI_ABCR_WSTROBE(n)				(n << 20)
+#define DAVINCI_ABCR_WHOLD(n)				(n << 17)
+#define DAVINCI_ABCR_RSETUP(n)				(n << 13)
+#define DAVINCI_ABCR_RSTROBE(n)				(n << 7)
+#define DAVINCI_ABCR_RHOLD(n)				(n << 4)
+#define DAVINCI_ABCR_TA(n)				(n << 2)
+#define DAVINCI_ABCR_ASIZE_16BIT			1
+#define DAVINCI_ABCR_ASIZE_8BIT				0
+
+#endif
diff --git a/arch/arm/include/asm/arch-keyasic/gpio_defs.h b/arch/arm/include/asm/arch-keyasic/gpio_defs.h
new file mode 100644
index 0000000..1be2ac2
--- /dev/null
+++ b/arch/arm/include/asm/arch-keyasic/gpio_defs.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2009 Texas Instruments Incorporated
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _GPIO_DEFS_H_
+#define _GPIO_DEFS_H_
+
+#ifndef CONFIG_SOC_DA8XX
+#define DAVINCI_GPIO_BINTEN	0x01C67008
+#define DAVINCI_GPIO_BANK01	0x01C67010
+#define DAVINCI_GPIO_BANK23	0x01C67038
+#define DAVINCI_GPIO_BANK45	0x01C67060
+#define DAVINCI_GPIO_BANK67	0x01C67088
+
+#else /* CONFIG_SOC_DA8XX */
+#define DAVINCI_GPIO_BINTEN	0x01E26008
+#define DAVINCI_GPIO_BANK01	0x01E26010
+#define DAVINCI_GPIO_BANK23	0x01E26038
+#define DAVINCI_GPIO_BANK45	0x01E26060
+#define DAVINCI_GPIO_BANK67	0x01E26088
+#endif /* CONFIG_SOC_DA8XX */
+
+struct davinci_gpio {
+	unsigned int dir;
+	unsigned int out_data;
+	unsigned int set_data;
+	unsigned int clr_data;
+	unsigned int in_data;
+	unsigned int set_rising;
+	unsigned int clr_rising;
+	unsigned int set_falling;
+	unsigned int clr_falling;
+	unsigned int intstat;
+};
+
+struct davinci_gpio_bank {
+	int num_gpio;
+	unsigned int irq_num;
+	unsigned int irq_mask;
+	unsigned long *in_use;
+	unsigned long base;
+};
+
+#define davinci_gpio_bank01 ((struct davinci_gpio *)DAVINCI_GPIO_BANK01)
+#define davinci_gpio_bank23 ((struct davinci_gpio *)DAVINCI_GPIO_BANK23)
+#define davinci_gpio_bank45 ((struct davinci_gpio *)DAVINCI_GPIO_BANK45)
+#define davinci_gpio_bank67 ((struct davinci_gpio *)DAVINCI_GPIO_BANK67)
+
+#endif
diff --git a/arch/arm/include/asm/arch-keyasic/hardware.h b/arch/arm/include/asm/arch-keyasic/hardware.h
new file mode 100644
index 0000000..9276242
--- /dev/null
+++ b/arch/arm/include/asm/arch-keyasic/hardware.h
@@ -0,0 +1,94 @@
+/*
+ *  linux/include/asm-arm/arch-keyasic/hardware.h
+ *
+ *  Copyright (C) 2010 
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <config.h>
+#include <asm/sizes.h>
+
+#define	REG(addr)	(*(volatile unsigned int *)(addr))
+#define REG_P(addr)	((volatile unsigned int *)(addr))
+
+typedef volatile unsigned int	ka_reg;
+typedef volatile unsigned int *	ka_reg_p;
+
+/*
+ * Base register addresses
+ *
+ */
+#define KA_REGIF_BASE               	0xA0000000
+#define KA_SCU_BASE			KA_REGIF_BASE			/* System Control Unit */
+#define KA_SSI_BASE                 	KA_REGIF_BASE + 0x1000
+#define KA_PWM_BASE                 	KA_REGIF_BASE + 0x2000
+#define KA_WDT_BASE                 	KA_REGIF_BASE + 0x3000
+#define KA_UART_BASE                	KA_REGIF_BASE + 0x4000
+#define KA_GPIO0_BASE                	KA_REGIF_BASE + 0x5000
+#define KA_INTC_BASE                 	KA_REGIF_BASE + 0x6000
+#define KA_DMA_BASE			KA_REGIF_BASE + 0x7000
+#define KA_SDRAM_CTRL_BASE           	KA_REGIF_BASE + 0x8000
+#define KA_SDIO_BASE                	KA_REGIF_BASE + 0x9000
+#define KA_SD_SWITCH_BASE           	KA_REGIF_BASE + 0xa000
+#define KA_SD_CTRL_BASE                	KA_REGIF_BASE + 0xb000
+#define KA_GPIO1_BASE                	KA_REGIF_BASE + 0xc000
+//#define KA_I2C_BASE			KA_REGIF_BASE + 0xc000
+#define KA_TIMER0_BASE			(0x01c21400)
+
+/* arch/arm/cpu/arm926ejs/keyasic/rw_support.S */
+extern void word_write(int addr, int data);
+extern int  word_read(int addr);
+extern void hword_write(int addr, int data);
+extern int  hword_read(int addr);
+extern void byte_write(int addr, int data);
+extern int  byte_read(int addr);
+
+/* arch/arm/cpu/arm926ejs/keyasic/ka2000.c */
+void ka_errata_workarounds(void);
+
+/* Clock IDs */
+enum ka_clk_ids {
+	KA_SPI0_CLKID = 2,
+	KA_UART_CLKID = 2,
+	KA_ARM_CLKID = 6,
+	KA_PLLM_CLKID = 0xff,
+	KA_PLLC_CLKID = 0x100,
+	KA_AUXCLK_CLKID = 0x101
+};
+int clk_get(enum ka_clk_ids id);
+
+/* Interrupt controller */
+struct ka_intc_regs {
+	ka_reg	revid;
+};
+#define ka_intc_regs ((struct ka_intc_regs *)KA_INTC_BASE)
+
+/* UART controller*/
+struct ka_uart_ctrl_regs {
+	ka_reg	revid;
+};
+#define ka_uart0_ctrl_regs ((struct ka_uart_ctrl_regs *)KA_UART_BASE)
+
+#endif /* __ASM_ARCH_HARDWARE_H */
diff --git a/arch/arm/include/asm/arch-keyasic/i2c_defs.h b/arch/arm/include/asm/arch-keyasic/i2c_defs.h
new file mode 100644
index 0000000..24cd268
--- /dev/null
+++ b/arch/arm/include/asm/arch-keyasic/i2c_defs.h
@@ -0,0 +1,99 @@
+/*
+ * (C) Copyright 2004
+ * Texas Instruments, <www.ti.com>
+ *
+ * Some changes copyright (C) 2007 Sergey Kubushyn <ksi@koi8.net>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _DAVINCI_I2C_H_
+#define _DAVINCI_I2C_H_
+
+#define I2C_WRITE		0
+#define I2C_READ		1
+
+#ifndef CONFIG_SOC_DA8XX
+#define I2C_BASE		0x01c21000
+#else
+#define I2C_BASE		0x01c22000
+#endif
+
+#define	I2C_OA			(I2C_BASE + 0x00)
+#define I2C_IE			(I2C_BASE + 0x04)
+#define I2C_STAT		(I2C_BASE + 0x08)
+#define I2C_SCLL		(I2C_BASE + 0x0c)
+#define I2C_SCLH		(I2C_BASE + 0x10)
+#define I2C_CNT			(I2C_BASE + 0x14)
+#define I2C_DRR			(I2C_BASE + 0x18)
+#define I2C_SA			(I2C_BASE + 0x1c)
+#define I2C_DXR			(I2C_BASE + 0x20)
+#define I2C_CON			(I2C_BASE + 0x24)
+#define I2C_IV			(I2C_BASE + 0x28)
+#define I2C_PSC			(I2C_BASE + 0x30)
+
+/* I2C masks */
+
+/* I2C Interrupt Enable Register (I2C_IE): */
+#define I2C_IE_SCD_IE	(1 << 5)	/* Stop condition detect interrupt enable */
+#define I2C_IE_XRDY_IE	(1 << 4)	/* Transmit data ready interrupt enable */
+#define I2C_IE_RRDY_IE	(1 << 3)	/* Receive data ready interrupt enable */
+#define I2C_IE_ARDY_IE	(1 << 2)	/* Register access ready interrupt enable */
+#define I2C_IE_NACK_IE	(1 << 1)	/* No acknowledgment interrupt enable */
+#define I2C_IE_AL_IE	(1 << 0)	/* Arbitration lost interrupt enable */
+
+/* I2C Status Register (I2C_STAT): */
+
+#define I2C_STAT_BB	(1 << 12)	/* Bus busy */
+#define I2C_STAT_ROVR	(1 << 11)	/* Receive overrun */
+#define I2C_STAT_XUDF	(1 << 10)	/* Transmit underflow */
+#define I2C_STAT_AAS	(1 << 9)	/* Address as slave */
+#define I2C_STAT_SCD	(1 << 5)	/* Stop condition detect */
+#define I2C_STAT_XRDY	(1 << 4)	/* Transmit data ready */
+#define I2C_STAT_RRDY	(1 << 3)	/* Receive data ready */
+#define I2C_STAT_ARDY	(1 << 2)	/* Register access ready */
+#define I2C_STAT_NACK	(1 << 1)	/* No acknowledgment interrupt enable */
+#define I2C_STAT_AL	(1 << 0)	/* Arbitration lost interrupt enable */
+
+
+/* I2C Interrupt Code Register (I2C_INTCODE): */
+
+#define I2C_INTCODE_MASK	7
+#define I2C_INTCODE_NONE	0
+#define I2C_INTCODE_AL		1	/* Arbitration lost */
+#define I2C_INTCODE_NAK		2	/* No acknowledgement/general call */
+#define I2C_INTCODE_ARDY	3	/* Register access ready */
+#define I2C_INTCODE_RRDY	4	/* Rcv data ready */
+#define I2C_INTCODE_XRDY	5	/* Xmit data ready */
+#define I2C_INTCODE_SCD		6	/* Stop condition detect */
+
+
+/* I2C Configuration Register (I2C_CON): */
+
+#define I2C_CON_EN	(1 << 5)	/* I2C module enable */
+#define I2C_CON_STB	(1 << 4)	/* Start byte mode (master mode only) */
+#define I2C_CON_MST	(1 << 10)	/* Master/slave mode */
+#define I2C_CON_TRX	(1 << 9)	/* Transmitter/receiver mode (master mode only) */
+#define I2C_CON_XA	(1 << 8)	/* Expand address */
+#define I2C_CON_STP	(1 << 11)	/* Stop condition (master mode only) */
+#define I2C_CON_STT	(1 << 13)	/* Start condition (master mode only) */
+#define I2C_CON_FREE	(1 << 14)	/* Free run on emulation */
+
+#define I2C_TIMEOUT	0xffff0000	/* Timeout mask for poll_i2c_irq() */
+
+#endif
diff --git a/arch/arm/include/asm/arch-keyasic/nand_defs.h b/arch/arm/include/asm/arch-keyasic/nand_defs.h
new file mode 100644
index 0000000..10f3a39
--- /dev/null
+++ b/arch/arm/include/asm/arch-keyasic/nand_defs.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2007 Sergey Kubushyn <ksi@koi8.net>
+ *
+ * Parts shamelesly stolen from Linux Kernel source tree.
+ *
+ * ------------------------------------------------------------
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _NAND_DEFS_H_
+#define _NAND_DEFS_H_
+
+#include <asm/arch/hardware.h>
+
+#ifdef CONFIG_SOC_DM646X
+#define	MASK_CLE	0x80000
+#define	MASK_ALE	0x40000
+#else
+#define	MASK_CLE	0x10
+#define	MASK_ALE	0x08
+#endif
+
+#define NAND_READ_START		0x00
+#define NAND_READ_END		0x30
+#define NAND_STATUS		0x70
+
+extern void davinci_nand_init(struct nand_chip *nand);
+
+#endif
diff --git a/arch/arm/include/asm/arch-keyasic/reg_defs.h b/arch/arm/include/asm/arch-keyasic/reg_defs.h
new file mode 100644
index 0000000..9638711
--- /dev/null
+++ b/arch/arm/include/asm/arch-keyasic/reg_defs.h
@@ -0,0 +1,252 @@
+/*
+ *  linux/include/asm-arm/arch-keyasic/reg_defs.h
+ *
+ *  Copyright (C) 2010 
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <asm/arch/hardware.h>
+
+#define CLK_DIV_REG              KA_SCU_BASE + 0x04
+
+//#define SDRAM_BASE               0x00000000 + 0x00200000 
+
+/* scu */
+#define SCU_CLK_SRC_CTL		 KA_SCU_BASE + 0x00
+#define SCU_PLL_FREQ_SEL1	 KA_SCU_BASE + 0x04
+#define SCU_PLL_FREQ_SEL2	 KA_SCU_BASE + 0x08
+#define SCU_SYSTEM_CTL1		 KA_SCU_BASE + 0x0c
+#define SCU_SYSTEM_CTL2		 KA_SCU_BASE + 0x10
+#define SCU_SYSTEM_CTL3		 KA_SCU_BASE + 0x14
+
+/* ssi */
+#define SSI_BASE                 KA_SSI_BASE
+#define SSI_PRE                  SSI_BASE + 0x00
+#define SSI_CON                  SSI_BASE + 0x04
+#define SSI_STA                  SSI_BASE + 0x08
+#define SSI_TDAT                 SSI_BASE + 0x0c
+#define SSI_RDAT                 SSI_BASE + 0x10
+
+/* sdio */
+#define SDIO_BASE                KA_SDIO_BASE
+#define SDIO_CARD_BLOCK_SET_REG  SDIO_BASE  + 0x00
+#define SDIO_CTRL_REG            SDIO_BASE  + 0x04
+#define SDIO_CMD_ARGUMENT_REG    SDIO_BASE  + 0x08
+#define SDIO_SPECIAL_COMMAND_REG SDIO_BASE  + 0x0c
+#define SDIO_STATUS_REG          SDIO_BASE  + 0x10
+#define SDIO_ERROR_ENABLE_REG    SDIO_BASE  + 0x14
+#define SDIO_RESPONSE1_REG       SDIO_BASE  + 0x18
+#define SDIO_RESPONSE2_REG       SDIO_BASE  + 0x1c
+#define SDIO_RESPONSE3_REG       SDIO_BASE  + 0x20
+#define SDIO_RESPONSE4_REG       SDIO_BASE  + 0x24
+#define SDIO_BUF_TRAN_RESP_REG   SDIO_BASE  + 0x28
+#define SDIO_BUF_TRAN_CTRL_REG   SDIO_BASE  + 0x2c
+#define SDIO_DMA_SACH0_REG       SDIO_BASE  + 0x30
+#define SDIO_DMA_TCCH0_REG       SDIO_BASE  + 0x34
+#define SDIO_DMA_CTRCH0_REG      SDIO_BASE  + 0x38
+#define SDIO_reserved            SDIO_BASE  + 0x3c
+#define SDIO_DMA_DACH1_REG       SDIO_BASE  + 0x40
+#define SDIO_DMA_TCCH1_REG       SDIO_BASE  + 0x44
+#define SDIO_DMA_CTRCH1_REG      SDIO_BASE  + 0x48
+#define SDIO_DMA_INTS_REG        SDIO_BASE  + 0x4c
+#define SDIO_DMA_FIFO_STATUS_REG SDIO_BASE  + 0x50
+
+/* pwm */
+#define PWM_BASE                 KA_PWM_BASE
+#define TCFG0                    PWM_BASE + 0x00
+#define TCFG1                    PWM_BASE + 0x04
+#define TCON0                    PWM_BASE + 0x08
+#define TCON1                    PWM_BASE + 0x0c
+#define TCNTB0                   PWM_BASE + 0x10
+#define TCMPB0                   PWM_BASE + 0x14
+#define TCNTO0                   PWM_BASE + 0x18
+#define TCNTB1                   PWM_BASE + 0x40
+#define TCNTO1                   PWM_BASE + 0x44
+#define TCNTB2                   PWM_BASE + 0x48
+#define TCNTO2                   PWM_BASE + 0x4c
+
+/* sd switch */
+#define SDSW_BASE           	 KA_SD_SWITCH_BASE
+#define SDSW_M1_CTRL0	 	 SDSW_BASE + 0x00
+#define SDSW_M2_CTRL0	 	 SDSW_BASE + 0x04
+#define SDSW_M1_STATUS	 	 SDSW_BASE + 0x08
+#define SDSW_M2_STATUS		 SDSW_BASE + 0x0c
+#define SDSW_READ_SWDAT	 	 SDSW_BASE + 0x18
+#define SDSW_SW_CTRL0	 	 SDSW_BASE + 0x1c
+#define SDSW_TEST_REG	 	 SDSW_BASE + 0x20
+#define SDSW_M1_PREV_CMD_REG	 SDSW_BASE + 0x30
+#define SDSW_M1_PREV_ARGU_REG	 SDSW_BASE + 0x34
+#define SDSW_M1_PREV_RSP_REG0	 SDSW_BASE + 0x38
+#define SDSW_M1_PREV_RSP_REG1	 SDSW_BASE + 0x3c
+#define SDSW_M1_CURR_CMD_REG	 SDSW_BASE + 0x40
+#define SDSW_M1_CURR_ARGU_REG	 SDSW_BASE + 0x44
+#define SDSW_M1_CURR_RSP_REG0	 SDSW_BASE + 0x48
+#define SDSW_M1_CURR_RSP_REG1	 SDSW_BASE + 0x4c
+#define SDSW_M1_CURR_RSP_REG2	 SDSW_BASE + 0x50
+#define SDSW_M1_CURR_RSP_REG3	 SDSW_BASE + 0x54
+#define SDSW_M1_CURR_RSP_REG4	 SDSW_BASE + 0x58
+#define SDSW_M1_CMD_FLG_REG0	 SDSW_BASE + 0x5c
+#define SDSW_M1_CMD_CRC_FLG_REG0 SDSW_BASE + 0x60
+#define SDSW_M1_CMD_FLG_REG1     SDSW_BASE + 0x64
+#define SDSW_M1_CMD_CRC_FLG_REG1 SDSW_BASE + 0x68
+#define SDSW_M1_CMD_FLG_REG2     SDSW_BASE + 0x6c
+#define SDSW_M1_CMD_CRC_FLG_REG2 SDSW_BASE + 0x70
+#define SDSW_M1_CMD_FLG_REG3     SDSW_BASE + 0x74
+#define SDSW_M1_CMD_CRC_FLG_REG3 SDSW_BASE + 0x78
+#define SDSW_BOMB_START_ADDR_REG SDSW_BASE + 0x80
+#define SDSW_BOMB_END_ADDR_REG   SDSW_BASE + 0x84
+#define SDSW_BOMB_Flag_ADDR_REG  SDSW_BASE + 0x88
+#define SDSW_M1_CID_REG0         SDSW_BASE + 0x8c
+#define SDSW_M1_CID_REG1         SDSW_BASE + 0x90
+#define SDSW_M1_CID_REG2         SDSW_BASE + 0x94
+#define SDSW_M1_CID_REG3         SDSW_BASE + 0x98
+#define SDSW_M1_RCA_REG          SDSW_BASE + 0x9c
+#define SDSW_M1_DSR_REG          SDSW_BASE + 0xa0
+#define SDSW_M1_CIC_REG          SDSW_BASE + 0xa4
+#define SDSW_M1_CSD_REG0         SDSW_BASE + 0xa8
+#define SDSW_M1_CSD_REG1         SDSW_BASE + 0xac
+#define SDSW_M1_CSD_REG2         SDSW_BASE + 0xb0
+#define SDSW_M1_CSD_REG3         SDSW_BASE + 0xb4
+#define SDSW_M1_CSR_REG          SDSW_BASE + 0xb8
+#define SDSW_M1_BLR_REG          SDSW_BASE + 0xbc
+#define SDSW_M1_EWBS_REG         SDSW_BASE + 0xc0
+#define SDSW_M1_EWBE_REG         SDSW_BASE + 0xc4
+#define SDSW_M1_SBW_REG          SDSW_BASE + 0xc8
+#define SDSW_M1_SWBEC_REG        SDSW_BASE + 0xcc
+#define SDSW_M1_OCR_REG          SDSW_BASE + 0xd0
+#define SDSW_M1_SCCD_REG         SDSW_BASE + 0xd4
+#define SDSW_M1_SSR_REG0         SDSW_BASE + 0xd8
+#define SDSW_M1_SSR_REG1         SDSW_BASE + 0xdc
+#define SDSW_M1_SSR_REG2         SDSW_BASE + 0xe0
+#define SDSW_M1_SSR_REG3         SDSW_BASE + 0xe4
+#define SDSW_M1_SCR_REG0         SDSW_BASE + 0xe8
+#define SDSW_M1_SCR_REG1         SDSW_BASE + 0xec
+#define SDSW_M1_SNWB_REG         SDSW_BASE + 0xf0
+#define SDSW_M1_BLOCK_LEN_REG    SDSW_BASE + 0xf4
+#define SDSW_M1_WDATA_TOUT_REG   SDSW_BASE + 0xf8
+#define SDSW_M1_RDATA_TOUT_REG   SDSW_BASE + 0xfc
+#define SDSW_DIRECT_START_TRANS_REG     SDSW_BASE + 0x100
+#define SDSW_DIRECT_CMD_INDEX_REG       SDSW_BASE + 0x104
+#define SDSW_DIRECT_CMD_ARGU_REG        SDSW_BASE + 0x108
+#define SDSW_DIRECT_CTRL_REG            SDSW_BASE + 0x10c
+#define SDSW_DIRECT_BLOCK_LENGTH_REG    SDSW_BASE + 0x110
+#define SDSW_DIRECT_WRITE_SW_CYCLE_REG  SDSW_BASE + 0x114
+#define SDSW_M1_CMD_FLAG_INTEN_REG0     SDSW_BASE + 0x120
+#define SDSW_M1_CMD_FLAG_INTEN_REG1     SDSW_BASE + 0x124
+#define SDSW_M1_CMD_FLAG_INTEN_REG2     SDSW_BASE + 0x128
+#define SDSW_M1_CMD_FLAG_INTEN_REG3     SDSW_BASE + 0x12c
+
+/* wdt */
+#define WDT_BASE                 KA_WDT_BASE
+#define WDT_CON                  WDT_BASE + 0x00
+#define WDT_DAT                  WDT_BASE + 0x04
+#define WDT_CNT                  WDT_BASE + 0x08
+#define WDT_CON_CONTER_EN        0x20
+
+/* gpio0 */
+#define GPIO0_BASE               KA_GPIO0_BASE		//old:GPIO_BASE
+#define GPIO_OEN                 GPIO0_BASE + 0x00
+#define GPIO_INPUT               GPIO0_BASE + 0x04
+#define GPIO_OUTPUT              GPIO0_BASE + 0x08
+#define GPIO_INT                 GPIO0_BASE + 0x0c
+#define GPIO_INT_CLR0            GPIO0_BASE + 0x10
+#define GPIO_INT_CLR1            GPIO0_BASE + 0x14
+#define GPIO_INT_CLR2            GPIO0_BASE + 0x18
+#define GPIO_INT_CLR3            GPIO0_BASE + 0x1c
+#define GPIO_INT_CLR4            GPIO0_BASE + 0x20
+#define GPIO_INT_CLR5            GPIO0_BASE + 0x24
+#define GPIO_INT_CLR6            GPIO0_BASE + 0x28
+#define GPIO_INT_CLR7            GPIO0_BASE + 0x2c
+
+/* gpio1 */
+#define GPIO1_BASE               KA_GPIO1_BASE
+#define GPO_OEN                  GPIO1_BASE + 0x00
+#define GPI_INPUT                GPIO1_BASE + 0x04
+#define GPO_OUTPUT               GPIO1_BASE + 0x08
+#define GPI_INT                  GPIO1_BASE + 0x0c
+#define GPI_INT_CLR0             GPIO1_BASE + 0x10
+#define GPI_INT_CLR1             GPIO1_BASE + 0x14
+#define GPI_INT_CLR2             GPIO1_BASE + 0x18
+#define GPI_INT_CLR3             GPIO1_BASE + 0x1c
+#define GPI_INT_CLR4             GPIO1_BASE + 0x20
+#define GPI_INT_CLR5             GPIO1_BASE + 0x24
+#define GPI_INT_CLR6             GPIO1_BASE + 0x28
+#define GPI_INT_CLR7             GPIO1_BASE + 0x2c
+
+// sdram base
+#define SDRAM_CTRL_BASE          KA_SDRAM_CTRL_BASE
+
+/* uart */
+#define UART_BASE                KA_UART_BASE
+#define UART_RECV                UART_BASE + 0x00
+#define UART_THR                 UART_BASE + 0x00
+#define UART_INTR                UART_BASE + 0x04
+#define UART_FCR                 UART_BASE + 0x08
+#define UART_IIR                 UART_BASE + 0x08
+#define UART_LCR                 UART_BASE + 0x0c
+#define UART_MCR                 UART_BASE + 0x10
+#define UART_LINE                UART_BASE + 0x14
+#define UART_MSR                 UART_BASE + 0x18
+#define UART_RFST                UART_BASE + 0x1c
+
+/*sd card */
+#define SDR_BASE                  KA_SD_CTRL_BASE
+#define SDR_Card_BLOCK_SET_REG    SDR_BASE + 0x00
+#define SDR_CTRL_REG              SDR_BASE + 0x04
+#define SDR_CMD_ARGUMENT_REG      SDR_BASE + 0x08
+#define SDR_SPECIAL_CTRL_REG      SDR_BASE + 0x0C	//old:SDR_ADDRESS_REG
+#define SDR_STATUS_REG            SDR_BASE + 0x10
+#define SDR_Error_Enable_REG      SDR_BASE + 0x14
+#define SDR_RESPONSE1_REG         SDR_BASE + 0x18
+#define SDR_RESPONSE2_REG         SDR_BASE + 0x1C
+#define SDR_RESPONSE3_REG         SDR_BASE + 0x20
+#define SDR_RESPONSE4_REG         SDR_BASE + 0x24
+#define SDR_DMA_TRAN_RESP_REG     SDR_BASE + 0x28
+#define SDR_BUF_TRAN_CTRL_REG     SDR_BASE + 0x2C
+
+#define SDR_DMA_SACH0_REG         SDR_BASE + 0x30
+#define SDR_DMA_TCCH0_REG         SDR_BASE + 0x34
+#define SDR_DMA_CTRCH0_REG        SDR_BASE + 0x38
+#define SDR_DMA_DACH1_REG         SDR_BASE + 0x40
+#define SDR_DMA_TCCH1_REG         SDR_BASE + 0x44
+#define SDR_DMA_CTRCH1_REG        SDR_BASE + 0x48
+#define SDR_DMA_INTS_REG          SDR_BASE + 0x4C
+#define SDR_DMA_FIFO_STATUS_REG   SDR_BASE + 0x50
+
+/* interrupt controller */
+#define INTC_BASE                 KA_INTC_BASE
+#define INTC_INTSRC1_ADDR         INTC_BASE + 0x00
+#define INTC_INTSRC2_ADDR         INTC_BASE + 0x04
+#define INTC_INTMOD1_ADDR         INTC_BASE + 0x08
+#define INTC_INTMOD2_ADDR         INTC_BASE + 0x0c
+#define INTC_INTMSK1_ADDR         INTC_BASE + 0x10
+#define INTC_INTMSK2_ADDR         INTC_BASE + 0x14
+#define INTC_INTPND1_ADDR         INTC_BASE + 0x18
+#define INTC_INTPND2_ADDR         INTC_BASE + 0x1c
+#define INTC_INTPRT1_ADDR         INTC_BASE + 0x20
+#define INTC_INTPRT2_ADDR         INTC_BASE + 0x24
+#define INTC_INTPRO1_ADDR         INTC_BASE + 0x28
+#define INTC_INTPRO2_ADDR         INTC_BASE + 0x2c
+#define INTC_INTCLR_ADDR          INTC_BASE + 0x30
+#define INTC_INTOFS_ADDR          INTC_BASE + 0x34
+
diff --git a/arch/arm/include/asm/mach-types.h b/arch/arm/include/asm/mach-types.h
index 2d5c3bc..e5600cb 100644
--- a/arch/arm/include/asm/mach-types.h
+++ b/arch/arm/include/asm/mach-types.h
@@ -465,6 +465,7 @@ extern unsigned int __machine_arch_type;
 #define MACH_TYPE_STAMP9G45            2761
 #define MACH_TYPE_CNS3420VB            2776
 #define MACH_TYPE_OMAP4_PANDA          2791
+#define MACH_TYPE_KEYASIC              2793
 #define MACH_TYPE_TI8168EVM            2800
 #define MACH_TYPE_TETON_BGA            2816
 #define MACH_TYPE_EUKREA_CPUIMX25SD    2820
diff --git a/arch/arm/lib/board.c b/arch/arm/lib/board.c
index f1951e8..8d195aa 100644
--- a/arch/arm/lib/board.c
+++ b/arch/arm/lib/board.c
@@ -38,6 +38,8 @@
  * FIQ Stack: 00ebef7c
  */
 
+#define DEBUG
+
 #include <common.h>
 #include <command.h>
 #include <malloc.h>
@@ -124,6 +126,7 @@ static int init_baudrate(void)
 
 static int display_banner(void)
 {
+#ifdef UBOOT_DBG
 	printf("\n\n%s\n\n", version_string);
 	debug("U-Boot code: %08lX -> %08lX  BSS: -> %08lX\n",
 	       _TEXT_BASE,
@@ -135,6 +138,7 @@ static int display_banner(void)
 	debug("IRQ Stack: %08lx\n", IRQ_STACK_START);
 	debug("FIQ Stack: %08lx\n", FIQ_STACK_START);
 #endif
+#endif // UBOOT_DBG
 
 	return (0);
 }
@@ -148,6 +152,7 @@ static int display_banner(void)
  */
 static int display_dram_config(void)
 {
+#if 1
 	int i;
 
 #ifdef DEBUG
@@ -166,7 +171,7 @@ static int display_dram_config(void)
 	puts("DRAM:  ");
 	print_size(size, "\n");
 #endif
-
+#endif
 	return (0);
 }
 
@@ -646,6 +651,8 @@ void board_init_r(gd_t *id, ulong dest_addr)
 	}
 #endif
 
+//	printf("\nStatus %x\n", word_read(0xa000a008));
+
 	/* main_loop() can return to retry autoboot, if so just run it again. */
 	for (;;) {
 		main_loop();
diff --git a/board/keyasic/common/Makefile b/board/keyasic/common/Makefile
new file mode 100644
index 0000000..d96da61
--- /dev/null
+++ b/board/keyasic/common/Makefile
@@ -0,0 +1,52 @@
+#
+# (C) Copyright 2012, Key ASIC Berhad.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+ifneq ($(OBJTREE),$(SRCTREE))
+$(shell mkdir -p $(obj)board/$(VENDOR)/common)
+endif
+
+LIB	= $(obj)lib$(VENDOR).o
+
+COBJS	:= misc.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS) $(SOBJS))
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+# This is for $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/keyasic/common/misc.c b/board/keyasic/common/misc.c
new file mode 100644
index 0000000..1fd20a4
--- /dev/null
+++ b/board/keyasic/common/misc.c
@@ -0,0 +1,28 @@
+/*
+ * Miscelaneous KeyASIC functions.
+ *
+ * Copyright (C) 2012, Key ASIC Berhad.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <common.h>
+#include <asm/arch/hardware.h>
+#include <asm/io.h>
+
+DECLARE_GLOBAL_DATA_PTR;
diff --git a/board/keyasic/ka2000/Makefile b/board/keyasic/ka2000/Makefile
new file mode 100644
index 0000000..ca8af2c
--- /dev/null
+++ b/board/keyasic/ka2000/Makefile
@@ -0,0 +1,49 @@
+#
+# (C) Copyright 2012, Key ASIC Berhad.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+COBJS	:= $(BOARD).o led.o
+SOBJS	:= board_init.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS) $(SOBJS))
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+# This is for $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/keyasic/ka2000/board_init.S b/board/keyasic/ka2000/board_init.S
new file mode 100644
index 0000000..e580ff7
--- /dev/null
+++ b/board/keyasic/ka2000/board_init.S
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2007 Sergey Kubushyn <ksi@koi8.net>
+ *
+ * Board-specific low level initialization code. Called at the very end
+ * of arch/arm/cpu/arm926ejs/keyasic/lowlevel_init.S. Just returns if there is no
+ * initialization required.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+
+.globl	ka_board_init
+ka_board_init:
+
+	mov	pc, lr
diff --git a/board/keyasic/ka2000/config.mk b/board/keyasic/ka2000/config.mk
new file mode 100644
index 0000000..993dd98
--- /dev/null
+++ b/board/keyasic/ka2000/config.mk
@@ -0,0 +1,43 @@
+#
+# (C) Copyright 2002
+# Gary Jennejohn, DENX Software Engineering, <garyj@denx.de>
+# David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+#
+# (C) Copyright 2003
+# Texas Instruments, <www.ti.com>
+# Swaminathan <swami.iyer@ti.com>
+#
+# Davinci EVM board (ARM925EJS) cpu
+# see http://www.ti.com/ for more information on Texas Instruments
+#
+# Davinci EVM has 1 bank of 256 MB DDR RAM
+# Physical Address:
+# 8000'0000 to 9000'0000
+#
+# Copyright (C) 2007 Sergey Kubushyn <ksi@koi8.net>
+#
+# Visioneering Corp. Sonata board (ARM926EJS) cpu
+#
+# Sonata board has 1 bank of 128 MB DDR RAM
+# Physical Address:
+# 8000'0000 to 8800'0000
+#
+# Razorstream, LLC. SCHMOOGIE board (ARM926EJS) cpu
+#
+# Schmoogie board has 1 bank of 128 MB DDR RAM
+# Physical Address:
+# 8000'0000 to 8800'0000
+#
+# Linux-Kernel is expected to be at 8000'8000, entry 8000'8000
+# (mem base + reserved)
+# we load ourself to 8108 '0000
+#
+# Copyright (C) 2012, Key ASIC Berhad.
+#
+# KeyASIC KA2000 board (ARM926EJS) cpu
+#
+# KA2000 board has 1 bank of 32 MB SDRAM
+#
+
+#Provide at least 15MB spacing between us and the Linux Kernel image
+#TEXT_BASE = 0x00F00000
diff --git a/board/keyasic/ka2000/ka2000.c b/board/keyasic/ka2000/ka2000.c
new file mode 100644
index 0000000..2073ebc
--- /dev/null
+++ b/board/keyasic/ka2000/ka2000.c
@@ -0,0 +1,168 @@
+/*
+ * Copyright (C) 2010
+ *
+ * ----------------------------------------------------------------------------
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+ */
+
+#include <common.h>
+#include <asm/arch/reg_defs.h>
+#include <asm/io.h>
+#include <asm/hardware.h>		//for ka_xxx()
+
+#if !defined(CONFIG_FLASH_CFI_DRIVER)
+#include "../common/flash.c"
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/*
+static int null_delay(int n)
+{
+	volatile int i = n;
+	volatile int j = 0;
+	while (i-- > 0)
+		j++;
+	return j;
+}
+*/
+
+//------------------------------------------------------------------------------
+int board_init(void)
+{
+	//printf("board_init\n");
+	/* arch number of the board */
+	gd->bd->bi_arch_number = MACH_TYPE_DAVINCI_EVM;
+
+	/* address of boot parameters */
+	gd->bd->bi_boot_params = 0x0000100; //LINUX_BOOT_PARAM_ADDR;
+
+	/* if workarounds are needed */
+	ka_errata_workarounds();
+
+	/* Disable SSI Clock */
+	word_write(KA_REGIF_BASE, word_read(KA_REGIF_BASE) & 0xffdfffff);
+	//buzzer_off();
+
+	printf("Status %x\n", word_read(SDSW_M1_STATUS));
+
+	/* Enable UART */
+	/*word_write(UART_LCR,  0x83);
+	word_write(UART_INTR, 0x00);
+	word_write(UART_RECV, 0x28);	//baudrate=19200,12MHz
+	word_write(UART_LCR,  0x03); */
+
+	/* Close PLL */
+	/* Power on required peripherals */
+	//timer_init();
+	//word_write(GPIO_OUTPUT, 0x66);
+
+	return(0);
+}
+
+#ifdef CONFIG_MISC_INIT_R
+int misc_init_r(void)
+{
+	//TODO: Placeholder
+	//setenv ("bootcmd", "run set_bootargs; bootm 1ffc00; sf probe 0; sf read 100000 3200 19000; go 19000\0");
+	return(0);
+}
+#endif
+
+#ifdef CONFIG_SYS_PROGRAM_BIN
+void detect_program_files(void);
+#endif
+
+#ifdef BOARD_LATE_INIT
+extern void buzzer_off(void);
+
+int board_late_init (void)
+{
+	u32 v1, v2;
+	//do_remap(0x00000000, 0x01f00000);
+
+	//buzzer_off();
+#ifdef CONFIG_SYS_PROGRAM_BIN
+	detect_program_files();
+	setenv ("bootdelay", "5");
+	setenv ("bootf", "go 208000");
+#else
+	v1 = word_read(0x1ffc00);
+	v2 = word_read(0x208000);
+
+	if (v2 == 0xe1a00000 || v2 == 0xe3a00000)
+		setenv ("bootf", "mmc init; go 208000");
+	else if (v2 == 0x56190527)
+		setenv ("bootf", "mmc init; bootm 208000");
+	else if (v1 == 0xe1a00000 || v1 == 0xe3a00000)
+		setenv ("bootf", "mmc init; go 1ffc00");
+	else if (v1 == 0x56190527)
+		setenv ("bootf", "mmc init; bootm 1ffc00");
+	else {
+		//setenv ("bootf", "mmc init; fatload mmc 1 208000 image; go 208000");
+		setenv ("bootf", "run boot_sd");
+		//buzzer_off();
+	}
+	buzzer_off();
+#endif
+
+#ifdef CONFIG_STAY_AT_UBOOT
+	setenv("bootdelay", "-1");
+#else
+	setenv("bootdelay", "2");
+#endif
+	v1 = word_read(CONFIG_ENV_OFFSET - 0x400);
+	if((v1 == 0x0) || (v1 == 0xffffffff))
+		run_command("saveenv", 0);
+
+	return (0);
+}
+#endif
+
+#if !defined(CONFIG_FLASH_CFI_DRIVER)
+unsigned long flash_init(void)
+{
+	//dummy function: we do not need to init flash
+	return (0);
+}
+#endif
+
+void do_remap(unsigned int src_base, unsigned int dest_base, int length)
+{
+	int i;
+
+	//transfer data
+	for(i = 0; i < length; i++)
+		writel(readl(src_base + i), (dest_base + i));
+
+	//set remap reg to compelete remap
+	word_write(0xa0000010, 0x1);
+	return ;
+}
+
+
+
+int dram_init(void)
+{
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+	/* dram_init must store complete ramsize in gd->ram_size */
+	gd->ram_size = get_ram_size((long *)CONFIG_SYS_SDRAM_BASE,
+			CONFIG_SYS_SDRAM_SIZE);
+
+	return(0);
+}
+
diff --git a/board/keyasic/ka2000/led.c b/board/keyasic/ka2000/led.c
new file mode 100644
index 0000000..4424f14
--- /dev/null
+++ b/board/keyasic/ka2000/led.c
@@ -0,0 +1,31 @@
+/*
+ * (C) Copyright 2010
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/arch/reg_defs.h>
+
+void coloured_LED_init(void)
+{
+	//word_write(GPIO_OUTPUT, 0x00);
+	//word_write(GPIO_OEN, 0xffff);
+	//word_write(GPIO_OUTPUT, 0x88);
+}
diff --git a/boards.cfg b/boards.cfg
index 2d36d83..c968a06 100644
--- a/boards.cfg
+++ b/boards.cfg
@@ -64,6 +64,7 @@ cm41xx                       arm         arm920t     -                   -
 VCMA9                        arm         arm920t     vcma9               mpl            s3c24x0
 smdk2410                     arm         arm920t     -                   samsung        s3c24x0
 omap1510inn                  arm         arm925t     -                   ti
+ka2000                       arm         arm926ejs   -                   keyasic        keyasic
 integratorap_cm926ejs        arm         arm926ejs   integrator          armltd         -           integratorap:CM926EJ_S
 integratorcp_cm926ejs        arm         arm926ejs   integrator          armltd         -           integratorcp:CM924EJ_S
 aspenite                     arm         arm926ejs   -                   Marvell        armada100
diff --git a/common/Makefile b/common/Makefile
index 483eb4d..ce2cbd6 100644
--- a/common/Makefile
+++ b/common/Makefile
@@ -78,7 +78,8 @@ COBJS-$(CONFIG_CMD_SETGETDCR) += cmd_dcr.o
 endif
 ifdef CONFIG_POST
 COBJS-$(CONFIG_CMD_DIAG) += cmd_diag.o
-endif
+endif
+COBJS-$(CONFIG_CMD_CLK) += cmd_clk.o
 COBJS-$(CONFIG_CMD_DISPLAY) += cmd_display.o
 COBJS-$(CONFIG_CMD_DTT) += cmd_dtt.o
 COBJS-$(CONFIG_CMD_ECHO) += cmd_echo.o
diff --git a/common/cmd_boot.c b/common/cmd_boot.c
index a799b33..411646a 100644
--- a/common/cmd_boot.c
+++ b/common/cmd_boot.c
@@ -47,7 +47,7 @@ int do_go (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 
 	addr = simple_strtoul(argv[1], NULL, 16);
 
-	printf ("## Starting application at 0x%08lX ...\n", addr);
+	printf ("go %X\n", (unsigned int)addr);
 
 	/*
 	 * pass address parameter as argv[0] (aka command name),
@@ -56,7 +56,7 @@ int do_go (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	rc = do_go_exec ((void *)addr, argc - 1, argv + 1);
 	if (rc != 0) rcode = 1;
 
-	printf ("## Application terminated, rc = 0x%lX\n", rc);
+	//printf ("## Application terminated, rc = 0x%lX\n", rc);
 	return rcode;
 }
 
diff --git a/common/cmd_bootm.c b/common/cmd_bootm.c
index 45e726a..baf9af8 100644
--- a/common/cmd_bootm.c
+++ b/common/cmd_bootm.c
@@ -429,10 +429,12 @@ static int bootm_load_os(image_info_t os, ulong *load_end, int boot_progress)
 	bootstage_mark(BOOTSTAGE_ID_KERNEL_LOADED);
 
 	if (!no_overlap && (load < blob_end) && (*load_end > blob_start)) {
+#if 0 // KA disabled.
 		debug("images.os.start = 0x%lX, images.os.end = 0x%lx\n",
 			blob_start, blob_end);
 		debug("images.os.load = 0x%lx, load_end = 0x%lx\n", load,
 			*load_end);
+#endif // KA disabled.
 
 		return BOOTM_ERR_OVERLAP;
 	}
@@ -845,7 +847,7 @@ static void *boot_get_kernel(cmd_tbl_t *cmdtp, int flag, int argc,
 	int		cfg_noffset;
 	int		os_noffset;
 #endif
-
+	//printf("boot_get_kernel arg %d\n", argc);
 	/* find out kernel image address */
 	if (argc < 2) {
 		img_addr = load_addr;
diff --git a/common/cmd_clk.c b/common/cmd_clk.c
new file mode 100644
index 0000000..999cb4b
--- /dev/null
+++ b/common/cmd_clk.c
@@ -0,0 +1,91 @@
+/*
+ * (C) Copyright 2011
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Chanage clock speed support
+ */
+#include <common.h>
+#include <command.h>
+#include <clk.h>
+
+
+
+int do_clk (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+	clk_speed_t *clkspeed;
+
+	if (argc < 2) {
+		cmd_usage(cmdtp);
+		return 1;
+	}
+
+	if (strcmp(argv[1], "set") == 0) {
+	    int pllclk = 192;
+	    int armclk = 192;
+	    int hclk = 96;
+	    int sdclk = 48;
+
+	    clkspeed = clk_get_dev();
+
+        clkspeed->baudrate = CONFIG_BAUDRATE;
+	    clkspeed->osc_clk = (int)simple_strtoul(argv[2], NULL, 10);
+	    if (argc >= 3)
+	        pllclk = (int)simple_strtoul(argv[3], NULL, 10);
+        if (argc >= 4)
+            armclk = (int)simple_strtoul(argv[4], NULL, 10);
+        if (argc >= 5)
+            hclk = (int)simple_strtoul(argv[5], NULL, 10);
+        if (argc >= 6)
+            sdclk = (int)simple_strtoul(argv[6], NULL, 10);
+
+	    u32 n = clkspeed->set_clock_speed(pllclk, armclk, hclk, sdclk);
+
+		printf("\nSet clock speed to:\nPLL:\t%dMHz\nARM:\t%dMHz\nHCLK:\t%dMHz\nSD:\t%dMHz\nSDIO:\t%dMHz ... ",
+			clkspeed->pllclk, clkspeed->armclk, clkspeed->hclk, clkspeed->sdclk, clkspeed->sdioclk);
+
+		printf("%s\n", n ? "ERROR" : "OK");
+		return n;
+	} else if (strcmp(argv[1], "get") == 0) {
+	    clkspeed = clk_get_dev();
+	    clkspeed->osc_clk = (int)simple_strtoul(argv[2], NULL, 10);
+	    u32 n = clkspeed->get_clock_speed();
+
+		printf("\nGet current clock speed:\nPLL:\t%dMHz\nARM:\t%dMHz\nHCLK:\t%dMHz\nSD:\t%dMHz\nSDIO:\t%dMHz ... ",
+			clkspeed->pllclk, clkspeed->armclk, clkspeed->hclk, clkspeed->sdclk, clkspeed->sdioclk);
+
+		printf("%s\n", n ? "ERROR" : "OK");
+		return n;
+	} else {
+		cmd_usage(cmdtp);
+		return 1;
+	}
+
+	return 0;
+}
+/***************************************************/
+
+U_BOOT_CMD(
+	clk,	CONFIG_SYS_MAXARGS,	1,	do_clk,
+	"Clock Speed",
+	"set <osc> <pll> <arm> <hclk> <sd/sdio>\n"
+	"get <osc>\n"
+);
diff --git a/common/cmd_mem.c b/common/cmd_mem.c
index 18f0a3f..ddf8257 100644
--- a/common/cmd_mem.c
+++ b/common/cmd_mem.c
@@ -470,6 +470,8 @@ int do_mem_loop (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	/* Length is the number of objects, not number of bytes.
 	*/
 	length = simple_strtoul(argv[2], NULL, 16);
+	printf("mem_loop: sz %x addr %x, len %x\n", size, (unsigned int)addr,
+		(unsigned int)length);
 
 	/* We want to optimize the loops to run as fast as possible.
 	 * If we have only one object, just run infinite loops.
@@ -477,40 +479,70 @@ int do_mem_loop (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	if (length == 1) {
 		if (size == 4) {
 			longp = (uint *)addr;
-			for (;;)
-				i = *longp;
+			for (;;) {
+				//i = *longp;
+				print_buffer(longp, (void*)longp, size, length, DISP_LINE_LEN/size);
+				if (ctrlc())
+					return 1;
+			}
 		}
 		if (size == 2) {
 			shortp = (ushort *)addr;
-			for (;;)
-				i = *shortp;
+			for (;;) {
+				//i = *shortp;
+				print_buffer(shortp, (void*)shortp, size, length, DISP_LINE_LEN/size);
+				if (ctrlc())
+					return 1;
+			}
 		}
 		cp = (u_char *)addr;
-		for (;;)
-			i = *cp;
+		for (;;) {
+			//i = *cp;
+			print_buffer(cp, (void*)cp, size, length, DISP_LINE_LEN/size);
+			if (ctrlc())
+				return 1;
+		}
 	}
 
 	if (size == 4) {
 		for (;;) {
 			longp = (uint *)addr;
-			i = length;
-			while (i-- > 0)
-				*longp++;
+			//i = length;
+			//while (i-- > 0)
+			{
+				//junk = *longp++;
+				print_buffer(longp, (void*)longp, size, length, DISP_LINE_LEN/size);
+				longp += size/* *length*/;
+				if (ctrlc()) {
+					printf("abort\n");
+					return 1;
+				}
+			}
 		}
 	}
 	if (size == 2) {
 		for (;;) {
 			shortp = (ushort *)addr;
 			i = length;
-			while (i-- > 0)
-				*shortp++;
+			while (i-- > 0) {
+				//junk = *shortp++;
+				print_buffer(shortp, (void*)shortp, size, length, DISP_LINE_LEN/size);
+				shortp += size*length;
+				if (ctrlc())
+					return 1;
+			}
 		}
 	}
 	for (;;) {
 		cp = (u_char *)addr;
 		i = length;
-		while (i-- > 0)
-			*cp++;
+		while (i-- > 0) {
+			//junk = *cp++;
+			print_buffer(cp, (void*)cp, size, length, DISP_LINE_LEN/size);
+			cp += size*length;
+			if (ctrlc())
+				return 1;
+		}
 	}
 }
 
diff --git a/common/cmd_mmc.c b/common/cmd_mmc.c
index 750509d..e91dba6 100644
--- a/common/cmd_mmc.c
+++ b/common/cmd_mmc.c
@@ -51,8 +51,12 @@ int do_mmc (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 			return 1;
 		}
 
-		curr_device = dev;
-		printf("mmc%d is available\n", curr_device);
+		curr_device = dev;
+#ifdef KA2000_DEBUG
+		printf("mmc%d is available\n", curr_device);
+#else
+		printf("<mmc1>\n");
+#endif
 	} else if (strcmp(argv[1], "device") == 0) {
 		if (argc == 2) {
 			if (curr_device < 0) {
@@ -72,6 +76,89 @@ int do_mmc (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 		}
 
 		printf("mmc%d is current device\n", curr_device);
+	} else if (strcmp(argv[1], "read") == 0) {
+		if (argc < 5) {
+			cmd_usage(cmdtp);
+			return 1;
+		}
+		int dev = simple_strtoul(argv[2], NULL, 10);
+		void *addr = (void *)simple_strtoul(argv[3], NULL, 16);
+		u32 cnt = simple_strtoul(argv[5], NULL, 16);
+		if(cnt <= 0) cnt = 1;
+		u32 n;
+		u32 blk = simple_strtoul(argv[4], NULL, 16);
+		block_dev_desc_t *mmc;
+
+		if (mmc_legacy_init(dev) != 0) {
+			puts("No MMC card found\n");
+			return 1;
+		}
+
+		mmc = mmc_get_dev(dev);
+		n = mmc->block_read(dev, blk, cnt, (ulong *)addr);
+
+		printf("\nMMC read: dev%d, blk %d, blkcnt %d ... ",
+			dev, blk, cnt);
+
+		//n = mmc->block_read(dev, blk, cnt, addr);
+
+		/* flush cache after read */
+		flush_cache((ulong)addr, cnt * 512); /* FIXME */
+
+		printf("%d blocks read: %s\n",
+			n, (n==cnt) ? "OK" : "ERROR");
+		return (n == cnt) ? 0 : 1;
+	} else if (strcmp(argv[1], "write") == 0) {
+		if (argc < 5) {
+			cmd_usage(cmdtp);
+			return 1;
+		}
+		int dev = simple_strtoul(argv[2], NULL, 10);
+		void *addr = (void *)simple_strtoul(argv[3], NULL, 16);
+		u32 cnt = simple_strtoul(argv[5], NULL, 16);
+		if(cnt <= 0) cnt = 1;
+		u32 n;
+		u32 blk = simple_strtoul(argv[4], NULL, 16);
+		block_dev_desc_t *mmc;
+
+		if (mmc_legacy_init(dev) != 0) {
+			puts("No MMC card found\n");
+			return 1;
+		}
+
+		mmc = mmc_get_dev(dev);
+		n = mmc->block_write(dev, blk, cnt, (ulong *)addr);
+
+		printf("\nMMC write: dev%d, blk %d, blkcnt %d ... ",
+			dev, blk, cnt);
+
+		printf("%d blocks write: %s\n",
+			n, (n==cnt) ? "OK" : "ERROR");
+		return (n == cnt) ? 0 : 1;
+	} else if (strcmp(argv[1], "cmd") == 0) {
+		if (argc < 5) {
+			cmd_usage(cmdtp);
+			return 1;
+		}
+		int dev = simple_strtoul(argv[2], NULL, 10);
+		u8 cmd = (u8)simple_strtoul(argv[3], NULL, 10);
+		u32 cmdarg = simple_strtoul(argv[4], NULL, 16);
+		u32 ctrl = simple_strtoul(argv[5], NULL, 16);
+		void *addr = (void *)simple_strtoul(argv[6], NULL, 16);
+		block_dev_desc_t *mmc;
+
+		if (mmc_legacy_init(dev) != 0) {
+			puts("No MMC card found\n");
+			return 1;
+		}
+
+		mmc = mmc_get_dev(dev);
+		u32 n = mmc->sd_cmd(dev, cmd, cmdarg, ctrl, (ulong *)addr);
+
+//		if(n != 0)
+//			printf("MMC send SD CMD%d ARG:%08x .. ", cmd, cmdarg);
+		printf("..%s\n", n ? "ERROR" : "OK");
+		return n;
 	} else {
 		return CMD_RET_USAGE;
 	}
@@ -80,10 +167,14 @@ int do_mmc (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 }
 
 U_BOOT_CMD(
-	mmc, 3, 1, do_mmc,
+	mmc, 7, 1, do_mmc,
 	"MMC sub-system",
 	"init [dev] - init MMC sub system\n"
-	"mmc device [dev] - show or set current device"
+	//"mmc device [dev] - show or set current device\n"
+	"read <dev> <dest addr> <sd blk#> <cnt>\n"
+	"write <dev> <src addr> <sd blk#> <cnt>\n"
+	"cmd <dev> <cmd> <arg> <ctrl> [addr]\n"
+
 );
 #else /* !CONFIG_GENERIC_MMC */
 
diff --git a/common/cmd_sf.c b/common/cmd_sf.c
index 9c76464..75c7434 100644
--- a/common/cmd_sf.c
+++ b/common/cmd_sf.c
@@ -112,6 +112,11 @@ static int do_spi_flash_probe(int argc, char * const argv[])
 		spi_flash_free(flash);
 	flash = new;
 
+#ifdef KA2000_DEBUG
+	printf("%u KiB %s at %u:%u is now current device\n",
+			flash->size >> 10, flash->name, bus, cs);
+#endif
+
 	return 0;
 }
 
diff --git a/common/env_common.c b/common/env_common.c
index d9e990d..158b5f2 100644
--- a/common/env_common.c
+++ b/common/env_common.c
@@ -189,7 +189,9 @@ void set_default_env(const char *s)
 			puts(s);
 		}
 	} else {
+#if 0 // KA disabled log
 		puts("Using default environment\n\n");
+#endif // KA disabled log
 	}
 
 	if (himport_r(&env_htab, (char *)default_environment,
diff --git a/common/image.c b/common/image.c
index 91954ac..4156ce2 100644
--- a/common/image.c
+++ b/common/image.c
@@ -185,11 +185,15 @@ int image_check_hcrc(const image_header_t *hdr)
 
 int image_check_dcrc(const image_header_t *hdr)
 {
+#if 1 // KA patch
+	return 1;
+#else // Orig
 	ulong data = image_get_data(hdr);
 	ulong len = image_get_data_size(hdr);
 	ulong dcrc = crc32_wd(0, (unsigned char *)data, len, CHUNKSZ_CRC32);
 
 	return (dcrc == image_get_dcrc(hdr));
+#endif // KA patch
 }
 
 /**
@@ -478,8 +482,8 @@ phys_size_t getenv_bootm_mapsize(void)
 
 void memmove_wd(void *to, void *from, size_t len, ulong chunksz)
 {
-	if (to == from)
-		return;
+	if (to == from)
+		return;
 
 #if defined(CONFIG_HW_WATCHDOG) || defined(CONFIG_WATCHDOG)
 	while (len > 0) {
@@ -1031,6 +1035,7 @@ int boot_get_ramdisk(int argc, char * const argv[], bootm_headers_t *images,
 		rd_len = rd_data = 0;
 	}
 
+#if 0 // Orig
 	if (!rd_data) {
 		debug("## No init Ramdisk\n");
 	} else {
@@ -1039,6 +1044,16 @@ int boot_get_ramdisk(int argc, char * const argv[], bootm_headers_t *images,
 	}
 	debug("   ramdisk start = 0x%08lx, ramdisk end = 0x%08lx\n",
 			*rd_start, *rd_end);
+#else // KA patch
+	if (!rd_data) {
+//		debug("## No init Ramdisk\n");
+	} else {
+		*rd_start = rd_data;
+		*rd_end = rd_data + rd_len;
+		debug("   ramdisk start = 0x%08lx, ramdisk end = 0x%08lx\n",
+			*rd_start, *rd_end);
+	}
+#endif // KA patch
 
 	return 0;
 }
diff --git a/common/main.c b/common/main.c
index a933357..965647c 100644
--- a/common/main.c
+++ b/common/main.c
@@ -83,6 +83,19 @@ int do_mdm_init = 0;
 extern void mdm_init(void); /* defined in board.c */
 #endif
 
+extern void buzzer_off(void);
+
+static __inline__ int null_delay(int t)
+{
+	volatile int i = 0;
+	volatile int j = 0;
+	for (i = 0; i < t; i++)
+	{
+		//for (j = 0; j < 1; j++);
+		j++;
+	}
+	return j;
+}
 /***************************************************************************
  * Watch for 'delay' seconds for autoboot stop or autoboot delay string.
  * returns: 0 -  no key string, allow autoboot 1 - got key string, abort
@@ -249,10 +262,13 @@ int abortboot(int bootdelay)
 # endif
 				break;
 			}
-			udelay(10000);
+			//udelay(10000);
+			null_delay(100);
 		}
-
-		printf("\b\b\b%2d ", bootdelay);
+		putc(0x8);
+		putc(0x8);
+		printf("%2d", bootdelay);
+		//printf("\b\b\b%2d ", bootdelay);
 	}
 
 	putc('\n');
@@ -262,6 +278,8 @@ int abortboot(int bootdelay)
 		gd->flags &= ~GD_FLG_SILENT;
 #endif
 
+	if (abort)
+		buzzer_off();
 	return abort;
 }
 # endif	/* CONFIG_AUTOBOOT_KEYED */
@@ -349,7 +367,7 @@ void main_loop (void)
 	s = getenv ("bootdelay");
 	bootdelay = s ? (int)simple_strtol(s, NULL, 10) : CONFIG_BOOTDELAY;
 
-	debug ("### main_loop entered: bootdelay=%d\n\n", bootdelay);
+	//debug ("### main_loop entered: bootdelay=%d\n\n", bootdelay);
 
 #if defined(CONFIG_MENU_SHOW)
 	bootdelay = menu_show(bootdelay);
@@ -373,8 +391,11 @@ void main_loop (void)
 	else
 #endif /* CONFIG_BOOTCOUNT_LIMIT */
 		s = getenv ("bootcmd");
-
-	debug ("### main_loop: bootcmd=\"%s\"\n", s ? s : "<UNDEFINED>");
+		if (bootdelay == 0)
+		{
+			run_command (s, 0);
+		}
+	//debug ("### main_loop: bootcmd=\"%s\"\n", s ? s : "<UNDEFINED>");
 
 	if (bootdelay >= 0 && s && !abortboot (bootdelay)) {
 # ifdef CONFIG_AUTOBOOT_KEYED
@@ -397,6 +418,8 @@ void main_loop (void)
 #endif /* CONFIG_MENUKEY */
 #endif /* CONFIG_BOOTDELAY */
 
+	buzzer_off();
+
 	/*
 	 * Main Loop for Monitor Command Processing
 	 */
@@ -414,7 +437,10 @@ void main_loop (void)
 			reset_cmd_timeout();
 		}
 #endif
+		//puts ("Jump to offset 0x40000\n");
+		//goto_offset();
 		len = readline (CONFIG_SYS_PROMPT);
+		//puts ("rl out\n");
 
 		flag = 0;	/* assume no special flags for now */
 		if (len > 0)
@@ -962,6 +988,7 @@ int readline_into_buffer(const char *const prompt, char *buffer, int timeout)
 	col = plen;
 
 	for (;;) {
+		//printf ("\nn=%d\n", n);
 #ifdef CONFIG_BOOT_RETRY_TIME
 		while (!tstc()) {	/* while no incoming data */
 			if (retry_time >= 0 && get_ticks() > endtime)
diff --git a/config.mk b/config.mk
index 3dcea6a..04073e5 100644
--- a/config.mk
+++ b/config.mk
@@ -181,7 +181,7 @@ endif
 # who are porting old code to latest mainline but not updating $(AR).
 ARFLAGS = $(error update your Makefile to use cmd_link_o_target and not AR)
 RELFLAGS= $(PLATFORM_RELFLAGS)
-DBGFLAGS= -g # -DDEBUG
+DBGFLAGS= -g0 # -DDEBUG
 OPTFLAGS= -Os #-fomit-frame-pointer
 
 OBJCFLAGS += --gap-fill=0xff
diff --git a/drivers/mtd/spi/spi_flash.c b/drivers/mtd/spi/spi_flash.c
index f689cc4..a941f14 100644
--- a/drivers/mtd/spi/spi_flash.c
+++ b/drivers/mtd/spi/spi_flash.c
@@ -240,6 +240,10 @@ int spi_flash_cmd_erase(struct spi_flash *flash, u8 erase_cmd,
 	return ret;
 }
 
+#ifdef CONFIG_SPI_FLASH_KA2000
+extern struct spi_flash *spi_flash_probe_ka2000(struct spi_slave *spi, u8 *idcode);
+#endif // CONFIG_SPI_FLASH_KA2000
+
 /*
  * The following table holds all device probe functions
  *
@@ -303,6 +307,10 @@ static const struct {
 #ifdef CONFIG_SPI_FRAM_RAMTRON_NON_JEDEC
 	{ 0, 0xff, spi_fram_probe_ramtron, },
 #endif
+#ifdef CONFIG_SPI_FLASH_KA2000
+	{ 0, 0x40, spi_flash_probe_ka2000, },
+	{ 0, 0xBF, spi_flash_probe_ka2000, },
+#endif // CONFIG_SPI_FLASH_KA2000
 };
 #define IDCODE_LEN (IDCODE_CONT_LEN + IDCODE_PART_LEN)
 
@@ -311,8 +319,13 @@ struct spi_flash *spi_flash_probe(unsigned int bus, unsigned int cs,
 {
 	struct spi_slave *spi;
 	struct spi_flash *flash = NULL;
-	int ret, i, shift;
-	u8 idcode[IDCODE_LEN], *idp;
+	int ret;
+	u8 idcode[IDCODE_LEN];
+#ifndef CONFIG_SPI_FLASH_KA2000
+	int i;
+	int shift;
+	u8 *idp;
+#endif // CONFIG_SPI_FLASH_KA2000
 
 	spi = spi_setup_slave(bus, cs, max_hz, spi_mode);
 	if (!spi) {
@@ -326,6 +339,18 @@ struct spi_flash *spi_flash_probe(unsigned int bus, unsigned int cs,
 		goto err_claim_bus;
 	}
 
+#ifdef CONFIG_SPI_FLASH_KA2000
+
+	flash = spi_flash_probe_ka2000(spi, idcode);
+	spi_release_bus(spi);
+
+	return flash;
+err_claim_bus:
+	spi_free_slave(spi);
+	return NULL;
+
+#else
+
 	/* Read the ID codes */
 	ret = spi_flash_cmd(spi, CMD_READ_ID, idcode, sizeof(idcode));
 	if (ret)
@@ -370,6 +395,7 @@ err_read_id:
 err_claim_bus:
 	spi_free_slave(spi);
 	return NULL;
+#endif
 }
 
 void spi_flash_free(struct spi_flash *flash)
diff --git a/drivers/serial/ns16550.c b/drivers/serial/ns16550.c
index 0c23955..f65d0c8 100644
--- a/drivers/serial/ns16550.c
+++ b/drivers/serial/ns16550.c
@@ -64,27 +64,47 @@ void NS16550_init(NS16550_t com_port, int baud_divisor)
 #endif /* CONFIG_OMAP */
 }
 
+int null_delay(int n)
+{
+	volatile int i = n/2;
+	int j = 0;
+	while (i-- > 0)
+		j++;
+	return j;
+}
 #ifndef CONFIG_NS16550_MIN_FUNCTIONS
 void NS16550_reinit(NS16550_t com_port, int baud_divisor)
 {
 	serial_out(CONFIG_SYS_NS16550_IER, &com_port->ier);
+	null_delay(10);
 	serial_out(UART_LCR_BKSE | UART_LCRVAL, &com_port->lcr);
+	null_delay(10);
 	serial_out(0, &com_port->dll);
+	null_delay(10);
 	serial_out(0, &com_port->dlm);
+	null_delay(10);
 	serial_out(UART_LCRVAL, &com_port->lcr);
+	null_delay(10);
 	serial_out(UART_MCRVAL, &com_port->mcr);
+	null_delay(10);
 	serial_out(UART_FCRVAL, &com_port->fcr);
+	null_delay(10);
 	serial_out(UART_LCR_BKSE, &com_port->lcr);
+	null_delay(10);
 	serial_out(baud_divisor & 0xff, &com_port->dll);
+	null_delay(10);
 	serial_out((baud_divisor >> 8) & 0xff, &com_port->dlm);
+	null_delay(10);
 	serial_out(UART_LCRVAL, &com_port->lcr);
+	null_delay(10);
 }
 #endif /* CONFIG_NS16550_MIN_FUNCTIONS */
 
 void NS16550_putc(NS16550_t com_port, char c)
 {
+	int time_out = 10000;
 	while ((serial_in(&com_port->lsr) & UART_LSR_THRE) == 0)
-		;
+		if (time_out-- <= 0) break;
 	serial_out(c, &com_port->thr);
 
 	/*
@@ -100,7 +120,9 @@ void NS16550_putc(NS16550_t com_port, char c)
 #ifndef CONFIG_NS16550_MIN_FUNCTIONS
 char NS16550_getc(NS16550_t com_port)
 {
+	volatile int time_out = 100000;
 	while ((serial_in(&com_port->lsr) & UART_LSR_DR) == 0) {
+		if (time_out-- <= 0) return 0;
 #ifdef CONFIG_USB_TTY
 		extern void usbtty_poll(void);
 		usbtty_poll();
diff --git a/drivers/serial/serial.c b/drivers/serial/serial.c
index 0d6ad62..6b4551a 100644
--- a/drivers/serial/serial.c
+++ b/drivers/serial/serial.c
@@ -32,7 +32,7 @@
 #if defined (CONFIG_SERIAL_MULTI)
 #include <serial.h>
 #endif
-
+
 DECLARE_GLOBAL_DATA_PTR;
 
 #if !defined(CONFIG_CONS_INDEX)
diff --git a/drivers/spi/ka2000_spi.c b/drivers/spi/ka2000_spi.c
new file mode 100644
index 0000000..516d45c
--- /dev/null
+++ b/drivers/spi/ka2000_spi.c
@@ -0,0 +1,85 @@
+#include <common.h>
+#include <asm/io.h>
+#include <malloc.h>
+#include <spi.h>
+#include <ka2000.h>
+
+void spi_init(void)
+{
+	struct ka2000_spi *spi = (struct ka2000_spi *)ka2000_SPI;
+	/*
+	 * Its important to use the correct order when initializing the
+	 * registers
+	 */
+	out_8(&spi->ddr, 0x0F);	/* set all SPI pins as output */
+	out_8(&spi->pdr, 0x00);	/* set SS low */
+	/* SPI is master, SS is general purpose output */
+	out_8(&spi->cr1, SPI_CR_MSTR | SPI_CR_SPE);
+	out_8(&spi->cr2, 0x00);	/* normal operation */
+	out_8(&spi->brr, 0x77);	/* baud rate: IPB clock / 2048 */
+}
+
+struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
+				  unsigned int max_hz, unsigned int mode)
+{
+	struct spi_slave *slave;
+
+	slave = malloc(sizeof(struct spi_slave));
+	if (!slave)
+		return NULL;
+
+	slave->bus = bus;
+	slave->cs = cs;
+
+	return slave;
+}
+
+void spi_free_slave(struct spi_slave *slave)
+{
+	free(slave);
+}
+
+int spi_claim_bus(struct spi_slave *slave)
+{
+	return 0;
+}
+
+void spi_release_bus(struct spi_slave *slave)
+{
+	return;
+}
+
+int spi_xfer(struct spi_slave *slave, unsigned int bitlen, const void *dout,
+	     void *din, unsigned long flags)
+{
+	struct ka2000_spi *spi = (struct ka2000_spi *)ka2000_SPI;
+	int i, iter = bitlen >> 3;
+	const uchar *txp = dout;
+	uchar *rxp = din;
+
+	debug("spi_xfer: slave %u:%u dout %08X din %08X bitlen %u\n",
+	      slave->bus, slave->cs, *(uint *) dout, *(uint *) din, bitlen);
+
+	if (flags & SPI_XFER_BEGIN)
+		setbits_8(&spi->pdr, SPI_PDR_SS);
+
+	for (i = 0; i < iter; i++) {
+		udelay(1000);
+		debug("spi_xfer: sending %x\n", txp[i]);
+		out_8(&spi->dr, txp[i]);
+		while (!(in_8(&spi->sr) & SPI_SR_SPIF)) {
+			udelay(1000);
+			if (in_8(&spi->sr) & SPI_SR_WCOL) {
+				rxp[i] = in_8(&spi->dr);
+				puts("spi_xfer: write collision\n");
+				return -1;
+			}
+		}
+		rxp[i] = in_8(&spi->dr);
+		debug("spi_xfer: received %x\n", rxp[i]);
+	}
+	if (flags & SPI_XFER_END)
+		clrbits_8(&spi->pdr, SPI_PDR_SS);
+
+	return 0;
+}
diff --git a/include/clk.h b/include/clk.h
new file mode 100644
index 0000000..5258c29
--- /dev/null
+++ b/include/clk.h
@@ -0,0 +1,46 @@
+/*
+ * (C) Copyright 2000-2004
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _CLK_H
+#define _CLK_H
+
+typedef struct clk_speed {
+	int	osc_clk;
+	int	pllclk;
+	int	armclk;
+	int	hclk;
+	int	sdclk;
+	int	sdioclk;
+	int	baudrate;
+	unsigned long	(*set_clock_speed)(
+				      int pllclk,
+				      int armclk,
+				      int hclk,
+				      int sdclk);
+	unsigned long	(*get_clock_speed)(void);
+	void		*priv;		/* driver private struct pointer */
+}clk_speed_t;
+
+/* functions */
+clk_speed_t* clk_get_dev(void);
+
+#endif /* _CLK_H */
diff --git a/include/common.h b/include/common.h
index 39859d3..180eda4 100644
--- a/include/common.h
+++ b/include/common.h
@@ -116,6 +116,7 @@ typedef volatile unsigned char	vu_char;
 #include <flash.h>
 #include <image.h>
 
+
 #ifdef DEBUG
 #define _DEBUG	1
 #else
diff --git a/include/configs/ka2000.h b/include/configs/ka2000.h
new file mode 100644
index 0000000..347e19b
--- /dev/null
+++ b/include/configs/ka2000.h
@@ -0,0 +1,313 @@
+/*
+ * (C) Copyright 2010
+ *
+ * Configuation settings for the KEYASIC KA2000 board.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*-----------------------------------------------------------------------
+ * CPU, Board, SoC Configuration Options
+ */
+#define CONFIG_ARM926EJS                    1                           /*ARM926EJS CPU Core */
+#define CONFIG_SOC_KA2000                   1                           /*KeyAsic KA2000 SoC */
+#define CONFIG_KA2000EVM                    1                           /*Board type*/
+
+#define CONFIG_SYS_CONSOLE_INFO_QUIET 1
+//#define CONFIG_SYS_RESISTOR
+
+//#define CONFIG_SYS_PROGRAM_BIN
+//#define CONFIG_SYS_ALLOW_PROGRAM_AUTOLOAD_TABLE
+//#define CONFIG_SYS_ALLOW_PROGRAM_BOOTLOADER
+//#define CONFIG_SYS_ALLOW_PROGRAM_UBOOT
+//#define CONFIG_SYS_FPGA
+//#define CONFIG_STAY_AT_UBOOT
+#define CONFIG_SYS_VER              4
+/*-----------------------------------------------------------------------
+ * Clock, Timer
+ */
+#ifndef CONFIG_SYS_FPGA
+#define OSC 24
+#if 0
+#define CONFIG_SET_CLOCK 0
+#define CONFIG_SYS_CLK_FREQ                 240000000                                   /*ARM clock freq, input clock of PLL */
+#else
+#define CONFIG_SET_CLOCK 1
+#define CONFIG_SYS_CLK_FREQ                 192000000                                   /*ARM clock freq, input clock of PLL */
+#endif
+#define CONFIG_SYS_HZ_CLOCK                 24000000                                    /*Timer input clock freq (timer.c) */
+#define CONFIG_HCLK_RATIO           2
+#define CONFIG_SYS_UART_CLK                 (CONFIG_SYS_CLK_FREQ / CONFIG_HCLK_RATIO)   //(CONFIG_SYS_CLK_FREQ/2)
+
+#else
+#define OSC 12
+#define CONFIG_SET_CLOCK 1                                              //0
+#define CONFIG_SYS_CLK_FREQ                 12000000                    /*ARM clock freq, input clock of PLL */
+#define CONFIG_SYS_HZ_CLOCK                 12000000                    /*Timer input clock freq (timer.c) */
+#define CONFIG_HCLK_RATIO           1
+#define CONFIG_SYS_UART_CLK                 (CONFIG_SYS_CLK_FREQ)       //(CONFIG_SYS_CLK_FREQ/CONFIG_HCLK_RATIO)
+#endif //CONFIG_SYS_FPGA
+
+#define CONFIG_SYS_HZ                       1000                                                /*Num of tick/sec (CONFIG_SYS_HZ_CLOCK/CONFIG_SYS_HZ=TIMER_VALUE) */
+
+/*-----------------------------------------------------------------------
+ * Hardware drivers
+ */
+
+
+/*-----------------------------------------------------------------------
+ * Debug Configuration
+ */
+#define CONFIG_KA2000_DEBUG             1
+
+#ifdef CONFIG_KA2000_DEBUG
+#undef CONFIG_CMD_CONSOLE
+#define CONFIG_CMD_RUN
+#define CONFIG_CMD_SPI
+#define CONFIG_CMD_SF
+#define CONFIG_CMD_EDITENV
+//#undef CONFIG_CMD_SAVEENV
+#define CONFIG_SPI_FLASH
+//#define CONFIG_SPI_FLASH_MACRONIX
+#define CONFIG_SPI_FLASH_KA2000
+#define CONFIG_SYS_SPI_WRITE_TOUT   (5 * CONFIG_SYS_HZ)
+//#define CONFIG_ENV_OVERWRITE                                          /*Allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OFFSET                   0x70000                     //0x7D000
+#define CONFIG_ENV_IS_IN_SPI_FLASH                                      //#undef  CONFIG_ENV_IS_IN_SPI_FLASH
+#undef  CONFIG_ENV_IS_NOWHERE
+#undef  CONFIG_ENV_IS_IN_FLASH
+//#define CONFIG_ENV_ADDR		    0x200100
+//#define CONFIG_ENV_SIZE		    (1*1024)
+# define CONFIG_ENV_SPI_BUS             0
+# define CONFIG_ENV_SPI_CS              0
+#define CONFIG_CMD_CLK
+
+#define CONFIG_MMC
+#ifdef CONFIG_MMC
+#define CONFIG_KA2000_MMC                   1
+#undef  CONFIG_GENERIC_MMC
+#define CONFIG_CMD_MMC                      1
+#define CONFIG_CMD_FAT
+#define CONFIG_DOS_PARTITION            1
+
+#if OSC == 12
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+	"console_args=console=ttyS0,19200n8\0"			\
+	"root_args=root=/dev/ram0 rw\0 initrd=0x800000,4M\0"	\
+	"misc_args=mem=30M\0"						\
+	"set_bootargs=setenv bootargs ${console_args} ${root_args} ${misc_args}\0"		\
+	"boot_sd=run set_bootargs; mmc init; fatload mmc 1 208000 image; go 208000\0"	\
+	"bootf=mmc init; go 0x208000\0"	\
+	"bootcmd=run set_bootargs; run bootf\0"
+#else
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+	"console_args=console=ttyS0,38400n8\0"			\
+	"root_args=root=/dev/ram0 rw\0 initrd=0x800000,4M\0"	\
+	"misc_args=mem=30M\0"						\
+	"set_bootargs=setenv bootargs ${console_args} ${root_args} ${misc_args}\0"		\
+	"boot_sd=run set_bootargs; mmc init; fatload mmc 1 208000 image2632; fatload mmc 1 600000 initramfs.gz; go 208000\0"	\
+	"bootf=mmc init; go 0x208000\0"	\
+	"bootcmd=run set_bootargs; run bootf\0"
+#endif
+#endif  //CONFIG_MMC
+//"program_kernel=sf probe 0; mmc init; fatload mmc 1 100000 uImage;  sf erase 200000 380000; sf write 100000 200000 380000; sf read d00000 200000 100; md d00000 10\0"
+//"program_uboot=sf probe 0; mmc init; sf read e00000 3000 20000; fatload mmc 1 e00200 u-boot.bin;  sf erase 3000 20000; sf write e00000 3000 20000; sf read 3200 3200 100; md 3200 10\0"
+/*
+        "tu=mmc init; fatload mmc 1 e00000 u-boot.bin; go e00000 \0" \
+        "tb=mmc init; fatload mmc 1 0 kaboot.bin; go 0\0" \
+        "bu=sf probe 0; sf read e00000 3200 19000; go e00000\0" \
+        "program_kernel=sf probe 0; fatload mmc 1 208000 image; sf erase 200000 480000; sf write 1ffc00 200000 480000\0" \
+        "program_uboot=sf probe 0; sf read e00000 3000 20000; fatload mmc 1 e00200 u-boot.bin;  sf erase 3000 20000; sf write e00000 3000 20000\0" \
+        "program_mtd=sf probe 0; fatload mmc 1 500000 mtd_jffs2.bin; sf erase 700000 100000; sf write 500000 700000 100000\0" \
+ */
+
+#else
+#undef  CONFIG_CMD_SAVEENV
+#define CONFIG_ENV_IS_NOWHERE           1
+#endif  //CONFIG_KA2000_DEBUG
+
+
+/*-----------------------------------------------------------------------
+ * Serial Console Configuration
+ */
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_COM1         0xa0004000                              /*Base address of UART0, =KA_UART_BASE in hardware.h */
+#define CONFIG_SYS_NS16550_REG_SIZE     -4
+#define CONFIG_SYS_NS16550_CLK          (CONFIG_SYS_UART_CLK)                   /*Input clock to NS16550 (eee:12000000,6000000)*/
+#define CONFIG_CONS_INDEX                   1                                   /*Use UART0 for console */
+#if OSC == 12
+#define CONFIG_BAUDRATE                     19200                               /*Default baud rate, ref by arch/arm/lib/board.c (eee:19200,9600) */
+#else
+#define CONFIG_BAUDRATE                     38400                               /*Default baud rate, ref by arch/arm/lib/board.c (eee:19200,9600) */
+#endif
+#define CONFIG_SYS_BAUDRATE_TABLE       { 9600, 19200, 38400, 57600, 115200 }   /*Valid baudrates */
+
+
+/*-----------------------------------------------------------------------
+ * Command line configuration
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_CACHE
+#undef CONFIG_CMD_NET
+//#define CONFIG_CMD_JFFS2						                /*Journaling Flash Filesystem Support */
+//#define CONFIG_CMD_SPI
+//#define CONFIG_CMDLINE_EDITING	1			                /*Enable editing & history functions for cmdline input */
+
+
+/*-----------------------------------------------------------------------
+ * Boot Options
+ */
+#define CONFIG_BOOTDELAY                    3                                       /*Delay (sec) b4 autoboot image, -1 disable autoboot */
+#if OSC == 12
+#define CONFIG_BOOTARGS                     "root=/dev/ram0 rw console=ttyS0,19200n8 mem=30M"
+#else
+#define CONFIG_BOOTARGS                     "root=/dev/ram0 rw console=ttyS0,38400n8 mem=30M"
+#endif
+#define CONFIG_BOOTCOMMAND                  "run set_bootargs; run bootf"    //bootcmd
+//#define CONFIG_BOOTARGS		    "root=/dev/ram0 console=ttySA0,19200n8 init=/linuxrc rw initrd=0xc0800000 mem=32M init=/linuxrc" (eee)
+//#define CONFIG_BOOTCOMMAND		"bootm 0x400000"
+//#define CONFIG_BOOT_RETRY_TIME					            /*Enable boot retry (autoboot stopped), specify retry timeout */
+//#define CONFIG_BOOT_RETRY_MIN						            /*Optional, def to CONFIG_BOOT_RETRY_TIME */
+//#define CONFIG_RESET_TO_RETRY
+//#define CONFIG_AUTOBOOT_KEYED
+//#define CONFIG_AUTOBOOT_PROMPT
+//#define CONFIG_AUTOBOOT_DELAY_STR
+//#define CONFIG_AUTOBOOT_STOP_STR
+//#define CONFIG_ZERO_BOOTDELAY_CHECK
+//#define CONFIG_BOOTCOUNT_LIMIT
+//#define CONFIG_BOOTFILE		"uImage"			            /*Boot file name */
+
+
+/*-----------------------------------------------------------------------
+ * Linux Interfacing
+ */
+#define CONFIG_SYS_LOAD_ADDR        0x208000                            /*Default Linux kernel load address (eee:0x00000000) 0x33000000*/
+#define LINUX_BOOT_PARAM_ADDR           0x000100                        /*ATAG list offset (eee:PHYS_SDRAM_1 + 0x100) 0x700000*/
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_SETUP_MEMORY_TAGS
+
+
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP                 1                                                           /*Undef to save memory */
+#define CONFIG_SYS_PROMPT                   "KA2000# "                                                  /*Monitor Command Prompt */
+#define CONFIG_SYS_CBSIZE                   256                                                         /*Console I/O Buffer Size */
+#define CONFIG_SYS_PBSIZE                   (CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)        /*Print Buffer Size */
+#define CONFIG_SYS_MAXARGS                  16                                                          /*Max number of command args */
+#define CONFIG_SYS_BARGSIZE                 CONFIG_SYS_CBSIZE                                           /*Boot Argument Buffer Size */
+#define CONFIG_VERSION_VARIABLE                                                                         /*Set "ver" env with u-boot version string */
+//#define CONFIG_DISPLAY_CPUINFO					            /*Display cpuinfo with print_cpuinfo(), not implemented */
+//#define CONFIG_DISPLAY_BOARDINFO					            /*Display boardinfo with checkboard(), not implemented */
+//#define CONFIG_HARD_I2C
+
+
+/*-----------------------------------------------------------------------
+ * Memory Info and organization
+ */
+/* SDRAM */
+#define CONFIG_NR_DRAM_BANKS            1                       /* 1 bank of DRAM (arch/arm/lib/board.c) */
+#define PHYS_SDRAM_1                    0x01000000              /* S DRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE               0x01000000              /* Size 16 MB */
+#define CONFIG_SYS_MEMTEST_START        0x01000000
+#define CONFIG_SYS_MEMTEST_END          0x011F0000
+#define CONFIG_SYS_SDRAM_BASE           PHYS_SDRAM_1
+#define CONFIG_SYS_SDRAM_SIZE           PHYS_SDRAM_1_SIZE
+#define CONFIG_SYS_INIT_SP_ADDR	\
+	(CONFIG_SYS_SDRAM_BASE + (4 * 1024) - GENERATED_GBL_DATA_SIZE)
+
+/* Flash */
+#define CONFIG_SYS_FLASH_BASE           0x10000000              /* Physical start address of Flash memory */
+#define CONFIG_SYS_FLASH_SIZE           0x00800000              /* Flash memory size (8MB) */
+#define CONFIG_SYS_MAX_FLASH_BANKS      1                       /* Max number of memory banks */
+#define CONFIG_SYS_MAX_FLASH_SECT       16384                   /* Max number of sectors on 1 chip (include/flash.h) */
+
+#if 1 // For autoload
+#define CONFIG_SYS_TEXT_BASE            0x00002E00
+#else // For testing
+#define CONFIG_SYS_TEXT_BASE            0x00200000
+#endif
+
+/* Environment */
+#define CONFIG_ENV_ADDR                     (CONFIG_SYS_MONITOR_BASE - CONFIG_ENV_SIZE) /*Addr of ENV (env_flash.c) */
+#define CONFIG_ENV_SIZE                     (32 * 1024)                                 //(64*1024)		/*Total size of ENV */
+#define CONFIG_ENV_SECT_SIZE            4096                                            //512
+//#define CONFIG_ENV_IS_NOWHERE		1
+//#define CONFIG_ENV_OVERWRITE						            /*Allow to overwrite serial and ethaddr */
+
+/* Mapping */
+#define CONFIG_SYS_MONITOR_BASE         CONFIG_SYS_TEXT_BASE                    /*Physical start address of boot monitor code */
+#define CONFIG_SYS_MALLOC_LEN           (CONFIG_ENV_SIZE + (128 * 1024))        /*Size of SDRAM reserved for  malloc() & relocated env */
+#define CONFIG_SYS_GBL_DATA_SIZE        128                                     /*Space in bytes reserved for initial data */
+#define CONFIG_STACKSIZE                    (128 * 1024)                        /*Regular stack (stack sizes are set up in start.S) */
+
+#undef CONFIG_USE_IRQ
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ            (4 * 1024)                                      /*IRQ stack size (arch/arm/lib/interrupt.c) */
+#define CONFIG_STACKSIZE_FIQ            (4 * 1024)                                      /*FIQ stack size (arch/arm/lib/interrupt.c) */
+#endif
+
+
+/*-----------------------------------------------------------------------
+ * Init options (start.S, board.c)
+ */
+#define CONFIG_ARCH_CPU_INIT                                                    /*placeholder for arch_cpu_init() in cpu.c */
+#define CONFIG_SKIP_LOWLEVEL_INIT                                               /*No low level (cpu) init required */
+//#define CONFIG_SKIP_RELOCATE_UBOOT					        /*no need to relocate u-boot */
+#define CONFIG_SYS_DISABLE_DCACHE
+//#define CONFIG_SYS_CACHE_TEST
+
+#define CONFIG_IDENT_STRING             " on KeyAsic KA2000"            /*(arch/arm/lib/board.c) */
+#define CONFIG_ARCH_MISC_INIT                                           /*Do arch dependent init with arch_misc_init() */
+#define CONFIG_MISC_INIT_R                                              /*Do platform dependent init with misc_init_r() */
+#define BOARD_LATE_INIT                                                 /*Do board init with board_late_init() */
+
+
+/*-----------------------------------------------------------------------
+ * Flash Support
+ */
+/* enable */
+//#define CONFIG_FLASH_CFI_DRIVER
+//#define CONFIG_SYS_FLASH_CFI
+//#define CONFIG_ENV_IS_IN_SPI_FLASH
+//#define CONFIG_SPI_FLASH_MACRONIX	1
+//#define CONFIG_SYS_SPI_WRITE_TOUT	(5*CONFIG_SYS_HZ)
+//#define CONFIG_SYS_FLASH_SECT_SZ
+//#define CONFIG_SYS_FLASH_ERASE_TOUT	(5*CONFIG_SYS_HZ)               /*Timeout for Flash Erase (ticks) */
+//#define CONFIG_SYS_FLASH_WRITE_TOUT	(5*CONFIG_SYS_HZ)               /*Timeout for Flash Write (ticks) */
+
+/* disable */
+#define CONFIG_SYS_NO_FLASH                                                             /*No need to init flash */
+#undef CONFIG_CMD_IMLS
+#undef CONFIG_CMD_FLASH
+//#undef CONFIG_CMD_SAVEENV
+
+#undef CONFIG_CMD_I2C
+
+#define CONFIG_SYS_ICACHE_OFF
+#define CONFIG_SYS_DCACHE_OFF
+#define CONFIG_SYS_L2CACHE_OFF
+
+#endif  /* __CONFIG_H */
diff --git a/include/configs/ka2000_0929.h b/include/configs/ka2000_0929.h
new file mode 100644
index 0000000..3f9b587
--- /dev/null
+++ b/include/configs/ka2000_0929.h
@@ -0,0 +1,186 @@
+/*
+ * (C) Copyright 2010
+ *
+ * Configuation settings for the KEYASIC KA2000 board.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*-----------------------------------------------------------------------
+ * CPU, Board, SoC Configuration Options
+*/
+#define CONFIG_ARM926EJS		1				/*ARM926EJS CPU Core */
+#define CONFIG_SOC_KA2000		1				/*KeyAsic KA2000 SoC */
+#define CONFIG_KA2000EVM		1				/*Board type*/
+
+
+/*-----------------------------------------------------------------------
+ * Clock, Timer
+*/
+#define CONFIG_SYS_CLK_FREQ		200000000			/*ARM clock freq, input clock of PLL */
+#define CONFIG_SYS_HZ_CLOCK		12000000			/*Timer input clock freq (timer.c) */
+#define	CONFIG_SYS_HZ			1000				/*Num of tick/sec (CONFIG_SYS_HZ_CLOCK/CONFIG_SYS_HZ=TIMER_VALUE) */
+
+
+/*-----------------------------------------------------------------------
+ * Hardware drivers
+ */
+
+
+/*-----------------------------------------------------------------------
+ * Serial Console Configuration
+ */
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_COM1		0xa0004000			/*Base address of UART0, =KA_UART_BASE in hardware.h */	
+#define CONFIG_SYS_NS16550_REG_SIZE	-4
+#define CONFIG_SYS_NS16550_CLK		12000000			/*Input clock to NS16550 */	
+#define CONFIG_CONS_INDEX		1				/*Use UART0 for console */
+#define CONFIG_BAUDRATE			19200				/*Default baud rate, ref by arch/arm/lib/board.c */
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }	/*Valid baudrates */
+
+
+/*-----------------------------------------------------------------------
+ * Command line configuration
+*/
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_CACHE
+#undef CONFIG_CMD_NET
+//#define CONFIG_CMD_JFFS2						/*Journaling Flash Filesystem Support */
+//#define CONFIG_CMD_SPI
+//#define CONFIG_CMDLINE_EDITING		1			/*Enable editing & history functions for cmdline input */
+
+
+/*-----------------------------------------------------------------------
+ * Boot Options
+*/
+#define CONFIG_BOOTDELAY		-1				/*Delay (sec) b4 autoboot image, -1 disable autoboot */
+#define CONFIG_BOOTARGS			"root=/dev/ram0 console=ttySA0,19200n8 init=/linuxrc rw initrd=0xc0800000 mem=32M init=/linuxrc"
+//#define CONFIG_BOOTCOMMAND		"bootm 0x400000"
+//#define CONFIG_BOOT_RETRY_TIME					/*Enable boot retry (autoboot stopped), specify retry timeout */
+//#define CONFIG_BOOT_RETRY_MIN						/*Optional, def to CONFIG_BOOT_RETRY_TIME */
+//#define CONFIG_RESET_TO_RETRY		
+//#define CONFIG_AUTOBOOT_KEYED
+//#define CONFIG_AUTOBOOT_PROMPT
+//#define CONFIG_AUTOBOOT_DELAY_STR
+//#define CONFIG_AUTOBOOT_STOP_STR
+//#define CONFIG_ZERO_BOOTDELAY_CHECK
+//#define CONFIG_BOOTCOUNT_LIMIT
+//#define CONFIG_BOOTFILE		"uImage"			/*Boot file name */
+
+
+/*-----------------------------------------------------------------------
+ * Linux Interfacing
+ */
+#define	CONFIG_SYS_LOAD_ADDR		0x00000000			/*Default Linux kernel load address */
+#define LINUX_BOOT_PARAM_ADDR   	PHYS_SDRAM_1 + 0x100		/*ATAG list offset (0x700000) */
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_SETUP_MEMORY_TAG
+
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+#define	CONFIG_SYS_LONGHELP		1				/*Undef to save memory */
+#define	CONFIG_SYS_PROMPT		"KA2000#"			/*Monitor Command Prompt */
+#define	CONFIG_SYS_CBSIZE		256				/*Console I/O Buffer Size */
+#define	CONFIG_SYS_PBSIZE 		(CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16) /*Print Buffer Size */
+#define	CONFIG_SYS_MAXARGS		16				/*Max number of command args */
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE		/*Boot Argument Buffer Size */
+#define CONFIG_VERSION_VARIABLE						/*Set "ver" env with u-boot version string */
+//#define CONFIG_DISPLAY_CPUINFO					/*Display cpuinfo with print_cpuinfo(), not implemented */
+//#define CONFIG_DISPLAY_BOARDINFO					/*Display boardinfo with checkboard(), not implemented */
+//#define CONFIG_HARD_I2C
+
+
+/*-----------------------------------------------------------------------
+ * Memory Info and organization
+ */
+/* SDRAM */
+#define CONFIG_NR_DRAM_BANKS		1	   			/*1 bank of DRAM (arch/arm/lib/board.c) */
+#define PHYS_SDRAM_1			0x00000000 			/*SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE		0x02000000 			/*Size 32 MB */
+#define CONFIG_SYS_MEMTEST_START	0x01000000
+#define CONFIG_SYS_MEMTEST_END		0x011F0000
+
+/* Flash */
+#define CONFIG_SYS_FLASH_BASE           0x10000000                      /*Physical start address of Flash memory */
+#define CONFIG_SYS_FLASH_SIZE           0x00800000                      /*Flash memory size (8MB) */
+#define CONFIG_SYS_MAX_FLASH_BANKS	1				/*Max number of memory banks */
+#define CONFIG_SYS_MAX_FLASH_SECT	16384				/*Max number of sectors on 1 chip (include/flash.h) */
+
+/* Environment */
+#define CONFIG_ENV_ADDR			(CONFIG_SYS_MONITOR_BASE-CONFIG_ENV_SIZE) /*Addr of ENV (env_flash.c) */
+#define CONFIG_ENV_SIZE			(64*1024)			/*Total size of ENV */
+#define CONFIG_ENV_SECT_SIZE		512
+#define CONFIG_ENV_IS_NOWHERE		1
+//#define CONFIG_ENV_OVERWRITE						/*Allow to overwrite serial and ethaddr */
+
+/* Mapping */
+#define CONFIG_SYS_MONITOR_BASE		TEXT_BASE			/*Physical start address of boot monitor code */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + (128*1024)) 	/*Size of SDRAM reserved for  malloc() & relocated env */
+#define CONFIG_SYS_GBL_DATA_SIZE	128				/*Space in bytes reserved for initial data */
+#define CONFIG_STACKSIZE		(128*1024)			/*Regular stack (stack sizes are set up in start.S) */
+
+#undef CONFIG_USE_IRQ							
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ		(4*1024)			/*IRQ stack size (arch/arm/lib/interrupt.c) */
+#define CONFIG_STACKSIZE_FIQ		(4*1024)			/*FIQ stack size (arch/arm/lib/interrupt.c) */
+#endif
+
+
+/*-----------------------------------------------------------------------
+ * Init options (start.S, board.c)
+ */
+#define CONFIG_ARCH_CPU_INIT         					/*placeholder for arch_cpu_init() in cpu.c */ 
+//#define CONFIG_SKIP_LOWLEVEL_INIT					/*No low level (cpu) init required */
+//#define CONFIG_SKIP_RELOCATE_UBOOT					/*no need to relocate u-boot */
+//#define CONFIG_SYS_DISABLE_DCACHE
+//#define CONFIG_SYS_CACHE_TEST
+
+#define CONFIG_IDENT_STRING     	" on KeyAsic KA2000"		/*(arch/arm/lib/board.c) */
+#define CONFIG_ARCH_MISC_INIT						/*Do arch dependent init with arch_misc_init() */
+#define CONFIG_MISC_INIT_R						/*Do platform dependent init with misc_init_r() */
+//#define BOARD_LATE_INIT						/*Do board init with board_late_init() */
+
+
+/*-----------------------------------------------------------------------
+ * Flash Support
+ */
+/* enable */
+//#define CONFIG_FLASH_CFI_DRIVER
+//#define CONFIG_SYS_FLASH_CFI
+//#define CONFIG_ENV_IS_IN_SPI_FLASH
+//#define CONFIG_SPI_FLASH_MACRONIX	1
+//#define CONFIG_SYS_SPI_WRITE_TOUT	(5*CONFIG_SYS_HZ)
+//#define CONFIG_SYS_FLASH_SECT_SZ
+//#define CONFIG_SYS_FLASH_ERASE_TOUT	(5*CONFIG_SYS_HZ) 		/*Timeout for Flash Erase (ticks) */
+//#define CONFIG_SYS_FLASH_WRITE_TOUT	(5*CONFIG_SYS_HZ) 		/*Timeout for Flash Write (ticks) */
+
+/* disable */
+#define CONFIG_SYS_NO_FLASH						/*No need to init flash */
+#undef CONFIG_CMD_IMLS
+#undef CONFIG_CMD_FLASH
+#undef CONFIG_CMD_SAVEENV
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/ka2000_1108.h b/include/configs/ka2000_1108.h
new file mode 100644
index 0000000..3633f77
--- /dev/null
+++ b/include/configs/ka2000_1108.h
@@ -0,0 +1,187 @@
+/*
+ * (C) Copyright 2010
+ *
+ * Configuation settings for the KEYASIC KA2000 board.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*-----------------------------------------------------------------------
+ * CPU, Board, SoC Configuration Options
+*/
+#define CONFIG_ARM926EJS		1				/*ARM926EJS CPU Core */
+#define CONFIG_SOC_KA2000		1				/*KeyAsic KA2000 SoC */
+#define CONFIG_KA2000EVM		1				/*Board type*/
+
+
+/*-----------------------------------------------------------------------
+ * Clock, Timer
+*/
+#define CONFIG_SYS_CLK_FREQ		200000000			/*ARM clock freq, input clock of PLL */
+#define CONFIG_SYS_HZ_CLOCK		12000000			/*Timer input clock freq (timer.c) */
+#define	CONFIG_SYS_HZ			1000				/*Num of tick/sec (CONFIG_SYS_HZ_CLOCK/CONFIG_SYS_HZ=TIMER_VALUE) */
+
+
+/*-----------------------------------------------------------------------
+ * Hardware drivers
+ */
+
+
+/*-----------------------------------------------------------------------
+ * Serial Console Configuration
+ */
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_COM1		0xa0004000			/*Base address of UART0, =KA_UART_BASE in hardware.h */	
+#define CONFIG_SYS_NS16550_REG_SIZE	-4
+#define CONFIG_SYS_NS16550_CLK		12000000			/*Input clock to NS16550 (eee:12000000,6000000)*/	
+#define CONFIG_CONS_INDEX		1				/*Use UART0 for console */
+#define CONFIG_BAUDRATE			19200				/*Default baud rate, ref by arch/arm/lib/board.c (eee:19200,9600) */
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }	/*Valid baudrates */
+
+
+/*-----------------------------------------------------------------------
+ * Command line configuration
+*/
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_CACHE
+#undef CONFIG_CMD_NET
+//#define CONFIG_CMD_JFFS2						/*Journaling Flash Filesystem Support */
+//#define CONFIG_CMD_SPI
+//#define CONFIG_CMDLINE_EDITING		1			/*Enable editing & history functions for cmdline input */
+
+
+/*-----------------------------------------------------------------------
+ * Boot Options
+*/
+#define CONFIG_BOOTDELAY		-1				/*Delay (sec) b4 autoboot image, -1 disable autoboot */
+#define CONFIG_BOOTARGS			"root=/dev/ram0 rw console=ttyS0,19200n8 rdinit=/linuxrc initrd=0xc0800000,2M mem=32M"
+//#define CONFIG_BOOTARGS			"root=/dev/ram0 console=ttySA0,19200n8 init=/linuxrc rw initrd=0xc0800000 mem=32M init=/linuxrc" (eee)
+//#define CONFIG_BOOTCOMMAND		"bootm 0x400000"
+//#define CONFIG_BOOT_RETRY_TIME					/*Enable boot retry (autoboot stopped), specify retry timeout */
+//#define CONFIG_BOOT_RETRY_MIN						/*Optional, def to CONFIG_BOOT_RETRY_TIME */
+//#define CONFIG_RESET_TO_RETRY		
+//#define CONFIG_AUTOBOOT_KEYED
+//#define CONFIG_AUTOBOOT_PROMPT
+//#define CONFIG_AUTOBOOT_DELAY_STR
+//#define CONFIG_AUTOBOOT_STOP_STR
+//#define CONFIG_ZERO_BOOTDELAY_CHECK
+//#define CONFIG_BOOTCOUNT_LIMIT
+//#define CONFIG_BOOTFILE		"uImage"			/*Boot file name */
+
+
+/*-----------------------------------------------------------------------
+ * Linux Interfacing
+ */
+#define	CONFIG_SYS_LOAD_ADDR		0x208000			/*Default Linux kernel load address (eee:0x00000000) 0x33000000*/ 
+#define LINUX_BOOT_PARAM_ADDR   	0x200100 			/*ATAG list offset (eee:PHYS_SDRAM_1 + 0x100) 0x700000*/
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_SETUP_MEMORY_TAG
+
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+#define	CONFIG_SYS_LONGHELP		1				/*Undef to save memory */
+#define	CONFIG_SYS_PROMPT		"KA2000#"			/*Monitor Command Prompt */
+#define	CONFIG_SYS_CBSIZE		256				/*Console I/O Buffer Size */
+#define	CONFIG_SYS_PBSIZE 		(CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16) /*Print Buffer Size */
+#define	CONFIG_SYS_MAXARGS		16				/*Max number of command args */
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE		/*Boot Argument Buffer Size */
+#define CONFIG_VERSION_VARIABLE						/*Set "ver" env with u-boot version string */
+//#define CONFIG_DISPLAY_CPUINFO					/*Display cpuinfo with print_cpuinfo(), not implemented */
+//#define CONFIG_DISPLAY_BOARDINFO					/*Display boardinfo with checkboard(), not implemented */
+//#define CONFIG_HARD_I2C
+
+
+/*-----------------------------------------------------------------------
+ * Memory Info and organization
+ */
+/* SDRAM */
+#define CONFIG_NR_DRAM_BANKS		1	   			/*1 bank of DRAM (arch/arm/lib/board.c) */
+#define PHYS_SDRAM_1			0x00000000 			/*SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE		0x02000000 			/*Size 32 MB */
+#define CONFIG_SYS_MEMTEST_START	0x01000000
+#define CONFIG_SYS_MEMTEST_END		0x011F0000
+
+/* Flash */
+#define CONFIG_SYS_FLASH_BASE           0x10000000                      /*Physical start address of Flash memory */
+#define CONFIG_SYS_FLASH_SIZE           0x00800000                      /*Flash memory size (8MB) */
+#define CONFIG_SYS_MAX_FLASH_BANKS	1				/*Max number of memory banks */
+#define CONFIG_SYS_MAX_FLASH_SECT	16384				/*Max number of sectors on 1 chip (include/flash.h) */
+
+/* Environment */
+#define CONFIG_ENV_ADDR			(CONFIG_SYS_MONITOR_BASE-CONFIG_ENV_SIZE) /*Addr of ENV (env_flash.c) */
+#define CONFIG_ENV_SIZE			(64*1024)			/*Total size of ENV */
+#define CONFIG_ENV_SECT_SIZE		512
+#define CONFIG_ENV_IS_NOWHERE		1
+//#define CONFIG_ENV_OVERWRITE						/*Allow to overwrite serial and ethaddr */
+
+/* Mapping */
+#define CONFIG_SYS_MONITOR_BASE		TEXT_BASE			/*Physical start address of boot monitor code */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + (128*1024)) 	/*Size of SDRAM reserved for  malloc() & relocated env */
+#define CONFIG_SYS_GBL_DATA_SIZE	128				/*Space in bytes reserved for initial data */
+#define CONFIG_STACKSIZE		(128*1024)			/*Regular stack (stack sizes are set up in start.S) */
+
+#undef CONFIG_USE_IRQ							
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ		(4*1024)			/*IRQ stack size (arch/arm/lib/interrupt.c) */
+#define CONFIG_STACKSIZE_FIQ		(4*1024)			/*FIQ stack size (arch/arm/lib/interrupt.c) */
+#endif
+
+
+/*-----------------------------------------------------------------------
+ * Init options (start.S, board.c)
+ */
+#define CONFIG_ARCH_CPU_INIT         					/*placeholder for arch_cpu_init() in cpu.c */ 
+#define CONFIG_SKIP_LOWLEVEL_INIT					/*No low level (cpu) init required */
+//#define CONFIG_SKIP_RELOCATE_UBOOT					/*no need to relocate u-boot */
+#define CONFIG_SYS_DISABLE_DCACHE
+//#define CONFIG_SYS_CACHE_TEST
+
+#define CONFIG_IDENT_STRING     	" on KeyAsic KA2000"		/*(arch/arm/lib/board.c) */
+#define CONFIG_ARCH_MISC_INIT						/*Do arch dependent init with arch_misc_init() */
+#define CONFIG_MISC_INIT_R						/*Do platform dependent init with misc_init_r() */
+//#define BOARD_LATE_INIT						/*Do board init with board_late_init() */
+
+
+/*-----------------------------------------------------------------------
+ * Flash Support
+ */
+/* enable */
+//#define CONFIG_FLASH_CFI_DRIVER
+//#define CONFIG_SYS_FLASH_CFI
+//#define CONFIG_ENV_IS_IN_SPI_FLASH
+//#define CONFIG_SPI_FLASH_MACRONIX	1
+//#define CONFIG_SYS_SPI_WRITE_TOUT	(5*CONFIG_SYS_HZ)
+//#define CONFIG_SYS_FLASH_SECT_SZ
+//#define CONFIG_SYS_FLASH_ERASE_TOUT	(5*CONFIG_SYS_HZ) 		/*Timeout for Flash Erase (ticks) */
+//#define CONFIG_SYS_FLASH_WRITE_TOUT	(5*CONFIG_SYS_HZ) 		/*Timeout for Flash Write (ticks) */
+
+/* disable */
+#define CONFIG_SYS_NO_FLASH						/*No need to init flash */
+#undef CONFIG_CMD_IMLS
+#undef CONFIG_CMD_FLASH
+#undef CONFIG_CMD_SAVEENV
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/ka2000_1118.h b/include/configs/ka2000_1118.h
new file mode 100644
index 0000000..e7a23cf
--- /dev/null
+++ b/include/configs/ka2000_1118.h
@@ -0,0 +1,231 @@
+/*
+ * (C) Copyright 2010
+ *
+ * Configuation settings for the KEYASIC KA2000 board.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*-----------------------------------------------------------------------
+ * CPU, Board, SoC Configuration Options
+*/
+#define CONFIG_ARM926EJS		1				/*ARM926EJS CPU Core */
+#define CONFIG_SOC_KA2000		1				/*KeyAsic KA2000 SoC */
+#define CONFIG_KA2000EVM		1				/*Board type*/
+
+
+/*-----------------------------------------------------------------------
+ * Clock, Timer
+*/
+#define CONFIG_SYS_CLK_FREQ		200000000			/*ARM clock freq, input clock of PLL */
+#define CONFIG_SYS_HZ_CLOCK		12000000			/*Timer input clock freq (timer.c) */
+#define	CONFIG_SYS_HZ			1000				/*Num of tick/sec (CONFIG_SYS_HZ_CLOCK/CONFIG_SYS_HZ=TIMER_VALUE) */
+
+
+/*-----------------------------------------------------------------------
+ * Hardware drivers
+ */
+
+
+/*-----------------------------------------------------------------------
+ * Debug Configuration
+ */
+#define CONFIG_KA2000_DEBUG 		1 
+
+#ifdef CONFIG_KA2000_DEBUG
+#define CONFIG_CMD_CONSOLE
+#define CONFIG_CMD_RUN
+#define CONFIG_CMD_SPI
+#define CONFIG_CMD_SF
+#define CONFIG_CMD_EDITENV
+#define CONFIG_CMD_SAVEENV
+#define CONFIG_SPI_FLASH
+//#define CONFIG_SPI_FLASH_KA2000
+#define CONFIG_SYS_SPI_WRITE_TOUT	(5*CONFIG_SYS_HZ)
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_ENV_OFFSET		0x7D000
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#undef  CONFIG_ENV_IS_IN_FLASH
+//#define CONFIG_ENV_ADDR		0x200100 
+//#define CONFIG_ENV_SIZE		(1*1024)
+
+#define CONFIG_MMC
+#ifdef CONFIG_MMC
+#define CONFIG_KA2000_MMC		1
+#undef  CONFIG_GENERIC_MMC 
+#define CONFIG_CMD_MMC  		1
+#define CONFIG_CMD_FAT
+#define CONFIG_DOS_PARTITION		1
+#define CONFIG_EXTRA_ENV_SETTINGS       \
+	"console_args=console=ttyS0,19200n8\0"			\
+	"root_args=root=/dev/ram0 rw\0 initrd=0x800000,4M\0"	\
+	"misc_args=mem=30M\0"						\
+	"set_bootargs=setenv bootargs ${console_args} ${root_args} ${misc_args}\0" 		\
+	"boot_sd=run set_bootargs; mmc init; fatload mmc 1 1108000 uImage; bootm 1108000\0"	\
+	"bootcmd=run boot_sd\0"
+#endif	//CONFIG_MMC
+
+#else
+#undef  CONFIG_CMD_SAVEENV
+#define CONFIG_ENV_IS_NOWHERE		1
+#endif	//CONFIG_KA2000_DEBUG
+
+
+/*-----------------------------------------------------------------------
+ * Serial Console Configuration
+ */
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_COM1		0xa0004000			/*Base address of UART0, =KA_UART_BASE in hardware.h */	
+#define CONFIG_SYS_NS16550_REG_SIZE	-4
+#define CONFIG_SYS_NS16550_CLK		12000000			/*Input clock to NS16550 (eee:12000000,6000000)*/	
+#define CONFIG_CONS_INDEX		1				/*Use UART0 for console */
+#define CONFIG_BAUDRATE			19200				/*Default baud rate, ref by arch/arm/lib/board.c (eee:19200,9600) */
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }	/*Valid baudrates */
+
+
+/*-----------------------------------------------------------------------
+ * Command line configuration
+*/
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_CACHE
+#undef CONFIG_CMD_NET
+//#define CONFIG_CMD_JFFS2						/*Journaling Flash Filesystem Support */
+//#define CONFIG_CMD_SPI
+//#define CONFIG_CMDLINE_EDITING		1			/*Enable editing & history functions for cmdline input */
+
+
+/*-----------------------------------------------------------------------
+ * Boot Options
+*/
+#define CONFIG_BOOTDELAY		-1				/*Delay (sec) b4 autoboot image, -1 disable autoboot */
+#define CONFIG_BOOTARGS			"root=/dev/ram0 rw console=ttyS0,19200n8 rdinit=/linuxrc initrd=0xc0800000,2M mem=30M"
+//#define CONFIG_BOOTARGS		"root=/dev/ram0 console=ttySA0,19200n8 init=/linuxrc rw initrd=0xc0800000 mem=32M init=/linuxrc" (eee)
+//#define CONFIG_BOOTCOMMAND		"bootm 0x400000"
+//#define CONFIG_BOOT_RETRY_TIME					/*Enable boot retry (autoboot stopped), specify retry timeout */
+//#define CONFIG_BOOT_RETRY_MIN						/*Optional, def to CONFIG_BOOT_RETRY_TIME */
+//#define CONFIG_RESET_TO_RETRY		
+//#define CONFIG_AUTOBOOT_KEYED
+//#define CONFIG_AUTOBOOT_PROMPT
+//#define CONFIG_AUTOBOOT_DELAY_STR
+//#define CONFIG_AUTOBOOT_STOP_STR
+//#define CONFIG_ZERO_BOOTDELAY_CHECK
+//#define CONFIG_BOOTCOUNT_LIMIT
+//#define CONFIG_BOOTFILE		"uImage"			/*Boot file name */
+
+
+/*-----------------------------------------------------------------------
+ * Linux Interfacing
+ */
+#define	CONFIG_SYS_LOAD_ADDR		0x208000			/*Default Linux kernel load address (eee:0x00000000) 0x33000000*/ 
+#define LINUX_BOOT_PARAM_ADDR   	0x200100 			/*ATAG list offset (eee:PHYS_SDRAM_1 + 0x100) 0x700000*/
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_SETUP_MEMORY_TAG
+
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+#define	CONFIG_SYS_LONGHELP		1				/*Undef to save memory */
+#define	CONFIG_SYS_PROMPT		"KA2000#"			/*Monitor Command Prompt */
+#define	CONFIG_SYS_CBSIZE		256				/*Console I/O Buffer Size */
+#define	CONFIG_SYS_PBSIZE 		(CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16) /*Print Buffer Size */
+#define	CONFIG_SYS_MAXARGS		16				/*Max number of command args */
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE		/*Boot Argument Buffer Size */
+#define CONFIG_VERSION_VARIABLE						/*Set "ver" env with u-boot version string */
+//#define CONFIG_DISPLAY_CPUINFO					/*Display cpuinfo with print_cpuinfo(), not implemented */
+//#define CONFIG_DISPLAY_BOARDINFO					/*Display boardinfo with checkboard(), not implemented */
+//#define CONFIG_HARD_I2C
+
+
+/*-----------------------------------------------------------------------
+ * Memory Info and organization
+ */
+/* SDRAM */
+#define CONFIG_NR_DRAM_BANKS		1	   			/*1 bank of DRAM (arch/arm/lib/board.c) */
+#define PHYS_SDRAM_1			0x00000000 			/*SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE		0x02000000 			/*Size 32 MB */
+#define CONFIG_SYS_MEMTEST_START	0x01000000
+#define CONFIG_SYS_MEMTEST_END		0x011F0000
+
+/* Flash */
+#define CONFIG_SYS_FLASH_BASE           0x10000000                      /*Physical start address of Flash memory */
+#define CONFIG_SYS_FLASH_SIZE           0x00800000                      /*Flash memory size (8MB) */
+#define CONFIG_SYS_MAX_FLASH_BANKS	1				/*Max number of memory banks */
+#define CONFIG_SYS_MAX_FLASH_SECT	16384				/*Max number of sectors on 1 chip (include/flash.h) */
+
+/* Environment */
+#define CONFIG_ENV_ADDR			(CONFIG_SYS_MONITOR_BASE-CONFIG_ENV_SIZE) /*Addr of ENV (env_flash.c) */
+#define CONFIG_ENV_SIZE			(64*1024)			/*Total size of ENV */
+#define CONFIG_ENV_SECT_SIZE		512
+//#define CONFIG_ENV_IS_NOWHERE		1
+//#define CONFIG_ENV_OVERWRITE						/*Allow to overwrite serial and ethaddr */
+
+/* Mapping */
+#define CONFIG_SYS_MONITOR_BASE		TEXT_BASE			/*Physical start address of boot monitor code */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + (128*1024)) 	/*Size of SDRAM reserved for  malloc() & relocated env */
+#define CONFIG_SYS_GBL_DATA_SIZE	128				/*Space in bytes reserved for initial data */
+#define CONFIG_STACKSIZE		(128*1024)			/*Regular stack (stack sizes are set up in start.S) */
+
+#undef CONFIG_USE_IRQ							
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ		(4*1024)			/*IRQ stack size (arch/arm/lib/interrupt.c) */
+#define CONFIG_STACKSIZE_FIQ		(4*1024)			/*FIQ stack size (arch/arm/lib/interrupt.c) */
+#endif
+
+
+/*-----------------------------------------------------------------------
+ * Init options (start.S, board.c)
+ */
+#define CONFIG_ARCH_CPU_INIT         					/*placeholder for arch_cpu_init() in cpu.c */ 
+#define CONFIG_SKIP_LOWLEVEL_INIT					/*No low level (cpu) init required */
+//#define CONFIG_SKIP_RELOCATE_UBOOT					/*no need to relocate u-boot */
+#define CONFIG_SYS_DISABLE_DCACHE
+//#define CONFIG_SYS_CACHE_TEST
+
+#define CONFIG_IDENT_STRING     	" on KeyAsic KA2000"		/*(arch/arm/lib/board.c) */
+#define CONFIG_ARCH_MISC_INIT						/*Do arch dependent init with arch_misc_init() */
+#define CONFIG_MISC_INIT_R						/*Do platform dependent init with misc_init_r() */
+//#define BOARD_LATE_INIT						/*Do board init with board_late_init() */
+
+
+/*-----------------------------------------------------------------------
+ * Flash Support
+ */
+/* enable */
+//#define CONFIG_FLASH_CFI_DRIVER
+//#define CONFIG_SYS_FLASH_CFI
+//#define CONFIG_ENV_IS_IN_SPI_FLASH
+//#define CONFIG_SPI_FLASH_MACRONIX	1
+//#define CONFIG_SYS_SPI_WRITE_TOUT	(5*CONFIG_SYS_HZ)
+//#define CONFIG_SYS_FLASH_SECT_SZ
+//#define CONFIG_SYS_FLASH_ERASE_TOUT	(5*CONFIG_SYS_HZ) 		/*Timeout for Flash Erase (ticks) */
+//#define CONFIG_SYS_FLASH_WRITE_TOUT	(5*CONFIG_SYS_HZ) 		/*Timeout for Flash Write (ticks) */
+
+/* disable */
+#define CONFIG_SYS_NO_FLASH						/*No need to init flash */
+#undef CONFIG_CMD_IMLS
+#undef CONFIG_CMD_FLASH
+//#undef CONFIG_CMD_SAVEENV
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/ka2000_boot1.h b/include/configs/ka2000_boot1.h
new file mode 100644
index 0000000..78e2914
--- /dev/null
+++ b/include/configs/ka2000_boot1.h
@@ -0,0 +1,236 @@
+/*
+ * (C) Copyright 2010
+ *
+ * Configuation settings for the KEYASIC KA2000 board.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*-----------------------------------------------------------------------
+ * CPU, Board, SoC Configuration Options
+*/
+#define CONFIG_ARM926EJS		1				/*ARM926EJS CPU Core */
+#define CONFIG_SOC_KA2000		1				/*KeyAsic KA2000 SoC */
+#define CONFIG_KA2000EVM		1				/*Board type*/
+
+
+/*-----------------------------------------------------------------------
+ * Clock, Timer
+*/
+#define CONFIG_SYS_CLK_FREQ		200000000			/*ARM clock freq, input clock of PLL */
+#define CONFIG_SYS_HZ_CLOCK		24000000 //96000000 //(192000000)			/*Timer input clock freq (timer.c) */
+#define	CONFIG_SYS_HZ			1000				/*Num of tick/sec (CONFIG_SYS_HZ_CLOCK/CONFIG_SYS_HZ=TIMER_VALUE) */
+
+
+/*-----------------------------------------------------------------------
+ * Hardware drivers
+ */
+
+
+/*-----------------------------------------------------------------------
+ * Debug Configuration
+ */
+#define CONFIG_KA2000_DEBUG 		1
+
+#ifdef CONFIG_KA2000_DEBUG
+#define CONFIG_CMD_CONSOLE
+#define CONFIG_CMD_RUN
+#define CONFIG_CMD_SPI
+#define CONFIG_CMD_SF
+#define CONFIG_CMD_EDITENV
+#define CONFIG_CMD_SAVEENV
+#define CONFIG_SPI_FLASH
+//#define CONFIG_SPI_FLASH_MACRONIX
+#define CONFIG_SPI_FLASH_KA2000
+#define CONFIG_SYS_SPI_WRITE_TOUT	(5*CONFIG_SYS_HZ)
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_ENV_OFFSET		0x7D000
+#undef  CONFIG_ENV_IS_IN_SPI_FLASH
+#undef  CONFIG_ENV_IS_IN_FLASH
+//#define CONFIG_ENV_ADDR		0x200100
+//#define CONFIG_ENV_SIZE		(1*1024)
+
+#define CONFIG_MMC
+#ifdef CONFIG_MMC
+#define CONFIG_KA2000_MMC		1
+#undef  CONFIG_GENERIC_MMC
+#define CONFIG_CMD_MMC  		1
+#define CONFIG_CMD_FAT
+#define CONFIG_DOS_PARTITION		1
+#define CONFIG_EXTRA_ENV_SETTINGS       \
+	"console_args=console=ttyS0,19200n8\0"			\
+	"root_args=root=/dev/ram0 rw\0 initrd=0x800000,4M\0"	\
+	"misc_args=mem=30M\0"						\
+	"set_bootargs=setenv bootargs ${console_args} ${root_args} ${misc_args}\0" 		\
+	"boot_sd=run set_bootargs; mmc init; fatload mmc 1 100000 uImage; bootm 100000\0"	\
+	"bootz=run set_bootargs; mmc init; fatload mmc 1 100000 uImage; bootm 100000\0" \
+	"bootf=run set_bootargs; bootm 1ffc00\0" \
+	"tu=mmc init; fatload mmc 1 100000 u-boot.bin; go 100000\0" \
+	"bootcmd=run bootf\0"
+#endif	//CONFIG_MMC
+
+#else
+#undef  CONFIG_CMD_SAVEENV
+#define CONFIG_ENV_IS_NOWHERE		1
+#endif	//CONFIG_KA2000_DEBUG
+
+
+/*-----------------------------------------------------------------------
+ * Serial Console Configuration
+ */
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_COM1		0xa0004000			/*Base address of UART0, =KA_UART_BASE in hardware.h */
+#define CONFIG_SYS_NS16550_REG_SIZE	-4
+#define CONFIG_SYS_NS16550_CLK		(CONFIG_SYS_HZ_CLOCK)			/*Input clock to NS16550 (eee:12000000,6000000)*/
+#define CONFIG_CONS_INDEX		1				/*Use UART0 for console */
+#define CONFIG_BAUDRATE			38400				/*Default baud rate, ref by arch/arm/lib/board.c (eee:19200,9600) */
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }	/*Valid baudrates */
+
+
+/*-----------------------------------------------------------------------
+ * Command line configuration
+*/
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_CACHE
+#undef CONFIG_CMD_NET
+//#define CONFIG_CMD_JFFS2						/*Journaling Flash Filesystem Support */
+//#define CONFIG_CMD_SPI
+//#define CONFIG_CMDLINE_EDITING		1			/*Enable editing & history functions for cmdline input */
+
+
+/*-----------------------------------------------------------------------
+ * Boot Options
+*/
+#define CONFIG_BOOTDELAY		5				/*Delay (sec) b4 autoboot image, -1 disable autoboot */
+#define CONFIG_BOOTARGS			"root=/dev/ram0 rw console=ttyS0,19200n8 mem=30M"
+#define CONFIG_BOOTCOMMAND		"run boot_sd"
+//#define CONFIG_BOOTARGS		"root=/dev/ram0 console=ttySA0,19200n8 init=/linuxrc rw initrd=0xc0800000 mem=32M init=/linuxrc" (eee)
+//#define CONFIG_BOOTCOMMAND		"bootm 0x400000"
+//#define CONFIG_BOOT_RETRY_TIME					/*Enable boot retry (autoboot stopped), specify retry timeout */
+//#define CONFIG_BOOT_RETRY_MIN						/*Optional, def to CONFIG_BOOT_RETRY_TIME */
+//#define CONFIG_RESET_TO_RETRY
+//#define CONFIG_AUTOBOOT_KEYED
+//#define CONFIG_AUTOBOOT_PROMPT
+//#define CONFIG_AUTOBOOT_DELAY_STR
+//#define CONFIG_AUTOBOOT_STOP_STR
+//#define CONFIG_ZERO_BOOTDELAY_CHECK
+//#define CONFIG_BOOTCOUNT_LIMIT
+//#define CONFIG_BOOTFILE		"uImage"			/*Boot file name */
+
+
+/*-----------------------------------------------------------------------
+ * Linux Interfacing
+ */
+#define	CONFIG_SYS_LOAD_ADDR		0x208000			/*Default Linux kernel load address (eee:0x00000000) 0x33000000*/
+#define LINUX_BOOT_PARAM_ADDR   	0x200100 			/*ATAG list offset (eee:PHYS_SDRAM_1 + 0x100) 0x700000*/
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_SETUP_MEMORY_TAG
+
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+#define	CONFIG_SYS_LONGHELP		1				/*Undef to save memory */
+#define	CONFIG_SYS_PROMPT		"KA2000#"			/*Monitor Command Prompt */
+#define	CONFIG_SYS_CBSIZE		256				/*Console I/O Buffer Size */
+#define	CONFIG_SYS_PBSIZE 		(CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16) /*Print Buffer Size */
+#define	CONFIG_SYS_MAXARGS		16				/*Max number of command args */
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE		/*Boot Argument Buffer Size */
+#define CONFIG_VERSION_VARIABLE						/*Set "ver" env with u-boot version string */
+//#define CONFIG_DISPLAY_CPUINFO					/*Display cpuinfo with print_cpuinfo(), not implemented */
+//#define CONFIG_DISPLAY_BOARDINFO					/*Display boardinfo with checkboard(), not implemented */
+//#define CONFIG_HARD_I2C
+
+
+/*-----------------------------------------------------------------------
+ * Memory Info and organization
+ */
+/* SDRAM */
+#define CONFIG_NR_DRAM_BANKS		1	   			/*1 bank of DRAM (arch/arm/lib/board.c) */
+#define PHYS_SDRAM_1			0x00000000 			/*SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE		0x02000000 			/*Size 32 MB */
+#define CONFIG_SYS_MEMTEST_START	0x01000000
+#define CONFIG_SYS_MEMTEST_END		0x011F0000
+
+/* Flash */
+#define CONFIG_SYS_FLASH_BASE           0x10000000                      /*Physical start address of Flash memory */
+#define CONFIG_SYS_FLASH_SIZE           0x00800000                      /*Flash memory size (8MB) */
+#define CONFIG_SYS_MAX_FLASH_BANKS	1				/*Max number of memory banks */
+#define CONFIG_SYS_MAX_FLASH_SECT	16384				/*Max number of sectors on 1 chip (include/flash.h) */
+
+/* Environment */
+#define CONFIG_ENV_ADDR			(CONFIG_SYS_MONITOR_BASE-CONFIG_ENV_SIZE) /*Addr of ENV (env_flash.c) */
+#define CONFIG_ENV_SIZE			(64*1024)			/*Total size of ENV */
+#define CONFIG_ENV_SECT_SIZE		512
+#define CONFIG_ENV_IS_NOWHERE		1
+//#define CONFIG_ENV_OVERWRITE						/*Allow to overwrite serial and ethaddr */
+
+/* Mapping */
+#define CONFIG_SYS_MONITOR_BASE		TEXT_BASE			/*Physical start address of boot monitor code */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + (128*1024)) 	/*Size of SDRAM reserved for  malloc() & relocated env */
+#define CONFIG_SYS_GBL_DATA_SIZE	128				/*Space in bytes reserved for initial data */
+#define CONFIG_STACKSIZE		(128*1024)			/*Regular stack (stack sizes are set up in start.S) */
+
+#undef CONFIG_USE_IRQ
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ		(4*1024)			/*IRQ stack size (arch/arm/lib/interrupt.c) */
+#define CONFIG_STACKSIZE_FIQ		(4*1024)			/*FIQ stack size (arch/arm/lib/interrupt.c) */
+#endif
+
+
+/*-----------------------------------------------------------------------
+ * Init options (start.S, board.c)
+ */
+#define CONFIG_ARCH_CPU_INIT         					/*placeholder for arch_cpu_init() in cpu.c */
+#define CONFIG_SKIP_LOWLEVEL_INIT					/*No low level (cpu) init required */
+//#define CONFIG_SKIP_RELOCATE_UBOOT					/*no need to relocate u-boot */
+#define CONFIG_SYS_DISABLE_DCACHE
+//#define CONFIG_SYS_CACHE_TEST
+
+#define CONFIG_IDENT_STRING     	" on KeyAsic KA2000"		/*(arch/arm/lib/board.c) */
+#define CONFIG_ARCH_MISC_INIT						/*Do arch dependent init with arch_misc_init() */
+#define CONFIG_MISC_INIT_R						/*Do platform dependent init with misc_init_r() */
+//#define BOARD_LATE_INIT						/*Do board init with board_late_init() */
+
+
+/*-----------------------------------------------------------------------
+ * Flash Support
+ */
+/* enable */
+//#define CONFIG_FLASH_CFI_DRIVER
+//#define CONFIG_SYS_FLASH_CFI
+//#define CONFIG_ENV_IS_IN_SPI_FLASH
+//#define CONFIG_SPI_FLASH_MACRONIX	1
+//#define CONFIG_SYS_SPI_WRITE_TOUT	(5*CONFIG_SYS_HZ)
+//#define CONFIG_SYS_FLASH_SECT_SZ
+//#define CONFIG_SYS_FLASH_ERASE_TOUT	(5*CONFIG_SYS_HZ) 		/*Timeout for Flash Erase (ticks) */
+//#define CONFIG_SYS_FLASH_WRITE_TOUT	(5*CONFIG_SYS_HZ) 		/*Timeout for Flash Write (ticks) */
+
+/* disable */
+#define CONFIG_SYS_NO_FLASH						/*No need to init flash */
+#undef CONFIG_CMD_IMLS
+#undef CONFIG_CMD_FLASH
+//#undef CONFIG_CMD_SAVEENV
+
+#endif	/* __CONFIG_H */
diff --git a/include/part.h b/include/part.h
index e1478f4..f574f5e 100644
--- a/include/part.h
+++ b/include/part.h
@@ -52,6 +52,12 @@ typedef struct block_dev_desc {
 	unsigned long   (*block_erase)(int dev,
 				       unsigned long start,
 				       lbaint_t blkcnt);
+	unsigned long   (*sd_cmd)(int dev,
+				  unsigned char cmd,
+				  unsigned int cmdarg,
+				  unsigned int ctrl,
+				  const void *buffer);
+
 	void		*priv;		/* driver private struct pointer */
 }block_dev_desc_t;
 
diff --git a/include/part_cmd.h b/include/part_cmd.h
new file mode 100644
index 0000000..008a29d
--- /dev/null
+++ b/include/part_cmd.h
@@ -0,0 +1,152 @@
+/*
+ * (C) Copyright 2000-2004
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _PART_H
+#define _PART_H
+
+#include <ide.h>
+
+typedef struct block_dev_desc {
+	int		if_type;	/* type of the interface */
+	int		dev;		/* device number */
+	unsigned char	part_type;	/* partition type */
+	unsigned char	target;		/* target SCSI ID */
+	unsigned char	lun;		/* target LUN */
+	unsigned char	type;		/* device type */
+	unsigned char	removable;	/* removable device */
+#ifdef CONFIG_LBA48
+	unsigned char	lba48;		/* device can use 48bit addr (ATA/ATAPI v7) */
+#endif
+	lbaint_t		lba;		/* number of blocks */
+	unsigned long	blksz;		/* block size */
+	char		vendor [40+1];	/* IDE model, SCSI Vendor */
+	char		product[20+1];	/* IDE Serial no, SCSI product */
+	char		revision[8+1];	/* firmware revision */
+	unsigned long	(*block_read)(int dev,
+				      unsigned long start,
+				      lbaint_t blkcnt,
+				      void *buffer);
+	unsigned long	(*block_write)(int dev,
+				       unsigned long start,
+				       lbaint_t blkcnt,
+				       const void *buffer);
+    unsigned long	(*sd_cmd)(int dev,
+				       unsigned char cmd,
+				       unsigned int cmdarg,
+				       unsigned int ctrl,
+				       const void *buffer);
+	void		*priv;		/* driver private struct pointer */
+}block_dev_desc_t;
+
+/* Interface types: */
+#define IF_TYPE_UNKNOWN		0
+#define IF_TYPE_IDE		1
+#define IF_TYPE_SCSI		2
+#define IF_TYPE_ATAPI		3
+#define IF_TYPE_USB		4
+#define IF_TYPE_DOC		5
+#define IF_TYPE_MMC		6
+#define IF_TYPE_SD		7
+#define IF_TYPE_SATA		8
+
+/* Part types */
+#define PART_TYPE_UNKNOWN	0x00
+#define PART_TYPE_MAC		0x01
+#define PART_TYPE_DOS		0x02
+#define PART_TYPE_ISO		0x03
+#define PART_TYPE_AMIGA		0x04
+#define PART_TYPE_EFI		0x05
+
+/*
+ * Type string for U-Boot bootable partitions
+ */
+#define BOOT_PART_TYPE	"U-Boot"	/* primary boot partition type	*/
+#define BOOT_PART_COMP	"PPCBoot"	/* PPCBoot compatibility type	*/
+
+/* device types */
+#define DEV_TYPE_UNKNOWN	0xff	/* not connected */
+#define DEV_TYPE_HARDDISK	0x00	/* harddisk */
+#define DEV_TYPE_TAPE		0x01	/* Tape */
+#define DEV_TYPE_CDROM		0x05	/* CD-ROM */
+#define DEV_TYPE_OPDISK		0x07	/* optical disk */
+
+typedef struct disk_partition {
+	ulong	start;		/* # of first block in partition	*/
+	ulong	size;		/* number of blocks in partition	*/
+	ulong	blksz;		/* block size in bytes			*/
+	uchar	name[32];	/* partition name			*/
+	uchar	type[32];	/* string type description		*/
+} disk_partition_t;
+
+/* Misc _get_dev functions */
+block_dev_desc_t* get_dev(char* ifname, int dev);
+block_dev_desc_t* ide_get_dev(int dev);
+block_dev_desc_t* sata_get_dev(int dev);
+block_dev_desc_t* scsi_get_dev(int dev);
+block_dev_desc_t* usb_stor_get_dev(int dev);
+block_dev_desc_t* mmc_get_dev(int dev);
+block_dev_desc_t* systemace_get_dev(int dev);
+block_dev_desc_t* mg_disk_get_dev(int dev);
+
+/* disk/part.c */
+int get_partition_info (block_dev_desc_t * dev_desc, int part, disk_partition_t *info);
+void print_part (block_dev_desc_t *dev_desc);
+void  init_part (block_dev_desc_t *dev_desc);
+void dev_print(block_dev_desc_t *dev_desc);
+
+
+#ifdef CONFIG_MAC_PARTITION
+/* disk/part_mac.c */
+int get_partition_info_mac (block_dev_desc_t * dev_desc, int part, disk_partition_t *info);
+void print_part_mac (block_dev_desc_t *dev_desc);
+int   test_part_mac (block_dev_desc_t *dev_desc);
+#endif
+
+#ifdef CONFIG_DOS_PARTITION
+/* disk/part_dos.c */
+int get_partition_info_dos (block_dev_desc_t * dev_desc, int part, disk_partition_t *info);
+void print_part_dos (block_dev_desc_t *dev_desc);
+int   test_part_dos (block_dev_desc_t *dev_desc);
+#endif
+
+#ifdef CONFIG_ISO_PARTITION
+/* disk/part_iso.c */
+int get_partition_info_iso (block_dev_desc_t * dev_desc, int part, disk_partition_t *info);
+void print_part_iso (block_dev_desc_t *dev_desc);
+int   test_part_iso (block_dev_desc_t *dev_desc);
+#endif
+
+#ifdef CONFIG_AMIGA_PARTITION
+/* disk/part_amiga.c */
+int get_partition_info_amiga (block_dev_desc_t * dev_desc, int part, disk_partition_t *info);
+void print_part_amiga (block_dev_desc_t *dev_desc);
+int   test_part_amiga (block_dev_desc_t *dev_desc);
+#endif
+
+#ifdef CONFIG_EFI_PARTITION
+/* disk/part_efi.c */
+int get_partition_info_efi (block_dev_desc_t * dev_desc, int part, disk_partition_t *info);
+void print_part_efi (block_dev_desc_t *dev_desc);
+int   test_part_efi (block_dev_desc_t *dev_desc);
+#endif
+
+#endif /* _PART_H */
diff --git a/keyasic_config.sh b/keyasic_config.sh
new file mode 100644
index 0000000..aff53db
--- /dev/null
+++ b/keyasic_config.sh
@@ -0,0 +1,2 @@
+make distclean ARCH=arm CROSS_COMPILE=/home/arm-2011.03/bin/arm-none-eabi-
+make ka2000_config ARCH=arm CROSS_COMPILE=/home/arm-2011.03/bin/arm-none-eabi-
diff --git a/keyasic_make.sh b/keyasic_make.sh
new file mode 100644
index 0000000..e3b722e
--- /dev/null
+++ b/keyasic_make.sh
@@ -0,0 +1 @@
+make ARCH=arm CROSS_COMPILE=/home/arm-2011.03/bin/arm-none-eabi-
-- 
1.7.9.5

